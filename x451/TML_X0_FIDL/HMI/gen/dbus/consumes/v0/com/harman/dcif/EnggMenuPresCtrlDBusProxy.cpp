/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v0/com/harman/dcif/EnggMenuPresCtrlDBusProxy.hpp>

namespace v0 {
namespace com {
namespace harman {
namespace dcif {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createEnggMenuPresCtrlDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<EnggMenuPresCtrlDBusProxy>(_address, _connection);
}

INITIALIZER(registerEnggMenuPresCtrlDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		EnggMenuPresCtrl::getInterface(),
		&createEnggMenuPresCtrlDBusProxy);
}

EnggMenuPresCtrlDBusProxy::EnggMenuPresCtrlDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		logStatus_(*this, "onLogStatusAttributeChanged", "setLogStatusAttribute", "(bbbb)", "getLogStatusAttribute", static_cast<::v0::com::harman::dcif::EnggMenuTypes_::loggingStatusDeployment_t*>(nullptr)),
		tunerData_(*this, "onTunerDataAttributeChanged", "setTunerDataAttribute", "(ssuyn)", "getTunerDataAttribute", static_cast<::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t*>(nullptr)),
		mediaData_(*this, "onMediaDataAttributeChanged", "setMediaDataAttribute", "(ssss)", "getMediaDataAttribute", static_cast<::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t*>(nullptr))
,		factoryResetComplete_(*this, "factoryResetComplete", "b", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}

      EnggMenuPresCtrlDBusProxy::LogStatusAttribute& EnggMenuPresCtrlDBusProxy::getLogStatusAttribute() {
          return logStatus_;
      }
      EnggMenuPresCtrlDBusProxy::TunerDataAttribute& EnggMenuPresCtrlDBusProxy::getTunerDataAttribute() {
          return tunerData_;
      }
      EnggMenuPresCtrlDBusProxy::MediaDataAttribute& EnggMenuPresCtrlDBusProxy::getMediaDataAttribute() {
          return mediaData_;
      }

EnggMenuPresCtrlDBusProxy::FactoryResetCompleteEvent& EnggMenuPresCtrlDBusProxy::getFactoryResetCompleteEvent() {
    return factoryResetComplete_;
}
    
    /**
     * description: method to start logging of DBUS,DLT RAM and CPU Measurement logs 		DBUS_LOGS =
     *   0 		DLT_LOGS = 1 		CPU_MEASUREMENT_LOGS = 2 		RAM_MEASUREMENT_LOGS = 3
     */
    void EnggMenuPresCtrlDBusProxy::startLogging(const ::v0::com::harman::dcif::EnggMenuTypes::logType &_typeOfLogs, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::logType &_activeLogType, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_typeOfLogs(_typeOfLogs, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_activeLogType(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "startLogging",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_typeOfLogs,
_internalCallStatus,
deploy_activeLogType, deploy_status);
_activeLogType = deploy_activeLogType.getValue();
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::startLoggingAsync(const ::v0::com::harman::dcif::EnggMenuTypes::logType &_typeOfLogs, StartLoggingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_typeOfLogs(_typeOfLogs, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_activeLogType(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "startLogging",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_typeOfLogs,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> _activeLogType, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _activeLogType.getValue(), _status.getValue());
        },
        std::make_tuple(deploy_activeLogType, deploy_status));
    }
    /**
     * description: method to start logging of DBUS,DLT RAM and CPU Measurement logs
     */
    void EnggMenuPresCtrlDBusProxy::startSystemLogging(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "startSystemLogging",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::startSystemLoggingAsync(StartSystemLoggingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "startSystemLogging",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: method to stop logging of DBUS,DLT RAM and CPU Measurement logs
     */
    void EnggMenuPresCtrlDBusProxy::stopSystemLogging(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "stopSystemLogging",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::stopSystemLoggingAsync(StopSystemLoggingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "stopSystemLogging",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    void EnggMenuPresCtrlDBusProxy::extractLogs(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum &_logError, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum, CommonAPI::EmptyDeployment> deploy_logError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "extractLogs",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_logError);
_logError = deploy_logError.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::extractLogsAsync(ExtractLogsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum, CommonAPI::EmptyDeployment> deploy_logError(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "extractLogs",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum, CommonAPI::EmptyDeployment> _logError) {
        	if (_callback)
        		_callback(_internalCallStatus, _logError.getValue());
        },
        std::make_tuple(deploy_logError));
    }
    /**
     * description: method to stop logging of DBUS,DLT RAM and CPU Measurement logs 		DBUS_LOGS = 0
     *   		DLT_LOGS = 1 		CPU_MEASUREMENT_LOGS = 2 		RAM_MEASUREMENT_LOGS = 3
     */
    void EnggMenuPresCtrlDBusProxy::stopLogging(const ::v0::com::harman::dcif::EnggMenuTypes::logType &_typeOfLogs, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::logType &_activeLogType, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_typeOfLogs(_typeOfLogs, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_activeLogType(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "stopLogging",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_typeOfLogs,
_internalCallStatus,
deploy_activeLogType, deploy_status);
_activeLogType = deploy_activeLogType.getValue();
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::stopLoggingAsync(const ::v0::com::harman::dcif::EnggMenuTypes::logType &_typeOfLogs, StopLoggingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_typeOfLogs(_typeOfLogs, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> deploy_activeLogType(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "stopLogging",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_typeOfLogs,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::logType, CommonAPI::EmptyDeployment> _activeLogType, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _activeLogType.getValue(), _status.getValue());
        },
        std::make_tuple(deploy_activeLogType, deploy_status));
    }
    /**
     * description: method to set Display Brightness
     */
    void EnggMenuPresCtrlDBusProxy::setDisplayBrightness(const uint16_t &_brightnessValue, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(_brightnessValue, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setDisplayBrightness",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_brightnessValue,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::setDisplayBrightnessAsync(const uint16_t &_brightnessValue, SetDisplayBrightnessAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(_brightnessValue, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setDisplayBrightness",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_brightnessValue,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: method to read Display Brightness
     */
    void EnggMenuPresCtrlDBusProxy::getDisplayBrightness(CommonAPI::CallStatus &_internalCallStatus, uint16_t &_brightnessValue, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getDisplayBrightness",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_brightnessValue, deploy_status);
_brightnessValue = deploy_brightnessValue.getValue();
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::getDisplayBrightnessAsync(GetDisplayBrightnessAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getDisplayBrightness",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> _brightnessValue, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _brightnessValue.getValue(), _status.getValue());
        },
        std::make_tuple(deploy_brightnessValue, deploy_status));
    }
    /**
     * description: method to set Button Panel Brightness
     */
    void EnggMenuPresCtrlDBusProxy::setButtonPanelBrightness(const uint16_t &_brightnessValue, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(_brightnessValue, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setButtonPanelBrightness",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_brightnessValue,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::setButtonPanelBrightnessAsync(const uint16_t &_brightnessValue, SetButtonPanelBrightnessAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(_brightnessValue, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setButtonPanelBrightness",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_brightnessValue,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: method to read Button Panel Brightness
     */
    void EnggMenuPresCtrlDBusProxy::getButtonPanelBrightness(CommonAPI::CallStatus &_internalCallStatus, uint16_t &_brightnessValue, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getButtonPanelBrightness",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_brightnessValue, deploy_status);
_brightnessValue = deploy_brightnessValue.getValue();
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::getButtonPanelBrightnessAsync(GetButtonPanelBrightnessAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_brightnessValue(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getButtonPanelBrightness",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> _brightnessValue, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _brightnessValue.getValue(), _status.getValue());
        },
        std::make_tuple(deploy_brightnessValue, deploy_status));
    }
    /**
     * description: method to read media type
     */
    void EnggMenuPresCtrlDBusProxy::getMediaType(CommonAPI::CallStatus &_internalCallStatus, std::string &_mediaType, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_mediaType(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getMediaType",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_mediaType, deploy_status);
_mediaType = deploy_mediaType.getValue();
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::getMediaTypeAsync(GetMediaTypeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_mediaType(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getMediaType",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _mediaType, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _mediaType.getValue(), _status.getValue());
        },
        std::make_tuple(deploy_mediaType, deploy_status));
    }
    /**
     * description: method to read track name
     */
    void EnggMenuPresCtrlDBusProxy::getTrackName(CommonAPI::CallStatus &_internalCallStatus, std::string &_trackName, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_trackName(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getTrackName",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_trackName, deploy_status);
_trackName = deploy_trackName.getValue();
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::getTrackNameAsync(GetTrackNameAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_trackName(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getTrackName",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _trackName, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _trackName.getValue(), _status.getValue());
        },
        std::make_tuple(deploy_trackName, deploy_status));
    }
    /**
     * description: method to launch/stop test automation service
     */
    void EnggMenuPresCtrlDBusProxy::testAutomationLaunch(const bool &_isEnable, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_isEnable(_isEnable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "testAutomationLaunch",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_isEnable,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::testAutomationLaunchAsync(const bool &_isEnable, TestAutomationLaunchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_isEnable(_isEnable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "testAutomationLaunch",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_isEnable,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: method to set the system IP- Static/Dynamic
     */
    void EnggMenuPresCtrlDBusProxy::setSystemIP(const ::v0::com::harman::dcif::EnggMenuTypes::ipType_enum &_typeOfIP, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::ipType_enum, CommonAPI::EmptyDeployment> deploy_typeOfIP(_typeOfIP, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::ipType_enum, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSystemIP",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_typeOfIP,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::setSystemIPAsync(const ::v0::com::harman::dcif::EnggMenuTypes::ipType_enum &_typeOfIP, SetSystemIPAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::ipType_enum, CommonAPI::EmptyDeployment> deploy_typeOfIP(_typeOfIP, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::ipType_enum, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSystemIP",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_typeOfIP,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: method to read the  		tuner data.
     */
    void EnggMenuPresCtrlDBusProxy::getTunerData(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::tunerInfo &_tunerData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::tunerInfo, ::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t> deploy_tunerData(static_cast<::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::tunerInfo,::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getTunerData",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_tunerData);
_tunerData = deploy_tunerData.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::getTunerDataAsync(GetTunerDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::tunerInfo, ::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t> deploy_tunerData(static_cast<::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::tunerInfo,::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getTunerData",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::tunerInfo, ::v0::com::harman::dcif::EnggMenuTypes_::tunerInfoDeployment_t> _tunerData) {
        	if (_callback)
        		_callback(_internalCallStatus, _tunerData.getValue());
        },
        std::make_tuple(deploy_tunerData));
    }
    /**
     * description: method to read the media data.
     */
    void EnggMenuPresCtrlDBusProxy::getMediaData(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::mediaInfo &_mediaData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::mediaInfo, ::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t> deploy_mediaData(static_cast<::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::mediaInfo,::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getMediaData",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_mediaData);
_mediaData = deploy_mediaData.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::getMediaDataAsync(GetMediaDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::mediaInfo, ::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t> deploy_mediaData(static_cast<::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::mediaInfo,::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getMediaData",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::mediaInfo, ::v0::com::harman::dcif::EnggMenuTypes_::mediaInfoDeployment_t> _mediaData) {
        	if (_callback)
        		_callback(_internalCallStatus, _mediaData.getValue());
        },
        std::make_tuple(deploy_mediaData));
    }
    /**
     * description: Perform factory reset of peristent data, media,  	tuner and bluetooth data   
     *   	- Key Pres 	- Mute audio sources 	- clear media data 	- reset persistency
     *   data 	- Disconnect the bluetooth device and delete the paired device list 	-
     *   Vehicle Settings reset
     */
    void EnggMenuPresCtrlDBusProxy::performFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "performFactoryReset",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::performFactoryResetAsync(PerformFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "performFactoryReset",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: method to turn on device mode.
     */
    void EnggMenuPresCtrlDBusProxy::setDeviceMode(const ::v0::com::harman::dcif::EnggMenuTypes::modeType &_typeOfMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::modeType &_activatedMode, ::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus &_dmStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment> deploy_typeOfMode(_typeOfMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment> deploy_activatedMode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus, CommonAPI::EmptyDeployment> deploy_dmStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setDeviceMode",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_typeOfMode,
_internalCallStatus,
deploy_activatedMode, deploy_dmStatus);
_activatedMode = deploy_activatedMode.getValue();
_dmStatus = deploy_dmStatus.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::setDeviceModeAsync(const ::v0::com::harman::dcif::EnggMenuTypes::modeType &_typeOfMode, SetDeviceModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment> deploy_typeOfMode(_typeOfMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment> deploy_activatedMode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus, CommonAPI::EmptyDeployment> deploy_dmStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setDeviceMode",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_typeOfMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::modeType, CommonAPI::EmptyDeployment> _activatedMode, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus, CommonAPI::EmptyDeployment> _dmStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _activatedMode.getValue(), _dmStatus.getValue());
        },
        std::make_tuple(deploy_activatedMode, deploy_dmStatus));
    }
    /**
     * description: Method to update the Mihup configuration file from the USB
     */
    void EnggMenuPresCtrlDBusProxy::updateMihupLib(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::EnggMenuTypes::retStatus &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "updateMihupLib",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> EnggMenuPresCtrlDBusProxy::updateMihupLibAsync(UpdateMihupLibAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "updateMihupLib",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::dcif::EnggMenuTypes::retStatus, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }


void EnggMenuPresCtrlDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 0;
          ownVersionMinor = 1;
      }

      } // namespace dcif
      } // namespace harman
      } // namespace com
      } // namespace v0
