/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v0/com/harman/audiopres/plugin/TataAudioPresPluginDBusProxy.hpp>

namespace v0 {
namespace com {
namespace harman {
namespace audiopres {
namespace plugin {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createTataAudioPresPluginDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<TataAudioPresPluginDBusProxy>(_address, _connection);
}

INITIALIZER(registerTataAudioPresPluginDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		TataAudioPresPlugin::getInterface(),
		&createTataAudioPresPluginDBusProxy);
}

TataAudioPresPluginDBusProxy::TataAudioPresPluginDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		startupVolume_(*this, "onStartupVolumeAttributeChanged", "q", "getStartupVolumeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		sdvcState_(*this, "onSdvcStateAttributeChanged", "b", "getSdvcStateAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		auxInGain_(*this, "onAuxInGainAttributeChanged", "i", "getAuxInGainAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		pdcMixMode_(*this, "onPdcMixModeAttributeChanged", "b", "getPdcMixModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		voiceAlertStatus_(*this, "onVoiceAlertStatusAttributeChanged", "i", "getVoiceAlertStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		auxConnectionState_(*this, "onAuxConnectionStateAttributeChanged", "s", "getAuxConnectionStateAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
		usbConnectionState_(*this, "onUsbConnectionStateAttributeChanged", "s", "getUsbConnectionStateAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
		ipodConnectionState_(*this, "onIpodConnectionStateAttributeChanged", "s", "getIpodConnectionStateAttribute", static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)),
		notificationVolume_(*this, "onNotificationVolumeAttributeChanged", "q", "getNotificationVolumeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
,		sourceState_(*this, "sourceState", "qi", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}

      TataAudioPresPluginDBusProxy::StartupVolumeAttribute& TataAudioPresPluginDBusProxy::getStartupVolumeAttribute() {
          return startupVolume_;
      }
      TataAudioPresPluginDBusProxy::SdvcStateAttribute& TataAudioPresPluginDBusProxy::getSdvcStateAttribute() {
          return sdvcState_;
      }
      TataAudioPresPluginDBusProxy::AuxInGainAttribute& TataAudioPresPluginDBusProxy::getAuxInGainAttribute() {
          return auxInGain_;
      }
      TataAudioPresPluginDBusProxy::PdcMixModeAttribute& TataAudioPresPluginDBusProxy::getPdcMixModeAttribute() {
          return pdcMixMode_;
      }
      TataAudioPresPluginDBusProxy::VoiceAlertStatusAttribute& TataAudioPresPluginDBusProxy::getVoiceAlertStatusAttribute() {
          return voiceAlertStatus_;
      }
      TataAudioPresPluginDBusProxy::AuxConnectionStateAttribute& TataAudioPresPluginDBusProxy::getAuxConnectionStateAttribute() {
          return auxConnectionState_;
      }
      TataAudioPresPluginDBusProxy::UsbConnectionStateAttribute& TataAudioPresPluginDBusProxy::getUsbConnectionStateAttribute() {
          return usbConnectionState_;
      }
      TataAudioPresPluginDBusProxy::IpodConnectionStateAttribute& TataAudioPresPluginDBusProxy::getIpodConnectionStateAttribute() {
          return ipodConnectionState_;
      }
      TataAudioPresPluginDBusProxy::NotificationVolumeAttribute& TataAudioPresPluginDBusProxy::getNotificationVolumeAttribute() {
          return notificationVolume_;
      }

TataAudioPresPluginDBusProxy::SourceStateEvent& TataAudioPresPluginDBusProxy::getSourceStateEvent() {
    return sourceState_;
}
    
    /**
     * description: This method is used to set audio entertainment sources
     */
    void TataAudioPresPluginDBusProxy::SetStartupVolume(const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetStartupVolume",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_volume,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SetStartupVolumeAsync(const uint16_t &_volume, SetStartupVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetStartupVolume",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to set SDVC state ON-OFF
     */
    void TataAudioPresPluginDBusProxy::SetSDVCState(const bool &_sdvcState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_sdvcState(_sdvcState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetSDVCState",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sdvcState,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SetSDVCStateAsync(const bool &_sdvcState, SetSDVCStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_sdvcState(_sdvcState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetSDVCState",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sdvcState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to set Aux In gain values
     */
    void TataAudioPresPluginDBusProxy::SetAuxInGain(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains &_auxInGain, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains, CommonAPI::EmptyDeployment> deploy_auxInGain(_auxInGain, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetAuxInGain",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_auxInGain,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SetAuxInGainAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains &_auxInGain, SetAuxInGainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains, CommonAPI::EmptyDeployment> deploy_auxInGain(_auxInGain, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetAuxInGain",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_auxInGain,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to set PDC Mix mode status
     */
    void TataAudioPresPluginDBusProxy::SetPdcMixMode(const bool &_mixMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_mixMode(_mixMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetPdcMixMode",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mixMode,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SetPdcMixModeAsync(const bool &_mixMode, SetPdcMixModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_mixMode(_mixMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetPdcMixMode",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mixMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to play eBeepTypes beep
     */
    void TataAudioPresPluginDBusProxy::PlayBeep(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes &_beepType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes, CommonAPI::EmptyDeployment> deploy_beepType(_beepType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "PlayBeep",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_beepType,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::PlayBeepAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes &_beepType, PlayBeepAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes, CommonAPI::EmptyDeployment> deploy_beepType(_beepType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "PlayBeep",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_beepType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to Activate Audio Source
     */
    void TataAudioPresPluginDBusProxy::activateSource(const uint16_t &_sourceId, const uint16_t &_type, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "activateSource",
        "qq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId, deploy_type,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::activateSourceAsync(const uint16_t &_sourceId, const uint16_t &_type, ActivateSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "activateSource",
        "qq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId, deploy_type,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to deactivate Audio Source
     */
    void TataAudioPresPluginDBusProxy::deactivateSource(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deactivateSource",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::deactivateSourceAsync(const uint16_t &_sourceId, DeactivateSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deactivateSource",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to play Voice Alert
     */
    void TataAudioPresPluginDBusProxy::playVoiceAlert(const uint16_t &_sourceId, const uint16_t &_id, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_id(_id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playVoiceAlert",
        "qq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId, deploy_id,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::playVoiceAlertAsync(const uint16_t &_sourceId, const uint16_t &_id, PlayVoiceAlertAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_id(_id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playVoiceAlert",
        "qq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId, deploy_id,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to cancel Voice Alert
     */
    void TataAudioPresPluginDBusProxy::cancelVoiceAlert(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "cancelVoiceAlert",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::cancelVoiceAlertAsync(const uint16_t &_sourceId, CancelVoiceAlertAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "cancelVoiceAlert",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to make Sink audio ON-OFF
     */
    void TataAudioPresPluginDBusProxy::SetAudioOff(const bool &_audioState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_audioState(_audioState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetAudioOff",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_audioState,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SetAudioOffAsync(const bool &_audioState, SetAudioOffAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_audioState(_audioState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetAudioOff",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_audioState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to reset Audio Settings
     */
    void TataAudioPresPluginDBusProxy::AudioFactoryReset(const uint16_t &_type, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "AudioFactoryReset",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_type,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::AudioFactoryResetAsync(const uint16_t &_type, AudioFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "AudioFactoryReset",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_type,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle entertianment source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     */
    void TataAudioPresPluginDBusProxy::ToggleEntertainmentSource(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ToggleEntertainmentSource",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_direction,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::ToggleEntertainmentSourceAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection &_direction, ToggleEntertainmentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection, CommonAPI::EmptyDeployment> deploy_direction(_direction, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ToggleEntertainmentSource",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_direction,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle mute status of currently playing sources as per
     *   TML mute strategy 	(at)attribute update ActiveSrcMute
     */
    void TataAudioPresPluginDBusProxy::PlayFromSourceGroup(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup &_srcGroupId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup, CommonAPI::EmptyDeployment> deploy_srcGroupId(_srcGroupId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "PlayFromSourceGroup",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_srcGroupId,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::PlayFromSourceGroupAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup &_srcGroupId, PlayFromSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup, CommonAPI::EmptyDeployment> deploy_srcGroupId(_srcGroupId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "PlayFromSourceGroup",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_srcGroupId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to toggle mute status of currently playing sources as per
     *   TML mute strategy 	(at)attribute update ActiveSrcMute
     */
    void TataAudioPresPluginDBusProxy::ToggleSystemMute(CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "ToggleSystemMute",
        "",
_internalCallStatus);
}
    /**
     * description: This method is used to toggle mute status of currently playing sources as per
     *   TML mute strategy 	(at)attribute update ActiveSrcMute
     */
    void TataAudioPresPluginDBusProxy::ToggleMute(const bool &_userInitiated, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_userInitiated(_userInitiated, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "ToggleMute",
        "b",
deploy_userInitiated,
_internalCallStatus);
}
    /**
     * description: This method is used to get source state from Audiomanager 	This will be helpful
     *   in cases where where HMI wanted to know status of source
     */
    void TataAudioPresPluginDBusProxy::GetSourceState(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e &_srcState, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e, CommonAPI::EmptyDeployment> deploy_srcState(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "GetSourceState",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId,
_internalCallStatus,
deploy_error,
deploy_srcState);
_error = deploy_error.getValue();
_srcState = deploy_srcState.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::GetSourceStateAsync(const uint16_t &_sourceId, GetSourceStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e, CommonAPI::EmptyDeployment> deploy_srcState(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "GetSourceState",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e, CommonAPI::EmptyDeployment> _srcState) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _srcState.getValue());
        },
        std::make_tuple(deploy_error, deploy_srcState));
    }
    /**
     * description: This method is used to get source state from Audiomanager 	This will be helpful
     *   in cases where where HMI wanted to know status of source
     */
    void TataAudioPresPluginDBusProxy::GetSourceStateList(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L &_srcStateList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t> deploy_srcStateList(static_cast<::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L,::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "GetSourceStateList",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_srcStateList);
_error = deploy_error.getValue();
_srcStateList = deploy_srcStateList.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::GetSourceStateListAsync(GetSourceStateListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t> deploy_srcStateList(static_cast<::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L,::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "GetSourceStateList",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes_::apres_SourceConnectionState_LDeployment_t> _srcStateList) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _srcStateList.getValue());
        },
        std::make_tuple(deploy_error, deploy_srcStateList));
    }
    /**
     * description: This method is used to switch to previous entertainment source from playback
     *   list 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened	 	(at)return eAudioPresErrors
     */
    void TataAudioPresPluginDBusProxy::SwitchToPreviousEntSource(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SwitchToPreviousEntSource",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SwitchToPreviousEntSourceAsync(SwitchToPreviousEntSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SwitchToPreviousEntSource",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to register device connection State 		This is mainly used
     *   for USB and IPOD device. Can be extended in futher for other devices
     *   	(at)return eAudioPresErrors
     */
    void TataAudioPresPluginDBusProxy::deviceConnectionState(const uint16_t &_sourceId, const std::string &_connectionState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_connectionState(_connectionState, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deviceConnectionState",
        "qs",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceId, deploy_connectionState,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::deviceConnectionStateAsync(const uint16_t &_sourceId, const std::string &_connectionState, DeviceConnectionStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_connectionState(_connectionState, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deviceConnectionState",
        "qs",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceId, deploy_connectionState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This method is used to set notification volume
     */
    void TataAudioPresPluginDBusProxy::SetNotificationVolume(const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetNotificationVolume",
        "q",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_volume,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> TataAudioPresPluginDBusProxy::SetNotificationVolumeAsync(const uint16_t &_volume, SetNotificationVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volume(_volume, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetNotificationVolume",
        "q",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_volume,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void TataAudioPresPluginDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 0;
          ownVersionMinor = 1;
      }

      } // namespace plugin
      } // namespace audiopres
      } // namespace harman
      } // namespace com
      } // namespace v0
