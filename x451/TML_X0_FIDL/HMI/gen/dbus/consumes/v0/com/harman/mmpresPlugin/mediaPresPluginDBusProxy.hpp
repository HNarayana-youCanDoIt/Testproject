/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_MMPRESPLUGIN_media_Pres_Plugin_DBUS_PROXY_HPP_
#define V0_COM_HARMAN_MMPRESPLUGIN_media_Pres_Plugin_DBUS_PROXY_HPP_

#include <v0/com/harman/mmpresPlugin/mediaPresPluginProxyBase.hpp>
#include "v0/com/harman/mmpresPlugin/mediaPresPluginDBusDeployment.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusAttribute.hpp>
#include <CommonAPI/DBus/DBusEvent.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace v0 {
namespace com {
namespace harman {
namespace mmpresPlugin {

class mediaPresPluginDBusProxy
    : virtual public mediaPresPluginProxyBase, 
      virtual public CommonAPI::DBus::DBusProxy {
public:
    mediaPresPluginDBusProxy(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection);

    virtual ~mediaPresPluginDBusProxy() { }

    virtual UsbDeviceErrorAttribute& getUsbDeviceErrorAttribute();
    virtual UsbPlaybackModeAttribute& getUsbPlaybackModeAttribute();
    virtual DeviceItemsInfoAttribute& getDeviceItemsInfoAttribute();
    virtual BitRateAttribute& getBitRateAttribute();
    virtual SamplingRateAttribute& getSamplingRateAttribute();
    virtual BTMetaDataAvailabilityStatusAttribute& getBTMetaDataAvailabilityStatusAttribute();
    virtual VideoTestModeParametersAttribute& getVideoTestModeParametersAttribute();
    virtual TEFilesPathAttribute& getTEFilesPathAttribute();
    virtual MediaErrorAttribute& getMediaErrorAttribute();

    virtual TrackSessionChangedEvent& getTrackSessionChangedEvent();

    /**
     * description: This method will toggle the repeat state as OFF->All->one. 		 		 Input :  none	
     *   		               returns:	eCallResult:	result
     */
    virtual void toggleRepeat(const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> toggleRepeatAsync(const mediaPresPlugin::eButtonStatus &_buttonStatus, ToggleRepeatAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method will toggle the shuffle state as OFF->All. 		 		 Input :  None     
     *       returns:	eCallResult:	result
     */
    virtual void toggleShuffle(const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> toggleShuffleAsync(const mediaPresPlugin::eButtonStatus &_buttonStatus, ToggleShuffleAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method to perform the next track operation. 		 		 Input :  UInt64 : step	
     *   		               returns:	  eCallResult:	result
     */
    virtual void next(const uint64_t &_step, const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> nextAsync(const uint64_t &_step, const mediaPresPlugin::eButtonStatus &_buttonStatus, NextAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method to perform the previous track operation. 		 		 Input :  UInt64 :
     *   step	 		               returns:	  eCallResult:	result
     */
    virtual void previous(const uint64_t &_step, const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> previousAsync(const uint64_t &_step, const mediaPresPlugin::eButtonStatus &_buttonStatus, PreviousAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method to perform the pause operation. 		 		 Input :  Boolean: pressed -
     *   Whether the button is pressed or released.	 		               returns:
     *   eCallResult:	result
     */
    virtual void pause(const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> pauseAsync(const mediaPresPlugin::eButtonStatus &_buttonStatus, PauseAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method to perform the resume operation. 		 		 Input :  Boolean: pressed -
     *   Whether the button is pressed or released.	 		               returns:
     *   eCallResult:	result
     */
    virtual void resume(const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> resumeAsync(const mediaPresPlugin::eButtonStatus &_buttonStatus, ResumeAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method to perform the FastForward operation. 		 		 Input :  Boolean:
     *   pressed - Whether the button is pressed or released.	 		              
     *   returns: eCallResult:	result
     */
    virtual void fastforward(const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> fastforwardAsync(const mediaPresPlugin::eButtonStatus &_buttonStatus, FastforwardAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method to perform the FastReverse operation. 		 		 Input :  Boolean:
     *   pressed - Whether the button is pressed or released.	 		              
     *   returns: eCallResult:	result
     */
    virtual void fastreverse(const mediaPresPlugin::eButtonStatus &_buttonStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> fastreverseAsync(const mediaPresPlugin::eButtonStatus &_buttonStatus, FastreverseAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is to receive the RVC status from HMI and enable/disable the video
     *   laye based on this. 		 		 Input :  boolean: rvcStatus : True = RVC engaged,
     *   False = RVC disengaged. 		               returns: eCallResult:result
     */
    virtual void updateRvcState(const bool &_rvcStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> updateRvcStateAsync(const bool &_rvcStatus, UpdateRvcStateAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is to receive the RVC status from HMI and enable/disable the video
     *   laye based on this. 		 		 Input :  eVideoSurfaceDisplayStatus: surfaceStatus 
     *   		               returns:	  String: path
     */
    virtual void videoSurfaceControl(const mediaPresPlugin::eVideoSurfaceDisplayStatus &_surfaceStatus, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> videoSurfaceControlAsync(const mediaPresPlugin::eVideoSurfaceDisplayStatus &_surfaceStatus, VideoSurfaceControlAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: This method is to fetch current playing track index in browse list.  		It will
     *   be required to display the correct pointer for current playing track in case
     *   track changed during browse list display. 		 		 Input :  UInt32      
     *   sessionID 				  UInt32       QueryID	 		               returns: eCallResult
     *   result				 				UInt32       sessionQueryID 				Boolean 	 highlight 				UInt64 
     *   	 trackIndex
     */
    virtual void getCurrentTrackIndex(const uint32_t &_sessionID, const uint32_t &_QueryID, CommonAPI::CallStatus &_internalCallStatus, mediaPresPlugin::eCallResult &_result, uint32_t &_sessionQueryID, bool &_highlight, uint64_t &_trackIndex, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> getCurrentTrackIndexAsync(const uint32_t &_sessionID, const uint32_t &_QueryID, GetCurrentTrackIndexAsyncCallback _callback, const CommonAPI::CallInfo *_info);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

private:
   
    class DBususbDeviceError_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<UsbDeviceErrorAttribute>> {
    public:
    template <typename... _A>
    	DBususbDeviceError_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<UsbDeviceErrorAttribute>>(
    			_proxy, arguments...) {}
    };
    DBususbDeviceError_Attribute usbDeviceError_;
    class DBususbPlaybackMode_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<UsbPlaybackModeAttribute>> {
    public:
    template <typename... _A>
    	DBususbPlaybackMode_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<UsbPlaybackModeAttribute>>(
    			_proxy, arguments...) {}
    };
    DBususbPlaybackMode_Attribute usbPlaybackMode_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<DeviceItemsInfoAttribute, mediaPresPlugin_::sItemsInfoDeployment_t>> deviceItemsInfo_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<BitRateAttribute, CommonAPI::DBus::StringDeployment>> bitRate_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<SamplingRateAttribute, CommonAPI::DBus::StringDeployment>> samplingRate_;
    class DBusbTMetaDataAvailabilityStatus_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<BTMetaDataAvailabilityStatusAttribute>> {
    public:
    template <typename... _A>
    	DBusbTMetaDataAvailabilityStatus_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<BTMetaDataAvailabilityStatusAttribute>>(
    			_proxy, arguments...) {}
    };
    DBusbTMetaDataAvailabilityStatus_Attribute bTMetaDataAvailabilityStatus_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<VideoTestModeParametersAttribute, mediaPresPlugin_::sVideoParametersDeployment_t>> videoTestModeParameters_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<TEFilesPathAttribute, mediaPresPlugin_::sTEFilesPathDeployment_t>> tEFilesPath_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<MediaErrorAttribute, mediaPresPlugin_::MediaErrorMapDeployment_t>> mediaError_;

    CommonAPI::DBus::DBusEvent<TrackSessionChangedEvent> trackSessionChanged_;

};

} // namespace mmpresPlugin
} // namespace harman
} // namespace com
} // namespace v0

#endif // V0_COM_HARMAN_MMPRESPLUGIN_media_Pres_Plugin_DBUS_PROXY_HPP_

