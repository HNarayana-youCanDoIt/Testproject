/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Interface for managing the GENIVI LUC (Last User Context)      The GENIVI Node
 *   Startup Controller remembers applications that were used     in the last
 *   session of a user. It is used in order to restore these     applications on
 *   the next start-up.      The Node Startup Controller is a passive component in
 *   the sense that it     does not remember applications on its own; instead,
 *   applications need to     register and deregister themselves proactively.     
 *   Applications can be registered for different LUC types, the standard ones
 * author: Giridhar
 */
#include <v1/org/genivi/NodeStartupController1/NodeStartupControllerDBusProxy.hpp>

namespace v1 {
namespace org {
namespace genivi {
namespace NodeStartupController1 {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createNodeStartupControllerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<NodeStartupControllerDBusProxy>(_address, _connection);
}

INITIALIZER(registerNodeStartupControllerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		NodeStartupController::getInterface(),
		&createNodeStartupControllerDBusProxy);
}

NodeStartupControllerDBusProxy::NodeStartupControllerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
{
}


    
    /**
     * description: BeginLUCRegistration:        Initialises the LUC registration sequence at
     *   shutdown in order to register       the applications which are running in the
     *   LUC in this moment.   	  consumer.
     * author: Giridhar
     */
    void NodeStartupControllerDBusProxy::BeginLUCRegistration(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "BeginLUCRegistration",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> NodeStartupControllerDBusProxy::BeginLUCRegistrationAsync(BeginLUCRegistrationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "BeginLUCRegistration",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: RegisterWithLUC:       apps: A dictionary that maps LUC types to arrays of
     *   application unit names.        Registers one or more applications for certain
     *   LUC types. Applications may       be listed multiple times. For LUC types
     *   where only a single application may       be registered at a time, the last
     *   application in the corresponding list wins.        An example for the apps
     *   parameter would be:          {           0 : [ "app1.unit" ],           1 : [
     *   "app2.unit", "app3.unit" ],           2 : [ "app3.unit" ]         }      
     *   where 0 = "foreground", 1 = background , 2 = "audible"
     * author: Giridhar
     */
    void NodeStartupControllerDBusProxy::RegisterWithLUC(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "RegisterWithLUC",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> NodeStartupControllerDBusProxy::RegisterWithLUCAsync(RegisterWithLUCAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "RegisterWithLUC",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: FinishLUCRegistration:        Finishes the LUC registration sequence and
     *   atomically replaces the       previous LUC.       consumer.
     * author: Giridhar
     */
    void NodeStartupControllerDBusProxy::FinishLUCRegistration(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "FinishLUCRegistration",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> NodeStartupControllerDBusProxy::FinishLUCRegistrationAsync(FinishLUCRegistrationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "FinishLUCRegistration",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }


void NodeStartupControllerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace NodeStartupController1
      } // namespace genivi
      } // namespace org
      } // namespace v1
