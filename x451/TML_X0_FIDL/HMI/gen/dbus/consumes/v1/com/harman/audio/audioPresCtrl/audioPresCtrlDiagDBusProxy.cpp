/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: This is a Common API DBUS diagnostics interface of audio presentation
 *   controller for Orinoco 2.0
 * author: AYatheesh
 */
#include <v1/com/harman/audio/audioPresCtrl/audioPresCtrlDiagDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createaudioPresCtrlDiagDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<audioPresCtrlDiagDBusProxy>(_address, _connection);
}

INITIALIZER(registeraudioPresCtrlDiagDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		audioPresCtrlDiag::getInterface(),
		&createaudioPresCtrlDiagDBusProxy);
}

audioPresCtrlDiagDBusProxy::audioPresCtrlDiagDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		activeFrequency_(*this, "onActiveFrequencyAttributeChanged", "d", "getActiveFrequencyAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		activeSpeakerMask_(*this, "onActiveSpeakerMaskAttributeChanged", "q", "getActiveSpeakerMaskAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		activeVolumePercent_(*this, "onActiveVolumePercentAttributeChanged", "q", "getActiveVolumePercentAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
{
}

      audioPresCtrlDiagDBusProxy::ActiveFrequencyAttribute& audioPresCtrlDiagDBusProxy::getActiveFrequencyAttribute() {
          return activeFrequency_;
      }
      audioPresCtrlDiagDBusProxy::ActiveSpeakerMaskAttribute& audioPresCtrlDiagDBusProxy::getActiveSpeakerMaskAttribute() {
          return activeSpeakerMask_;
      }
      audioPresCtrlDiagDBusProxy::ActiveVolumePercentAttribute& audioPresCtrlDiagDBusProxy::getActiveVolumePercentAttribute() {
          return activeVolumePercent_;
      }

    
    /**
     * description: For diagnostic purpose to test one or multiple speakers 	(at)return
     *   eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::TestSpeaker(const uint16_t &_speakerMask, const double &_frequency, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_speakerMask(_speakerMask, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<double, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<double, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "TestSpeaker",
        "qd",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_speakerMask, deploy_frequency,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::TestSpeakerAsync(const uint16_t &_speakerMask, const double &_frequency, TestSpeakerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_speakerMask(_speakerMask, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<double, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<double, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "TestSpeaker",
        "qd",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_speakerMask, deploy_frequency,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This function is used to play a sine signal with sine generator with special
     *   parameters.     (at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::playSineTone(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType &_sampleRate, const int16_t &_frequency, const int16_t &_pauseTime, const int16_t &_pulseTime, const int16_t &_repeatCount, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment> deploy_sampleRate(_sampleRate, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pauseTime(_pauseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pulseTime(_pulseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_repeatCount(_repeatCount, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playSineTone",
        "innnn",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sampleRate, deploy_frequency, deploy_pauseTime, deploy_pulseTime, deploy_repeatCount,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::playSineToneAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType &_sampleRate, const int16_t &_frequency, const int16_t &_pauseTime, const int16_t &_pulseTime, const int16_t &_repeatCount, PlaySineToneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment> deploy_sampleRate(_sampleRate, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_frequency(_frequency, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pauseTime(_pauseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_pulseTime(_pulseTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_repeatCount(_repeatCount, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eSampleRateType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playSineTone",
        "innnn",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sampleRate, deploy_frequency, deploy_pauseTime, deploy_pulseTime, deploy_repeatCount,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: This function is used to stop playing sine tone for diagnostics purpose    
     *   (at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::StopSineTone(CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "StopSineTone",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::StopSineToneAsync(StopSineToneAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "StopSineTone",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: For diagnostic purpose to Start Diagnostic Session 	(at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::DiagTestStart(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType &_diagModeType, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment> deploy_diagModeType(_diagModeType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "DiagTestStart",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_diagModeType,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::DiagTestStartAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType &_diagModeType, DiagTestStartAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment> deploy_diagModeType(_diagModeType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "DiagTestStart",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_diagModeType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: For diagnostic purpose to Stop Diagnostic Session 	(at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::DiagTestStop(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType &_diagModeType, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment> deploy_diagModeType(_diagModeType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "DiagTestStop",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_diagModeType,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::DiagTestStopAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType &_diagModeType, DiagTestStopAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment> deploy_diagModeType(_diagModeType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "DiagTestStop",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_diagModeType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: For diagnostic purpose to Set Volume in percentage 	(at)return eAudioPresErrors
     */
    void audioPresCtrlDiagDBusProxy::SetVolumePercentage(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType &_diagModeType, const uint16_t &_volumePercent, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment> deploy_diagModeType(_diagModeType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volumePercent(_volumePercent, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetVolumePercentage",
        "iq",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_diagModeType, deploy_volumePercent,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> audioPresCtrlDiagDBusProxy::SetVolumePercentageAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType &_diagModeType, const uint16_t &_volumePercent, SetVolumePercentageAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment> deploy_diagModeType(_diagModeType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment> deploy_volumePercent(_volumePercent, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eDiagModeType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint16_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetVolumePercentage",
        "iq",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_diagModeType, deploy_volumePercent,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void audioPresCtrlDiagDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace audioPresCtrl
      } // namespace audio
      } // namespace harman
      } // namespace com
      } // namespace v1
