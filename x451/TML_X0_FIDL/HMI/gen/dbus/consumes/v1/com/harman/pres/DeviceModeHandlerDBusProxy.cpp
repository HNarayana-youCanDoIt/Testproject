/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v1/com/harman/pres/DeviceModeHandlerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace pres {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createDeviceModeHandlerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<DeviceModeHandlerDBusProxy>(_address, _connection);
}

INITIALIZER(registerDeviceModeHandlerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		DeviceModeHandler::getInterface(),
		&createDeviceModeHandlerDBusProxy);
}

DeviceModeHandlerDBusProxy::DeviceModeHandlerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		deviceInserted_(*this, "deviceInserted", "(ysbia(iii))", std::make_tuple(static_cast<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t*>(nullptr))),
		deviceRemoved_(*this, "deviceRemoved", "y", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		modeStatus_(*this, "modeStatus", "ybba(ysi)(iii)", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sConflictModeDeployment_t>*>(nullptr), static_cast<::v1::com::harman::pres::devprestypes_::sModeInfoDeployment_t*>(nullptr)))
{
}


DeviceModeHandlerDBusProxy::DeviceInsertedEvent& DeviceModeHandlerDBusProxy::getDeviceInsertedEvent() {
    return deviceInserted_;
}
DeviceModeHandlerDBusProxy::DeviceRemovedEvent& DeviceModeHandlerDBusProxy::getDeviceRemovedEvent() {
    return deviceRemoved_;
}
DeviceModeHandlerDBusProxy::ModeStatusEvent& DeviceModeHandlerDBusProxy::getModeStatusEvent() {
    return modeStatus_;
}
    
    /**
     * description: This method to be called to get device details. 		parameters are explained in
     *   devprestypes FIDL.
     */
    void DeviceModeHandlerDBusProxy::getDeviceDetails(const ::v1::com::harman::pres::devprestypes::eDeviceFilter &_devFilter, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, ::v1::com::harman::pres::devprestypes::eRequestStatus &_reqStatus, std::vector<::v1::com::harman::pres::devprestypes::sDeviceInfo> &_devDetails, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eDeviceFilter, CommonAPI::EmptyDeployment> deploy_devFilter(_devFilter, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eRequestStatus, CommonAPI::EmptyDeployment> deploy_reqStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::sDeviceInfo>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>> deploy_devDetails(static_cast<CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eDeviceFilter, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eRequestStatus,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::sDeviceInfo>,CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getDeviceDetails",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_devFilter,
_internalCallStatus,
deploy_ackStatus, deploy_reqStatus, deploy_devDetails);
_ackStatus = deploy_ackStatus.getValue();
_reqStatus = deploy_reqStatus.getValue();
_devDetails = deploy_devDetails.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::getDeviceDetailsAsync(const ::v1::com::harman::pres::devprestypes::eDeviceFilter &_devFilter, GetDeviceDetailsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eDeviceFilter, CommonAPI::EmptyDeployment> deploy_devFilter(_devFilter, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eRequestStatus, CommonAPI::EmptyDeployment> deploy_reqStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::sDeviceInfo>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>> deploy_devDetails(static_cast<CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eDeviceFilter, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eRequestStatus,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::sDeviceInfo>,CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getDeviceDetails",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_devFilter,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eRequestStatus, CommonAPI::EmptyDeployment> _reqStatus, CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::sDeviceInfo>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::pres::devprestypes_::sDeviceInfoDeployment_t>> _devDetails) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue(), _reqStatus.getValue(), _devDetails.getValue());
        },
        std::make_tuple(deploy_ackStatus, deploy_reqStatus, deploy_devDetails));
    }
    /**
     * description: This method to be called to delete device from known wifi projection device
     *   list. 	 		The confirmation for this request happens with broadcast
     *   "deviceRemoved" 						 		parameters are explained in devprestypes FIDL.
     */
    void DeviceModeHandlerDBusProxy::deleteDevice(const uint8_t &_Id, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deleteDevice",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_Id,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::deleteDeviceAsync(const uint8_t &_Id, DeleteDeviceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deleteDevice",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_Id,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: (WIFI_AA/WIFI_CP) This is to be called whenever user wants to search for new
     *   wifi devices and pair                         Once the connected devices list
     *   comes to HMI, user can start session on any one of them                       
     *    User has to provide the mode as input, based on which corresponding devices
     *   will be paired and given back
     */
    void DeviceModeHandlerDBusProxy::searchAndPairWifiDevices(const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "searchAndPairWifiDevices",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_modeName,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::searchAndPairWifiDevicesAsync(const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, SearchAndPairWifiDevicesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "searchAndPairWifiDevices",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_modeName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: This method to be called whenever user selects a mode and mode is in CAPABLE
     *   state (session to be established). 		If mode is in ACTIVE state (session
     *   already established), HMI should communicate with corresponding pres control
     *   to control the device. 		 		when this method gets called, devPresCntrl updates
     *   status through a broadcast "modeStatus". 		 		If user wants to close
     *   conflicting modes before starting requested mode, "forceStart" should be set
     *   to TRUE.  		otherwise "forceStart" should be set to FALSE. 		 		other
     *   parameters are explained in devprestypes FIDL.
     */
    void DeviceModeHandlerDBusProxy::startMode(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, const bool &_forceStart, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_forceStart(_forceStart, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "startMode",
        "yib",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_Id, deploy_modeName, deploy_forceStart,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::startModeAsync(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, const bool &_forceStart, StartModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_forceStart(_forceStart, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "startMode",
        "yib",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_Id, deploy_modeName, deploy_forceStart,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: This method to be called whenever user wants to terminate an active mode. 				
     *   		when this method gets called, devPresCntrl updates status through a
     *   broadcast "modeStatus". 			 		parameters are explained in devprestypes FIDL.
     */
    void DeviceModeHandlerDBusProxy::stopMode(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "stopMode",
        "yi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_Id, deploy_modeName,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::stopModeAsync(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, StopModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "stopMode",
        "yi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_Id, deploy_modeName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: This method to be called to cancel ongoing "startMode" request. 	 		when this
     *   method gets called, devPresCntrl updates status through a broadcast
     *   "modeStatus". 		 		parameters are explained in devprestypes FIDL.
     */
    void DeviceModeHandlerDBusProxy::cancelMode(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "cancelMode",
        "yi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_Id, deploy_modeName,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::cancelModeAsync(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_modeName, CancelModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_Id(_Id, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment> deploy_modeName(_modeName, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eModeName, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "cancelMode",
        "yi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_Id, deploy_modeName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: This broadcast gets emitted, whenever device is inserted. 		parameters are
     *   explained in devprestypes FIDL.
     */
    void DeviceModeHandlerDBusProxy::getinserteddeviceinfo(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::vDeviceInfo &_devInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vDeviceInfo, ::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t> deploy_devInfo(static_cast<::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vDeviceInfo,::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getinserteddeviceinfo",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_devInfo);
_devInfo = deploy_devInfo.getValue();
}
    std::future<CommonAPI::CallStatus> DeviceModeHandlerDBusProxy::getinserteddeviceinfoAsync(GetinserteddeviceinfoAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vDeviceInfo, ::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t> deploy_devInfo(static_cast<::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vDeviceInfo,::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getinserteddeviceinfo",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vDeviceInfo, ::v1::com::harman::pres::devprestypes_::vDeviceInfoDeployment_t> _devInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _devInfo.getValue());
        },
        std::make_tuple(deploy_devInfo));
    }


void DeviceModeHandlerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 1;
      }

      } // namespace pres
      } // namespace harman
      } // namespace com
      } // namespace v1
