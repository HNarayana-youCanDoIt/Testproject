/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v1/com/harman/pres/IAP2HandlerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace pres {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createIAP2HandlerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<IAP2HandlerDBusProxy>(_address, _connection);
}

INITIALIZER(registerIAP2HandlerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		IAP2Handler::getInterface(),
		&createIAP2HandlerDBusProxy);
}

IAP2HandlerDBusProxy::IAP2HandlerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		iAP2Started_(*this, "IAP2Started", "iaisys", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::DBus::StringDeployment*>(nullptr))),
		iAP2Stopped_(*this, "iAP2Stopped", "s", std::make_tuple(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr)))
{
}


IAP2HandlerDBusProxy::IAP2StartedEvent& IAP2HandlerDBusProxy::getIAP2StartedEvent() {
    return iAP2Started_;
}
IAP2HandlerDBusProxy::IAP2StoppedEvent& IAP2HandlerDBusProxy::getIAP2StoppedEvent() {
    return iAP2Stopped_;
}
    
    /**
     * description: This method to be called to start IAP2 driver. 	 		This is to be called for
     *   transport over BT & WIFI.  		For USB_HOST & USB_DEVICE transports,
     *   devPresCntrl itself starts IAP2 driver. 		 		dbus instanceName of launched
     *   IAP2 driver can be found with broadcast "IAP2Started".
     */
    void IAP2HandlerDBusProxy::startIAP2(const ::v1::com::harman::pres::devprestypes::eIAP2Transport &_transport, const std::vector<::v1::com::harman::pres::devprestypes::eIAP2Mode> &_modes, const std::string &_devicePath, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eIAP2Transport, CommonAPI::EmptyDeployment> deploy_transport(_transport, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::eIAP2Mode>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_modes(_modes, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_devicePath(_devicePath, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eIAP2Transport, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::eIAP2Mode>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "startIAP2",
        "iais",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_transport, deploy_modes, deploy_devicePath,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> IAP2HandlerDBusProxy::startIAP2Async(const ::v1::com::harman::pres::devprestypes::eIAP2Transport &_transport, const std::vector<::v1::com::harman::pres::devprestypes::eIAP2Mode> &_modes, const std::string &_devicePath, StartIAP2AsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eIAP2Transport, CommonAPI::EmptyDeployment> deploy_transport(_transport, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::eIAP2Mode>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_modes(_modes, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_devicePath(_devicePath, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eIAP2Transport, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<::v1::com::harman::pres::devprestypes::eIAP2Mode>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "startIAP2",
        "iais",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_transport, deploy_modes, deploy_devicePath,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: This method to be called to stop IAP2 driver. 	 		"instanceName" : dbus
     *   instanceName of IAP2 driver to be terminated.
     */
    void IAP2HandlerDBusProxy::stopIAP2(const std::string &_instanceName, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_instanceName(_instanceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "stopIAP2",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_instanceName,
_internalCallStatus,
deploy_ackStatus);
_ackStatus = deploy_ackStatus.getValue();
}
    std::future<CommonAPI::CallStatus> IAP2HandlerDBusProxy::stopIAP2Async(const std::string &_instanceName, StopIAP2AsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_instanceName(_instanceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> deploy_ackStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "stopIAP2",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_instanceName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::eAcknowledgement, CommonAPI::EmptyDeployment> _ackStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _ackStatus.getValue());
        },
        std::make_tuple(deploy_ackStatus));
    }
    /**
     * description: This getter notifies dbus instanceName of IAP2 currently launched. 
     *   	"devicepath" is only applicable for USB_HOST, BT & WIFI transports.
     *   	"deviceId" is only applicable for USB_HOST & USB_DEVICE.  	instanceName and
     *   devicePath will be null if iap2 is not active
     */
    void IAP2HandlerDBusProxy::getIAP2Started(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::vIAP2Info &_iap2StackInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vIAP2Info, ::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t> deploy_iap2StackInfo(static_cast<::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vIAP2Info,::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getIAP2Started",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_iap2StackInfo);
_iap2StackInfo = deploy_iap2StackInfo.getValue();
}
    std::future<CommonAPI::CallStatus> IAP2HandlerDBusProxy::getIAP2StartedAsync(GetIAP2StartedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vIAP2Info, ::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t> deploy_iap2StackInfo(static_cast<::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vIAP2Info,::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getIAP2Started",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::pres::devprestypes::vIAP2Info, ::v1::com::harman::pres::devprestypes_::vIAP2InfoDeployment_t> _iap2StackInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _iap2StackInfo.getValue());
        },
        std::make_tuple(deploy_iap2StackInfo));
    }


void IAP2HandlerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace pres
      } // namespace harman
      } // namespace com
      } // namespace v1
