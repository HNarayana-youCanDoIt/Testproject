/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_TIMEMANAGER_Time_Manager_DBUS_PROXY_HPP_
#define V1_COM_HARMAN_TIMEMANAGER_Time_Manager_DBUS_PROXY_HPP_

#include <v1/com/harman/TimeManager/TimeManagerProxyBase.hpp>
#include "v1/com/harman/TimeManager/TimeManagerDBusDeployment.hpp"

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/DBus/DBusAddress.hpp>
#include <CommonAPI/DBus/DBusFactory.hpp>
#include <CommonAPI/DBus/DBusProxy.hpp>
#include <CommonAPI/DBus/DBusAddressTranslator.hpp>
#include <CommonAPI/DBus/DBusAttribute.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

#include <string>

namespace v1 {
namespace com {
namespace harman {
namespace TimeManager {

class TimeManagerDBusProxy
    : virtual public TimeManagerProxyBase, 
      virtual public CommonAPI::DBus::DBusProxy {
public:
    TimeManagerDBusProxy(
        const CommonAPI::DBus::DBusAddress &_address,
        const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection);

    virtual ~TimeManagerDBusProxy() { }

    virtual TzOffsetAttribute& getTzOffsetAttribute();
    virtual SystemTimeWithTzAttribute& getSystemTimeWithTzAttribute();
    virtual SystemTimeWithTz12HrAttribute& getSystemTimeWithTz12HrAttribute();
    virtual SystemTimeWithTz24HrAttribute& getSystemTimeWithTz24HrAttribute();
    virtual SystemTimeUTCAttribute& getSystemTimeUTCAttribute();
    virtual UtcTime12HrAttribute& getUtcTime12HrAttribute();
    virtual UtcTime24HrAttribute& getUtcTime24HrAttribute();
    virtual TimeFormatAttribute& getTimeFormatAttribute();


    /**
     * description: disableTimeSource 		This method is used to let TM know about which source to
     *   disable.    		input: sourceName - valid configured source name. The
     *   configuration of TM should be refered for this.    		output: status - true if
     *   the source is disabled. false if source disabling falied.
     * author: Bhushan J
     */
    virtual void disableTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> disableTimeSourceAsync(const std::string &_sourceName, DisableTimeSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: getEnabledSources  		Get the list of enabled sources    		output:
     *   sourceNameList - Gets the list of the sourceNames which are currently enabled
     * author: Bhushan J
     */
    virtual void getEnabledSources(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_sourceNameList, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> getEnabledSourcesAsync(GetEnabledSourcesAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: selectTimeSource	 		Enable the time source    		input: sourceName - valid
     *   configured source name. The configuration of TM should be refered for this.   
     *   		output: holdOffTime - -1 or value greater than 0. The value will be -1 in
     *   case the selected source is not operational.    		Else the configured holdOff
     *   time will be returned.     		This method is used to enable a specific
     *   timeSource. Here TimeManager will not disable the other sources.   
     *   		Accordingly the source will be enabled by TM for fetching and sending the
     *   data to Chrony.
     * author: Bhushan J
     */
    virtual void selectTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, int16_t &_holdOffTime, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> selectTimeSourceAsync(const std::string &_sourceName, SelectTimeSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: changeTM_State  		Change state of TM    		input: newState - valid state from
     *   the described TM_States.    		output: currState - Current state of the TM. If
     *   the provided newState is invalid with respect to the    		state transition the
     *   privious state will be kept unchanged and the same will be retured.
     * author: Bhushan J
     */
    virtual void changeTM_State(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_currState, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> changeTM_StateAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, ChangeTM_StateAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: changeTM_OperationalMode 	 		Change the operation mode    		input: newMode -
     *   valid mode from the described TM_operationalMode.    		output: currMode -
     *   Current operational mode TM is working after the change is made.
     * author: Bhushan J
     */
    virtual void changeTM_OperationalMode(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_currMode, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> changeTM_OperationalModeAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, ChangeTM_OperationalModeAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: updateSourceTime_wellFormed	 		Update time from a time source    		input:
     *   newTime - new time value which is defined time data structure.     		sourceId:
     *   Source ID as configured in TM configuration     		output: status - true:
     *   update is succesful, false:failure in the update. For failure there can   
     *   		be two issues. Either sourceId is not valid or provided newTime is not valid.
     * author: Bhushan J
     */
    virtual void updateSourceTime_wellFormed(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> updateSourceTime_wellFormedAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, UpdateSourceTime_wellFormedAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: updateSourceTime_UTC 	 		Update time from a time source    		input: newUTCTime
     *   - new time value in UTC format, sourceId: Source ID as configured in TM
     *   configuration     		output: status - true: update is succesful, false:failure
     *   in the update. For failure there can    		be two issues. Either sourceId is
     *   not valid or provided newTime is not valid.
     * author: Bhushan J
     */
    virtual void updateSourceTime_UTC(const uint64_t &_newUTCTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> updateSourceTime_UTCAsync(const uint64_t &_newUTCTime, const std::string &_sourceId, UpdateSourceTime_UTCAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: Get current format of the time
     * author: Tarun Thomas
     */
    virtual void getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> getTimeFormatAsync(GetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info);
    /**
     * description: Set current format for the time
     * author: Tarun Thomas
     */
    virtual void setTimeFormat(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info);
    virtual std::future<CommonAPI::CallStatus> setTimeFormatAsync(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, SetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info);


    virtual void getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const;

private:
   
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusAttribute<TzOffsetAttribute, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::timeZoneOffsetDeployment_t>> tzOffset_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<SystemTimeWithTzAttribute, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t>> systemTimeWithTz_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<SystemTimeWithTz12HrAttribute, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t>> systemTimeWithTz12Hr_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<SystemTimeWithTz24HrAttribute, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t>> systemTimeWithTz24Hr_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<SystemTimeUTCAttribute>> systemTimeUTC_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<UtcTime12HrAttribute, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t>> utcTime12Hr_;
    CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<UtcTime24HrAttribute, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t>> utcTime24Hr_;
    class DBustimeFormat_Attribute : public CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<TimeFormatAttribute>> {
    public:
    template <typename... _A>
    	DBustimeFormat_Attribute(DBusProxy &_proxy,
    		_A ... arguments)
    		: CommonAPI::DBus::DBusObservableAttribute<CommonAPI::DBus::DBusReadonlyAttribute<TimeFormatAttribute>>(
    			_proxy, arguments...) {}
    };
    DBustimeFormat_Attribute timeFormat_;


};

} // namespace TimeManager
} // namespace harman
} // namespace com
} // namespace v1

#endif // V1_COM_HARMAN_TIMEMANAGER_Time_Manager_DBUS_PROXY_HPP_

