/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v1/com/harman/mmpres/MediaPlayerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace mmpres {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createMediaPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<MediaPlayerDBusProxy>(_address, _connection);
}

INITIALIZER(registerMediaPlayerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		MediaPlayer::getInterface(),
		&createMediaPlayerDBusProxy);
}

MediaPlayerDBusProxy::MediaPlayerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		currentPlayTime_(*this, "onCurrentPlayTimeAttributeChanged", "t", "getCurrentPlayTimeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		totalPlayDuration_(*this, "onTotalPlayDurationAttributeChanged", "t", "getTotalPlayDurationAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		trackState_(*this, "onTrackStateAttributeChanged", "(tt)", "getTrackStateAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::tTrackStateDeployment_t*>(nullptr)),
		nowPlayingData_(*this, "onNowPlayingDataAttributeChanged", "(sssssssssstbtttbi)", "getNowPlayingDataAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::tNowPlayingInfoDeployment_t*>(nullptr)),
		playState_(*this, "onPlayStateAttributeChanged", "i", "getPlayStateAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		speed_(*this, "onSpeedAttributeChanged", "i", "getSpeedAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		repeatMode_(*this, "onRepeatModeAttributeChanged", "i", "getRepeatModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		shuffleMode_(*this, "onShuffleModeAttributeChanged", "i", "getShuffleModeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		nowPlayingArtworkStatus_(*this, "onNowPlayingArtworkStatusAttributeChanged", "i", "getNowPlayingArtworkStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		playbackPreview_(*this, "onPlaybackPreviewAttributeChanged", "a(tsbbiia{it}a{is}isss)", "getPlaybackPreviewAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::MetadataItemListDeployment_t*>(nullptr)),
		videoPlayStatus_(*this, "onVideoPlayStatusAttributeChanged", "b", "getVideoPlayStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		remotePlayerCapability_(*this, "onRemotePlayerCapabilityAttributeChanged", "(yu)", "getRemotePlayerCapabilityAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::tRemotePlayerCapabilityDeployment_t*>(nullptr)),
		mediaError_(*this, "onMediaErrorAttributeChanged", "a{yi}", "getMediaErrorAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::MediaErrorMapDeployment_t*>(nullptr)),
		syncStatus_(*this, "onSyncStatusAttributeChanged", "a{yi}", "getSyncStatusAttribute", static_cast<::v1::com::harman::mmpres::MMPresTypes_::SyncMapDeployment_t*>(nullptr)),
		seekStatus_(*this, "onSeekStatusAttributeChanged", "b", "getSeekStatusAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		favouriteSupported_(*this, "onFavouriteSupportedAttributeChanged", "b", "getFavouriteSupportedAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
,		recentPlayListUpdate_(*this, "recentPlayListUpdate", "", std::make_tuple())
{
}

      MediaPlayerDBusProxy::CurrentPlayTimeAttribute& MediaPlayerDBusProxy::getCurrentPlayTimeAttribute() {
          return currentPlayTime_;
      }
      MediaPlayerDBusProxy::TotalPlayDurationAttribute& MediaPlayerDBusProxy::getTotalPlayDurationAttribute() {
          return totalPlayDuration_;
      }
      MediaPlayerDBusProxy::TrackStateAttribute& MediaPlayerDBusProxy::getTrackStateAttribute() {
          return trackState_;
      }
      MediaPlayerDBusProxy::NowPlayingDataAttribute& MediaPlayerDBusProxy::getNowPlayingDataAttribute() {
          return nowPlayingData_;
      }
      MediaPlayerDBusProxy::PlayStateAttribute& MediaPlayerDBusProxy::getPlayStateAttribute() {
          return playState_;
      }
      MediaPlayerDBusProxy::SpeedAttribute& MediaPlayerDBusProxy::getSpeedAttribute() {
          return speed_;
      }
      MediaPlayerDBusProxy::RepeatModeAttribute& MediaPlayerDBusProxy::getRepeatModeAttribute() {
          return repeatMode_;
      }
      MediaPlayerDBusProxy::ShuffleModeAttribute& MediaPlayerDBusProxy::getShuffleModeAttribute() {
          return shuffleMode_;
      }
      MediaPlayerDBusProxy::NowPlayingArtworkStatusAttribute& MediaPlayerDBusProxy::getNowPlayingArtworkStatusAttribute() {
          return nowPlayingArtworkStatus_;
      }
      MediaPlayerDBusProxy::PlaybackPreviewAttribute& MediaPlayerDBusProxy::getPlaybackPreviewAttribute() {
          return playbackPreview_;
      }
      MediaPlayerDBusProxy::VideoPlayStatusAttribute& MediaPlayerDBusProxy::getVideoPlayStatusAttribute() {
          return videoPlayStatus_;
      }
      MediaPlayerDBusProxy::RemotePlayerCapabilityAttribute& MediaPlayerDBusProxy::getRemotePlayerCapabilityAttribute() {
          return remotePlayerCapability_;
      }
      MediaPlayerDBusProxy::MediaErrorAttribute& MediaPlayerDBusProxy::getMediaErrorAttribute() {
          return mediaError_;
      }
      MediaPlayerDBusProxy::SyncStatusAttribute& MediaPlayerDBusProxy::getSyncStatusAttribute() {
          return syncStatus_;
      }
      MediaPlayerDBusProxy::SeekStatusAttribute& MediaPlayerDBusProxy::getSeekStatusAttribute() {
          return seekStatus_;
      }
      MediaPlayerDBusProxy::FavouriteSupportedAttribute& MediaPlayerDBusProxy::getFavouriteSupportedAttribute() {
          return favouriteSupported_;
      }

MediaPlayerDBusProxy::RecentPlayListUpdateEvent& MediaPlayerDBusProxy::getRecentPlayListUpdateEvent() {
    return recentPlayListUpdate_;
}
    
    /**
     * description: Method to initiate the playback of all items of a specific object type in the
     *   device
     */
    void MediaPlayerDBusProxy::playAll(const uint8_t &_slotId, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_objectType, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_objectType(_objectType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "playAll",
        "yi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_slotId, deploy_objectType,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::playAllAsync(const uint8_t &_slotId, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_objectType, PlayAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_objectType(_objectType, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "playAll",
        "yi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_slotId, deploy_objectType,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::next(const uint64_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "next",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_step,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::nextAsync(const uint64_t &_step, NextAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "next",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::previous(const uint64_t &_step, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previous",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_step,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::previousAsync(const uint64_t &_step, PreviousAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_step(_step, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previous",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_step,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: Method to initiate the playback of the first item present in the next folder of
     *   a specific object type in the device.
     */
    void MediaPlayerDBusProxy::nextFolder(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eMediaError &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "nextFolder",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::nextFolderAsync(NextFolderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "nextFolder",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: Method to initiate the playback of the first item present in the previous
     *   folder of a specific object type in the device. 	[Input parameter]startIndopt
     *   :This parameter decides whether to play the first track in the previous folder
     *   or the last track in the previous folder
     */
    void MediaPlayerDBusProxy::previousFolder(const ::v1::com::harman::mmpres::MMPresTypes::startIndexOption &_startIndopt, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eMediaError &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::startIndexOption, CommonAPI::EmptyDeployment> deploy_startIndopt(_startIndopt, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::startIndexOption, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "previousFolder",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_startIndopt,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::previousFolderAsync(const ::v1::com::harman::mmpres::MMPresTypes::startIndexOption &_startIndopt, PreviousFolderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::startIndexOption, CommonAPI::EmptyDeployment> deploy_startIndopt(_startIndopt, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::startIndexOption, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "previousFolder",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_startIndopt,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMediaError, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::pause(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "pause",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::pauseAsync(PauseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "pause",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::resume(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "resume",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::resumeAsync(ResumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "resume",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::seekToTime(const uint64_t &_timePosition, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_timePosition(_timePosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "seekToTime",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_timePosition,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::seekToTimeAsync(const uint64_t &_timePosition, SeekToTimeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_timePosition(_timePosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "seekToTime",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_timePosition,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::fastForward(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "fastForward",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::fastForwardAsync(FastForwardAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "fastForward",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::fastReverse(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "fastReverse",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::fastReverseAsync(FastReverseAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "fastReverse",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::setRepeat(const ::v1::com::harman::mmpres::MMPresTypes::eRepeatMode &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setRepeat",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setRepeatAsync(const ::v1::com::harman::mmpres::MMPresTypes::eRepeatMode &_mode, SetRepeatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eRepeatMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setRepeat",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::setShuffle(const ::v1::com::harman::mmpres::MMPresTypes::eShuffleMode &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setShuffle",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_mode,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setShuffleAsync(const ::v1::com::harman::mmpres::MMPresTypes::eShuffleMode &_mode, SetShuffleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment> deploy_mode(_mode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eShuffleMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setShuffle",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_mode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtInformation(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation &_albumArtInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtInformation",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_albumArtInfo);
_albumArtInfo = deploy_albumArtInfo.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtInformationAsync(GetNowPlayingAlbumArtInformationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtInformation",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> _albumArtInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtInfo.getValue());
        },
        std::make_tuple(deploy_albumArtInfo));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtPath(const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtPath",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_imageNumber,
_internalCallStatus,
deploy_path);
_path = deploy_path.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtPathAsync(const uint8_t &_imageNumber, GetNowPlayingAlbumArtPathAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtPath",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue());
        },
        std::make_tuple(deploy_path));
    }
    void MediaPlayerDBusProxy::getNowPlayingAlbumArtData(const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint8_t> &_albumArtData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getNowPlayingAlbumArtData",
        "y",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_imageNumber,
_internalCallStatus,
deploy_albumArtData);
_albumArtData = deploy_albumArtData.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getNowPlayingAlbumArtDataAsync(const uint8_t &_imageNumber, GetNowPlayingAlbumArtDataAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getNowPlayingAlbumArtData",
        "y",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _albumArtData) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtData.getValue());
        },
        std::make_tuple(deploy_albumArtData));
    }
    void MediaPlayerDBusProxy::getAlbumArtInformationForTrack(const uint64_t &_trackId, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation &_albumArtInfo, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtInformationForTrack",
        "t",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId,
_internalCallStatus,
deploy_albumArtInfo);
_albumArtInfo = deploy_albumArtInfo.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtInformationForTrackAsync(const uint64_t &_trackId, GetAlbumArtInformationForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> deploy_albumArtInfo(static_cast<::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation,::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtInformationForTrack",
        "t",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::tAlbumArtInformation, ::v1::com::harman::mmpres::MMPresTypes_::tAlbumArtInformationDeployment_t> _albumArtInfo) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtInfo.getValue());
        },
        std::make_tuple(deploy_albumArtInfo));
    }
    void MediaPlayerDBusProxy::getAlbumArtPathForTrack(const uint64_t &_trackId, const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtPathForTrack",
        "ty",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId, deploy_imageNumber,
_internalCallStatus,
deploy_path);
_path = deploy_path.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtPathForTrackAsync(const uint64_t &_trackId, const uint8_t &_imageNumber, GetAlbumArtPathForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtPathForTrack",
        "ty",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId, deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue());
        },
        std::make_tuple(deploy_path));
    }
    void MediaPlayerDBusProxy::getAlbumArtDataForTrack(const uint64_t &_trackId, const uint8_t &_imageNumber, CommonAPI::CallStatus &_internalCallStatus, std::vector<uint8_t> &_albumArtData, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getAlbumArtDataForTrack",
        "ty",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_trackId, deploy_imageNumber,
_internalCallStatus,
deploy_albumArtData);
_albumArtData = deploy_albumArtData.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getAlbumArtDataForTrackAsync(const uint64_t &_trackId, const uint8_t &_imageNumber, GetAlbumArtDataForTrackAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_trackId(_trackId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_imageNumber(_imageNumber, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_albumArtData(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<uint8_t>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getAlbumArtDataForTrack",
        "ty",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_trackId, deploy_imageNumber,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<uint8_t>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _albumArtData) {
        	if (_callback)
        		_callback(_internalCallStatus, _albumArtData.getValue());
        },
        std::make_tuple(deploy_albumArtData));
    }
    void MediaPlayerDBusProxy::setSpeed(const uint8_t &_slotId, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_type, const ::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed &_speed, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(_speed, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setSpeed",
        "yii",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_slotId, deploy_type, deploy_speed,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::setSpeedAsync(const uint8_t &_slotId, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_type, const ::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed &_speed, SetSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(_speed, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setSpeed",
        "yii",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_slotId, deploy_type, deploy_speed,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    void MediaPlayerDBusProxy::getSpeed(const uint8_t &_slotId, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_type, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed &_speed, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getSpeed",
        "yi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_slotId, deploy_type,
_internalCallStatus,
deploy_speed);
_speed = deploy_speed.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::getSpeedAsync(const uint8_t &_slotId, const ::v1::com::harman::mmpres::MMPresTypes::eMetadataType &_type, GetSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_slotId(_slotId, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> deploy_speed(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eMetadataType, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getSpeed",
        "yi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_slotId, deploy_type,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::ePlaybackSpeed, CommonAPI::EmptyDeployment> _speed) {
        	if (_callback)
        		_callback(_internalCallStatus, _speed.getValue());
        },
        std::make_tuple(deploy_speed));
    }
    /**
     * description: This interface can be used to add currently playing track to Favourite List.
     */
    void MediaPlayerDBusProxy::addToFavouriteList(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "addToFavouriteList",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::addToFavouriteListAsync(AddToFavouriteListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "addToFavouriteList",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: This interface can be used to remove currently playing track from Favourite
     *   List.
     */
    void MediaPlayerDBusProxy::deleteFromFavouriteList(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::mmpres::MMPresTypes::eCallResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "deleteFromFavouriteList",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> MediaPlayerDBusProxy::deleteFromFavouriteListAsync(DeleteFromFavouriteListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "deleteFromFavouriteList",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::mmpres::MMPresTypes::eCallResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }


void MediaPlayerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 2;
      }

      } // namespace mmpres
      } // namespace harman
      } // namespace com
      } // namespace v1
