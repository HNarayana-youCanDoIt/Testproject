/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Provides interface to control the Software Update flow and to access the states
 *   and progress during the update process
 * author: Bharath Upadhya
 */
#include <v1/com/harman/swdl/SoftwareUpdateDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace swdl {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createSoftwareUpdateDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<SoftwareUpdateDBusProxy>(_address, _connection);
}

INITIALIZER(registerSoftwareUpdateDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		SoftwareUpdate::getInterface(),
		&createSoftwareUpdateDBusProxy);
}

SoftwareUpdateDBusProxy::SoftwareUpdateDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		softwareAvailableForDownloadAttr_(*this, "onSoftwareAvailableForDownloadAttrAttributeChanged", "a(isssuus)", "getSoftwareAvailableForDownloadAttrAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageListDeployment_t*>(nullptr)),
		softwareAvailableForInstallAttr_(*this, "onSoftwareAvailableForInstallAttrAttributeChanged", "a(isssuus)", "getSoftwareAvailableForInstallAttrAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageListDeployment_t*>(nullptr)),
		installProgress_(*this, "onInstallProgressAttributeChanged", "(yys)", "getInstallProgressAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tInstallProgressDeployment_t*>(nullptr)),
		downloadProgress_(*this, "onDownloadProgressAttributeChanged", "(yys)", "getDownloadProgressAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tDownloadProgressDeployment_t*>(nullptr)),
		activationResult_(*this, "onActivationResultAttributeChanged", "(i(isssuus))", "getActivationResultAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tActivationResultDeployment_t*>(nullptr)),
		lastUpdateSearchTime_(*this, "onLastUpdateSearchTimeAttributeChanged", "(qyyyyy)", "getLastUpdateSearchTimeAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tTimeDeployment_t*>(nullptr)),
		lastUpdateInstallTime_(*this, "onLastUpdateInstallTimeAttributeChanged", "(qyyyyy)", "getLastUpdateInstallTimeAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tTimeDeployment_t*>(nullptr)),
		status_(*this, "onStatusAttributeChanged", "(i(is)i)", "getStatusAttribute", static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tStatusDeployment_t*>(nullptr)),
		autoDownload_(*this, "onAutoDownloadAttributeChanged", "setAutoDownloadAttribute", "b", "getAutoDownloadAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		autoDownloadSizeLimit_(*this, "onAutoDownloadSizeLimitAttributeChanged", "setAutoDownloadSizeLimitAttribute", "b", "getAutoDownloadSizeLimitAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		autoInstall_(*this, "onAutoInstallAttributeChanged", "setAutoInstallAttribute", "b", "getAutoInstallAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		autoSearch_(*this, "onAutoSearchAttributeChanged", "setAutoSearchAttribute", "b", "getAutoSearchAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		autoSearchInterval_(*this, "onAutoSearchIntervalAttributeChanged", "setAutoSearchIntervalAttribute", "u", "getAutoSearchIntervalAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		allowVersionDowngrade_(*this, "onAllowVersionDowngradeAttributeChanged", "setAllowVersionDowngradeAttribute", "b", "getAllowVersionDowngradeAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
,		softwareAvailableForDownload_(*this, "SoftwareAvailableForDownload", "(isssuus)", std::make_tuple(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t*>(nullptr))),
		softwareAvailableForInstall_(*this, "SoftwareAvailableForInstall", "(isssuus)", std::make_tuple(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t*>(nullptr))),
		softwareUpdateStatus_(*this, "SoftwareUpdateStatus", "(i(is)i)i", std::make_tuple(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tStatusDeployment_t*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}

      SoftwareUpdateDBusProxy::SoftwareAvailableForDownloadAttrAttribute& SoftwareUpdateDBusProxy::getSoftwareAvailableForDownloadAttrAttribute() {
          return softwareAvailableForDownloadAttr_;
      }
      SoftwareUpdateDBusProxy::SoftwareAvailableForInstallAttrAttribute& SoftwareUpdateDBusProxy::getSoftwareAvailableForInstallAttrAttribute() {
          return softwareAvailableForInstallAttr_;
      }
      SoftwareUpdateDBusProxy::InstallProgressAttribute& SoftwareUpdateDBusProxy::getInstallProgressAttribute() {
          return installProgress_;
      }
      SoftwareUpdateDBusProxy::DownloadProgressAttribute& SoftwareUpdateDBusProxy::getDownloadProgressAttribute() {
          return downloadProgress_;
      }
      SoftwareUpdateDBusProxy::ActivationResultAttribute& SoftwareUpdateDBusProxy::getActivationResultAttribute() {
          return activationResult_;
      }
      SoftwareUpdateDBusProxy::LastUpdateSearchTimeAttribute& SoftwareUpdateDBusProxy::getLastUpdateSearchTimeAttribute() {
          return lastUpdateSearchTime_;
      }
      SoftwareUpdateDBusProxy::LastUpdateInstallTimeAttribute& SoftwareUpdateDBusProxy::getLastUpdateInstallTimeAttribute() {
          return lastUpdateInstallTime_;
      }
      SoftwareUpdateDBusProxy::StatusAttribute& SoftwareUpdateDBusProxy::getStatusAttribute() {
          return status_;
      }
      SoftwareUpdateDBusProxy::AutoDownloadAttribute& SoftwareUpdateDBusProxy::getAutoDownloadAttribute() {
          return autoDownload_;
      }
      SoftwareUpdateDBusProxy::AutoDownloadSizeLimitAttribute& SoftwareUpdateDBusProxy::getAutoDownloadSizeLimitAttribute() {
          return autoDownloadSizeLimit_;
      }
      SoftwareUpdateDBusProxy::AutoInstallAttribute& SoftwareUpdateDBusProxy::getAutoInstallAttribute() {
          return autoInstall_;
      }
      SoftwareUpdateDBusProxy::AutoSearchAttribute& SoftwareUpdateDBusProxy::getAutoSearchAttribute() {
          return autoSearch_;
      }
      SoftwareUpdateDBusProxy::AutoSearchIntervalAttribute& SoftwareUpdateDBusProxy::getAutoSearchIntervalAttribute() {
          return autoSearchInterval_;
      }
      SoftwareUpdateDBusProxy::AllowVersionDowngradeAttribute& SoftwareUpdateDBusProxy::getAllowVersionDowngradeAttribute() {
          return allowVersionDowngrade_;
      }

SoftwareUpdateDBusProxy::SoftwareAvailableForDownloadEvent& SoftwareUpdateDBusProxy::getSoftwareAvailableForDownloadEvent() {
    return softwareAvailableForDownload_;
}
SoftwareUpdateDBusProxy::SoftwareAvailableForInstallEvent& SoftwareUpdateDBusProxy::getSoftwareAvailableForInstallEvent() {
    return softwareAvailableForInstall_;
}
SoftwareUpdateDBusProxy::SoftwareUpdateStatusEvent& SoftwareUpdateDBusProxy::getSoftwareUpdateStatusEvent() {
    return softwareUpdateStatus_;
}
    
    /**
     * description: Trigger to search for any software updates available for download and install
     *   from the available sources.                        e.g check for updates from
     *   OTA server or update packages within connected mass storage devices etc
     */
    void SoftwareUpdateDBusProxy::CheckForUpdates(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t> deploy_checkResult(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult,::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "CheckForUpdates",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_checkResult);
_error = deploy_error.getValue();
_checkResult = deploy_checkResult.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::CheckForUpdatesAsync(CheckForUpdatesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t> deploy_checkResult(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult,::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "CheckForUpdates",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t> _checkResult) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _checkResult.getValue());
        },
        std::make_tuple(deploy_error, deploy_checkResult));
    }
    /**
     * description: Trigger to search for specific update package via its name and matching hash in
     *   a source (e.g. Mass Storage Device)                          Parameters:
     */
    void SoftwareUpdateDBusProxy::CheckPackageForUpdate(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_packageName(_packageName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue, CommonAPI::EmptyDeployment> deploy_hash(_hash, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource, CommonAPI::EmptyDeployment> deploy_source(_source, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t> deploy_checkResult(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult,::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "CheckPackageForUpdate",
        "sayi",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_packageName, deploy_hash, deploy_source,
_internalCallStatus,
deploy_error,
deploy_checkResult);
_error = deploy_error.getValue();
_checkResult = deploy_checkResult.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::CheckPackageForUpdateAsync(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CheckPackageForUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_packageName(_packageName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue, CommonAPI::EmptyDeployment> deploy_hash(_hash, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource, CommonAPI::EmptyDeployment> deploy_source(_source, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t> deploy_checkResult(static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult,::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "CheckPackageForUpdate",
        "sayi",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_packageName, deploy_hash, deploy_source,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tUpdateSearchResultDeployment_t> _checkResult) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _checkResult.getValue());
        },
        std::make_tuple(deploy_error, deploy_checkResult));
    }
    /**
     * description: Trigger to perform a possible download action on newly available software.
     */
    void SoftwareUpdateDBusProxy::RequestDownload(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload, CommonAPI::EmptyDeployment> deploy_requestDownload(_requestDownload, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestDownload",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_requestDownload,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::RequestDownloadAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, RequestDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload, CommonAPI::EmptyDeployment> deploy_requestDownload(_requestDownload, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestDownload",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_requestDownload,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Trigger to perform a possible installation action on newly available software  
     *                         (Note : Package might be already downloaded from
     *   external sources to the internal device cache or ready for installation from
     *   external source)
     */
    void SoftwareUpdateDBusProxy::RequestInstall(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall, CommonAPI::EmptyDeployment> deploy_installPackage(_installPackage, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestInstall",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_installPackage,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::RequestInstallAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, RequestInstallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall, CommonAPI::EmptyDeployment> deploy_installPackage(_installPackage, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestInstall",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_installPackage,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Method interface to request installation of the specific package located at a
     *   path specified via argument
     */
    void SoftwareUpdateDBusProxy::RequestDownloadPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t> deploy_downloadPackage(_downloadPackage, static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestDownloadPackage",
        "(isssuus)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_downloadPackage,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::RequestDownloadPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, RequestDownloadPackageAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t> deploy_downloadPackage(_downloadPackage, static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestDownloadPackage",
        "(isssuus)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_downloadPackage,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: Method interface to request installation of the specific package located at a
     *   path specified via argument
     */
    void SoftwareUpdateDBusProxy::RequestInstallPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t> deploy_installPackage(_installPackage, static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestInstallPackage",
        "(isssuus)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_installPackage,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::RequestInstallPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, RequestInstallPackageAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t> deploy_installPackage(_installPackage, static_cast<::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails, ::v1::com::harman::swdl::SoftwareUpdateTypes_::tPackageDetailsDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestInstallPackage",
        "(isssuus)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_installPackage,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: To cancel the download which is already started.         Deprecated for future
     *   use , Instead use RequestDownload(CANCEL_DOWNLOAD)
     */
    void SoftwareUpdateDBusProxy::CancelDownload(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "CancelDownload",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::CancelDownloadAsync(CancelDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "CancelDownload",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: To cancel the installation which is already in progress.         Deprecated for
     *   future use , Instead use RequestInstall(CANCEL_INSTALLATION)
     */
    void SoftwareUpdateDBusProxy::CancelInstall(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "CancelInstall",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::CancelInstallAsync(CancelInstallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "CancelInstall",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: To enable or disable automatic download of the package from external source
     *   (e.g. OTA server or Mass storage device) in to the device cached.
     */
    void SoftwareUpdateDBusProxy::SetAutomaticDownload(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enableAutoDownload(_enableAutoDownload, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_autoDownloadLimit(_autoDownloadLimit, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetAutomaticDownload",
        "bu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_enableAutoDownload, deploy_autoDownloadLimit,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::SetAutomaticDownloadAsync(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, SetAutomaticDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enableAutoDownload(_enableAutoDownload, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_autoDownloadLimit(_autoDownloadLimit, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetAutomaticDownload",
        "bu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_enableAutoDownload, deploy_autoDownloadLimit,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: To get the current enable/disable status for automatic download.
     */
    void SoftwareUpdateDBusProxy::GetAutomaticDownloadStatus(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_enableAutoDownload, uint32_t &_autoDownloadLimit, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enableAutoDownload(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_autoDownloadLimit(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<uint32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "GetAutomaticDownloadStatus",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_enableAutoDownload, deploy_autoDownloadLimit);
_error = deploy_error.getValue();
_enableAutoDownload = deploy_enableAutoDownload.getValue();
_autoDownloadLimit = deploy_autoDownloadLimit.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::GetAutomaticDownloadStatusAsync(GetAutomaticDownloadStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enableAutoDownload(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_autoDownloadLimit(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<uint32_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "GetAutomaticDownloadStatus",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _enableAutoDownload, CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> _autoDownloadLimit) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _enableAutoDownload.getValue(), _autoDownloadLimit.getValue());
        },
        std::make_tuple(deploy_error, deploy_enableAutoDownload, deploy_autoDownloadLimit));
    }
    /**
     * description: Request for activation of recently installed software ;                        
     *   Installation complete is notified via states INSTALLATION_COMPLETE or
     *   READY_FOR_ACTIVATION                        Post this API trigger , system
     *   will be restarted to new lifecycle to effect the new software
     */
    void SoftwareUpdateDBusProxy::ActivateSoftware(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "ActivateSoftware",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::ActivateSoftwareAsync(ActivateSoftwareAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "ActivateSoftware",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: To completely disable the software update feature. When the update is disbaled,
     *                           software update process will neither check for any
     *   updates on its own not process any APIs to serach for updates.
     */
    void SoftwareUpdateDBusProxy::DisableSoftwareUpdate(const bool &_disable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_disable(_disable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "DisableSoftwareUpdate",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_disable,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::DisableSoftwareUpdateAsync(const bool &_disable, DisableSoftwareUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_disable(_disable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "DisableSoftwareUpdate",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_disable,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: retrieve if software update service is currently enabled or disabled
     */
    void SoftwareUpdateDBusProxy::GetDisableSoftwareUpdate(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_disable, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_disable(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "GetDisableSoftwareUpdate",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error,
deploy_disable);
_error = deploy_error.getValue();
_disable = deploy_disable.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::GetDisableSoftwareUpdateAsync(GetDisableSoftwareUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_disable(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "GetDisableSoftwareUpdate",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _disable) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue(), _disable.getValue());
        },
        std::make_tuple(deploy_error, deploy_disable));
    }
    /**
     * description: To abort any on going search for updates.
     */
    void SoftwareUpdateDBusProxy::AbortSearch(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "AbortSearch",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::AbortSearchAsync(AbortSearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "AbortSearch",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: To enable / disable automatic installation of the available/downloaded package
     *   without the confirmation from the client .
     */
    void SoftwareUpdateDBusProxy::SetAutomaticInstallation(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "SetAutomaticInstallation",
        "b",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_enable,
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::SetAutomaticInstallationAsync(const bool &_enable, SetAutomaticInstallationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_enable(_enable, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "SetAutomaticInstallation",
        "b",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_enable,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }
    /**
     * description: method trigger to reset the Software update states back to idle along with
     *   resetting the settings back to default.                        Clears any
     *   internal cache/status informations. If service is already in installation
     *   stage , request will not be processed
     */
    void SoftwareUpdateDBusProxy::RequestFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "RequestFactoryReset",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_error);
_error = deploy_error.getValue();
}
    std::future<CommonAPI::CallStatus> SoftwareUpdateDBusProxy::RequestFactoryResetAsync(RequestFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> deploy_error(static_cast<CommonAPI::EmptyDeployment *>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "RequestFactoryReset",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult, CommonAPI::EmptyDeployment> _deploy_error) {
        	if (_callback)
        		_callback(_internalCallStatus, _deploy_error.getValue());
        },
        std::make_tuple(deploy_error));
    }


void SoftwareUpdateDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 2;
      }

      } // namespace swdl
      } // namespace harman
      } // namespace com
      } // namespace v1
