/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v1/com/harman/layermanager/LayerManagerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace layermanager {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createLayerManagerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<LayerManagerDBusProxy>(_address, _connection);
}

INITIALIZER(registerLayerManagerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		LayerManager::getInterface(),
		&createLayerManagerDBusProxy);
}

LayerManagerDBusProxy::LayerManagerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		eventUpdateSelective_(*this, "eventUpdate", "iu", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		propertyUpdateSelective_(*this, "propertyUpdate", "(ii(yv))", std::make_tuple(static_cast<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t*>(nullptr)))
{
}


LayerManagerDBusProxy::EventUpdateSelectiveEvent& LayerManagerDBusProxy::getEventUpdateSelectiveEvent() {
    return eventUpdateSelective_;
}
LayerManagerDBusProxy::PropertyUpdateSelectiveEvent& LayerManagerDBusProxy::getPropertyUpdateSelectiveEvent() {
    return propertyUpdateSelective_;
}
    
    /**
     * description: This is different from the Common API broadcast/attribute subscription. Client
     *   can subscribe to events like creation,destruction etc for a particular
     *   surface/layer/display. 					  The API will always be successfull, and will
     *   cause conditional broadcasts to be triggered to the registering clients.   
     *   					  Before calling this function ensure that you have subscribed to the
     *   propertyUpdate broadcast.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: name: 		  The string name for the desired object. The string name can be
     *   checked in LayerManager.conf
     * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
     * param: eventFilter:	  Bitmask combination of events interested in (Look at tEventType)
     *                      returns:	  nothing
     */
    void LayerManagerDBusProxy::subscribeEvents(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, const uint64_t &_eventFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_eventFilter(_eventFilter, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_isSubscribe(_isSubscribe, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "subscribeEvents",
        "istb",
deploy_type, deploy_name, deploy_eventFilter, deploy_isSubscribe,
_internalCallStatus);
}
    void LayerManagerDBusProxy::setProperty(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t>> deploy_property(_property, static_cast<CommonAPI::DBus::ArrayDeployment<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t>*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setProperty",
        "a(ii(yv))",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_property,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::setPropertyAsync(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, SetPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t>> deploy_property(_property, static_cast<CommonAPI::DBus::ArrayDeployment<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t>*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty>, CommonAPI::DBus::ArrayDeployment<::v1::com::harman::layermanager::LayerManagerTypes_::tPropertyDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setProperty",
        "a(ii(yv))",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_property,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: This is different from the Common API broadcast/attribute subscription. Client
     *   can subscribe to events like creation,visibility change, resize etc for a
     *   particular surface/layer. 					  The API will always be successfull, and will
     *   cause conditional broadcasts to be triggered to the registering clients.   
     *   					  Before calling this function ensure that you have subscribed to the
     *   propertyUpdate broadcast.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: id: 			  The string identifier for the desired object. The string identifier
     *   can be checked in LayerManager.conf
     * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
     * param: propFilter:	  Bitmask combination of properties interested in (Look at
     *   tPropertyType)                    returns:	  nothing
     */
    void LayerManagerDBusProxy::subscribeProps(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_id, const uint64_t &_propFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus) {
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_id(_id, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_propFilter(_propFilter, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_isSubscribe(_isSubscribe, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethod(
        *this,
        "subscribeProps",
        "istb",
deploy_type, deploy_id, deploy_propFilter, deploy_isSubscribe,
_internalCallStatus);
}
    /**
     * description: Removes all event / property subscription for a client.             returns:	 
     *   Nothing..
     */
    void LayerManagerDBusProxy::unsubscribeAll(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "unsubscribeAll",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::unsubscribeAllAsync(UnsubscribeAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "unsubscribeAll",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: Initiate a capture operation for the display,layer or surface. Will only return
     *   once the operation finished successfully/failed. 		Add periodic.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: name: 		  The string name for the desired object. The string identifier can be
     *   checked in LayerManager.conf                    returns:	  path: 		  If
     *   successfull, returns the path to the PNG file.           returns:    
     *   result:		  Status of operation.
     */
    void LayerManagerDBusProxy::screenshot(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "screenshot",
        "is",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_type, deploy_name,
_internalCallStatus,
deploy_path, deploy_result);
_path = deploy_path.getValue();
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::screenshotAsync(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, ScreenshotAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment> deploy_type(_type, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_name(_name, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_path(static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string,CommonAPI::DBus::StringDeployment>,
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "screenshot",
        "is",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_type, deploy_name,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> _path, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _path.getValue(), _result.getValue());
        },
        std::make_tuple(deploy_path, deploy_result));
    }
    /**
     * description: This API will set the visibility of a layer to true, if no higher priority
     *   layers are not currently visible.   				      There are no implicit z order /
     *   alpha changes.  				      Any layers at the same priority level will be hidden
     *   implicitly.  					  For more specific use cases, use the command API.
     * param: :layerID	Layer ID matching in layermanager.conf	       	 		returns:	  result :
     *   Check enumeration for more details.
     */
    void LayerManagerDBusProxy::showLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_layerID(_layerID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "showLayerSafe",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_layerID,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::showLayerSafeAsync(const std::string &_layerID, ShowLayerSafeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_layerID(_layerID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "showLayerSafe",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_layerID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: This API will set the visibility of a layer to false. If any previous layer can
     *   be shown on screen, it is made visible.
     * param: :layerID	Layer ID matching in layermanager.conf 			returns:	  result : Check
     *   enumeration for more details.
     */
    void LayerManagerDBusProxy::hideLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_layerID(_layerID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "hideLayerSafe",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_layerID,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::hideLayerSafeAsync(const std::string &_layerID, HideLayerSafeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_layerID(_layerID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "hideLayerSafe",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_layerID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: This API will set the visibility of a surface to true. The surface can be
     *   hidden again if desired through the hideSurface interface.
     * param: surfaceID: surface ID matching in layermanager.conf
     * param: bestGuessAttach: If set to true, this parameter causes the layer manager to
     *   find an appropriate "visible" layer to attach this surface to. (before being
     *   shown).  							The bestGuessSurface must be defined in the "supportedlayers"
     *   attribute in the layermanager config. The attach will always be done to the
     *   first visible layer found in the 							 "supportedlayers" list. If no visible
     *   Layer is found to which the surface can be attached, then the API will fail. 
     *   	       	 		returns:	  result : Check enumeration for more details.
     */
    void LayerManagerDBusProxy::showSurface(const std::string &_surfaceID, const bool &_bestGuessAttach, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_surfaceID(_surfaceID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_bestGuessAttach(_bestGuessAttach, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "showSurface",
        "sb",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_surfaceID, deploy_bestGuessAttach,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::showSurfaceAsync(const std::string &_surfaceID, const bool &_bestGuessAttach, ShowSurfaceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_surfaceID(_surfaceID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_bestGuessAttach(_bestGuessAttach, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "showSurface",
        "sb",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_surfaceID, deploy_bestGuessAttach,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: This API will set the visibility of a surface to false.
     * param: surfaceID: surface ID matching in layermanager.conf 			returns:	  result :
     *   Check enumeration for more details.
     */
    void LayerManagerDBusProxy::hideSurface(const std::string &_surfaceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_surfaceID(_surfaceID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "hideSurface",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_surfaceID,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::hideSurfaceAsync(const std::string &_surfaceID, HideSurfaceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_surfaceID(_surfaceID, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "hideSurface",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_surfaceID,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }
    /**
     * description: Can be used to run any arbitrary command sequence. Command Sequences can be
     *   defined in LayerManagerCommands.ini file
     * param: :command	Cammand Sequence defined in LayerManagerCommands.ini 	       	
     *   		returns:	  result : Check enumeration for more details.
     */
    void LayerManagerDBusProxy::runCommand(const std::string &_command, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_command(_command, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "runCommand",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_command,
_internalCallStatus,
deploy_result);
_result = deploy_result.getValue();
}
    std::future<CommonAPI::CallStatus> LayerManagerDBusProxy::runCommandAsync(const std::string &_command, RunCommandAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_command(_command, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> deploy_result(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "runCommand",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_command,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v1::com::harman::layermanager::LayerManagerTypes::tResult, CommonAPI::EmptyDeployment> _result) {
        	if (_callback)
        		_callback(_internalCallStatus, _result.getValue());
        },
        std::make_tuple(deploy_result));
    }


void LayerManagerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 0;
      }

      } // namespace layermanager
      } // namespace harman
      } // namespace com
      } // namespace v1
