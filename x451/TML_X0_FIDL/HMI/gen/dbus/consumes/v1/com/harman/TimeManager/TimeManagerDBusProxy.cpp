/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v1/com/harman/TimeManager/TimeManagerDBusProxy.hpp>

namespace v1 {
namespace com {
namespace harman {
namespace TimeManager {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createTimeManagerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<TimeManagerDBusProxy>(_address, _connection);
}

INITIALIZER(registerTimeManagerDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		TimeManager::getInterface(),
		&createTimeManagerDBusProxy);
}

TimeManagerDBusProxy::TimeManagerDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		tzOffset_(*this, "onTzOffsetAttributeChanged", "setTzOffsetAttribute", "(iyy)", "getTzOffsetAttribute", static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::timeZoneOffsetDeployment_t*>(nullptr)),
		systemTimeWithTz_(*this, "onSystemTimeWithTzAttributeChanged", "(nnnnnnni)", "getSystemTimeWithTzAttribute", static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr)),
		systemTimeWithTz12Hr_(*this, "onSystemTimeWithTz12HrAttributeChanged", "(nnnnnnni)", "getSystemTimeWithTz12HrAttribute", static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr)),
		systemTimeWithTz24Hr_(*this, "onSystemTimeWithTz24HrAttributeChanged", "(nnnnnnni)", "getSystemTimeWithTz24HrAttribute", static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr)),
		systemTimeUTC_(*this, "onSystemTimeUTCAttributeChanged", "t", "getSystemTimeUTCAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr)),
		utcTime12Hr_(*this, "onUtcTime12HrAttributeChanged", "(nnnnnnni)", "getUtcTime12HrAttribute", static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr)),
		utcTime24Hr_(*this, "onUtcTime24HrAttributeChanged", "(nnnnnnni)", "getUtcTime24HrAttribute", static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr)),
		timeFormat_(*this, "onTimeFormatAttributeChanged", "i", "getTimeFormatAttribute", static_cast<CommonAPI::EmptyDeployment*>(nullptr))
{
}

      TimeManagerDBusProxy::TzOffsetAttribute& TimeManagerDBusProxy::getTzOffsetAttribute() {
          return tzOffset_;
      }
      TimeManagerDBusProxy::SystemTimeWithTzAttribute& TimeManagerDBusProxy::getSystemTimeWithTzAttribute() {
          return systemTimeWithTz_;
      }
      TimeManagerDBusProxy::SystemTimeWithTz12HrAttribute& TimeManagerDBusProxy::getSystemTimeWithTz12HrAttribute() {
          return systemTimeWithTz12Hr_;
      }
      TimeManagerDBusProxy::SystemTimeWithTz24HrAttribute& TimeManagerDBusProxy::getSystemTimeWithTz24HrAttribute() {
          return systemTimeWithTz24Hr_;
      }
      TimeManagerDBusProxy::SystemTimeUTCAttribute& TimeManagerDBusProxy::getSystemTimeUTCAttribute() {
          return systemTimeUTC_;
      }
      TimeManagerDBusProxy::UtcTime12HrAttribute& TimeManagerDBusProxy::getUtcTime12HrAttribute() {
          return utcTime12Hr_;
      }
      TimeManagerDBusProxy::UtcTime24HrAttribute& TimeManagerDBusProxy::getUtcTime24HrAttribute() {
          return utcTime24Hr_;
      }
      TimeManagerDBusProxy::TimeFormatAttribute& TimeManagerDBusProxy::getTimeFormatAttribute() {
          return timeFormat_;
      }

    
    /**
     * description: disableTimeSource 		This method is used to let TM know about which source to
     *   disable.    		input: sourceName - valid configured source name. The
     *   configuration of TM should be refered for this.    		output: status - true if
     *   the source is disabled. false if source disabling falied.
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::disableTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceName(_sourceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "disableTimeSource",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceName,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::disableTimeSourceAsync(const std::string &_sourceName, DisableTimeSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceName(_sourceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "disableTimeSource",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: getEnabledSources  		Get the list of enabled sources    		output:
     *   sourceNameList - Gets the list of the sourceNames which are currently enabled
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::getEnabledSources(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_sourceNameList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<std::string>, CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>> deploy_sourceNameList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<std::string>,CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getEnabledSources",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_sourceNameList);
_sourceNameList = deploy_sourceNameList.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::getEnabledSourcesAsync(GetEnabledSourcesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<std::string>, CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>> deploy_sourceNameList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<std::string>,CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getEnabledSources",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<std::string>, CommonAPI::DBus::ArrayDeployment<CommonAPI::DBus::StringDeployment>> _sourceNameList) {
        	if (_callback)
        		_callback(_internalCallStatus, _sourceNameList.getValue());
        },
        std::make_tuple(deploy_sourceNameList));
    }
    /**
     * description: selectTimeSource	 		Enable the time source    		input: sourceName - valid
     *   configured source name. The configuration of TM should be refered for this.   
     *   		output: holdOffTime - -1 or value greater than 0. The value will be -1 in
     *   case the selected source is not operational.    		Else the configured holdOff
     *   time will be returned.     		This method is used to enable a specific
     *   timeSource. Here TimeManager will not disable the other sources.   
     *   		Accordingly the source will be enabled by TM for fetching and sending the
     *   data to Chrony.
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::selectTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, int16_t &_holdOffTime, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceName(_sourceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_holdOffTime(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int16_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "selectTimeSource",
        "s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceName,
_internalCallStatus,
deploy_holdOffTime);
_holdOffTime = deploy_holdOffTime.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::selectTimeSourceAsync(const std::string &_sourceName, SelectTimeSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceName(_sourceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_holdOffTime(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<int16_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "selectTimeSource",
        "s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceName,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> _holdOffTime) {
        	if (_callback)
        		_callback(_internalCallStatus, _holdOffTime.getValue());
        },
        std::make_tuple(deploy_holdOffTime));
    }
    /**
     * description: changeTM_State  		Change state of TM    		input: newState - valid state from
     *   the described TM_States.    		output: currState - Current state of the TM. If
     *   the provided newState is invalid with respect to the    		state transition the
     *   privious state will be kept unchanged and the same will be retured.
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::changeTM_State(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_currState, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment> deploy_newState(_newState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment> deploy_currState(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "changeTM_State",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_newState,
_internalCallStatus,
deploy_currState);
_currState = deploy_currState.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::changeTM_StateAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, ChangeTM_StateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment> deploy_newState(_newState, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment> deploy_currState(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "changeTM_State",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_newState,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States, CommonAPI::EmptyDeployment> _currState) {
        	if (_callback)
        		_callback(_internalCallStatus, _currState.getValue());
        },
        std::make_tuple(deploy_currState));
    }
    /**
     * description: changeTM_OperationalMode 	 		Change the operation mode    		input: newMode -
     *   valid mode from the described TM_operationalMode.    		output: currMode -
     *   Current operational mode TM is working after the change is made.
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::changeTM_OperationalMode(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_currMode, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment> deploy_newMode(_newMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment> deploy_currMode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "changeTM_OperationalMode",
        "i",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_newMode,
_internalCallStatus,
deploy_currMode);
_currMode = deploy_currMode.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::changeTM_OperationalModeAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, ChangeTM_OperationalModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment> deploy_newMode(_newMode, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment> deploy_currMode(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "changeTM_OperationalMode",
        "i",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_newMode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode, CommonAPI::EmptyDeployment> _currMode) {
        	if (_callback)
        		_callback(_internalCallStatus, _currMode.getValue());
        },
        std::make_tuple(deploy_currMode));
    }
    /**
     * description: updateSourceTime_wellFormed	 		Update time from a time source    		input:
     *   newTime - new time value which is defined time data structure.     		sourceId:
     *   Source ID as configured in TM configuration     		output: status - true:
     *   update is succesful, false:failure in the update. For failure there can   
     *   		be two issues. Either sourceId is not valid or provided newTime is not valid.
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::updateSourceTime_wellFormed(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t> deploy_newTime(_newTime, static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "updateSourceTime_wellFormed",
        "(nnnnnnni)s",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_newTime, deploy_sourceId,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::updateSourceTime_wellFormedAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, UpdateSourceTime_wellFormedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t> deploy_newTime(_newTime, static_cast<::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime, ::v0::com::harman::TimeManager::timeManagerServiceTypes_::systemTimeDeployment_t >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "updateSourceTime_wellFormed",
        "(nnnnnnni)s",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_newTime, deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: updateSourceTime_UTC 	 		Update time from a time source    		input: newUTCTime
     *   - new time value in UTC format, sourceId: Source ID as configured in TM
     *   configuration     		output: status - true: update is succesful, false:failure
     *   in the update. For failure there can    		be two issues. Either sourceId is
     *   not valid or provided newTime is not valid.
     * author: Bhushan J
     */
    void TimeManagerDBusProxy::updateSourceTime_UTC(const uint64_t &_newUTCTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_newUTCTime(_newUTCTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "updateSourceTime_UTC",
        "ts",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_newUTCTime, deploy_sourceId,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::updateSourceTime_UTCAsync(const uint64_t &_newUTCTime, const std::string &_sourceId, UpdateSourceTime_UTCAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment> deploy_newUTCTime(_newUTCTime, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceId(_sourceId, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint64_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "updateSourceTime_UTC",
        "ts",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_newUTCTime, deploy_sourceId,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }
    /**
     * description: Get current format of the time
     * author: Tarun Thomas
     */
    void TimeManagerDBusProxy::getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment> deploy_format(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getTimeFormat",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_format);
_format = deploy_format.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::getTimeFormatAsync(GetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment> deploy_format(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getTimeFormat",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment> _format) {
        	if (_callback)
        		_callback(_internalCallStatus, _format.getValue());
        },
        std::make_tuple(deploy_format));
    }
    /**
     * description: Set current format for the time
     * author: Tarun Thomas
     */
    void TimeManagerDBusProxy::setTimeFormat(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceName(_sourceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment> deploy_format(_format, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "setTimeFormat",
        "si",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sourceName, deploy_format,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> TimeManagerDBusProxy::setTimeFormatAsync(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, SetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_sourceName(_sourceName, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment> deploy_format(_format, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_status(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "setTimeFormat",
        "si",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sourceName, deploy_format,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }


void TimeManagerDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 1;
          ownVersionMinor = 3;
      }

      } // namespace TimeManager
      } // namespace harman
      } // namespace com
      } // namespace v1
