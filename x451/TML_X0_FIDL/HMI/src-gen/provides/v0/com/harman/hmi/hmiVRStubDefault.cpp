/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#include <v0/com/harman/hmi/hmiVRStubDefault.hpp>
#include <assert.h>

namespace v0 {
namespace com {
namespace harman {
namespace hmi {

hmiVRStubDefault::hmiVRStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(hmiVR::getInterfaceVersion()) {
}

const CommonAPI::Version& hmiVRStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

hmiVRStubRemoteEvent* hmiVRStubDefault::initStubAdapter(const std::shared_ptr<hmiVRStubAdapter> &_adapter) {
    CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}


/**
 * description: Method to be invoked to display teleprompter list in HMI.
 */
void hmiVRStubDefault::showTelePrompterList(const std::shared_ptr<CommonAPI::ClientId> _client, std::vector<std::string> _strAryTelePrompterlist, showTelePrompterListReply_t _reply) {
    (void)_client;
    (void) _strAryTelePrompterlist;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to display picklist in HMI.
 */
void hmiVRStubDefault::showPickList(const std::shared_ptr<CommonAPI::ClientId> _client, std::vector<std::string> _strAryPicklist, std::string _strContextTitle, showPickListReply_t _reply) {
    (void)_client;
    (void) _strAryPicklist;
    (void) _strContextTitle;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to display picklist in HMI.
 */
void hmiVRStubDefault::showPickList(const std::shared_ptr<CommonAPI::ClientId> _client, std::vector<std::string> _strAryPicklist, showPickList1Reply_t _reply) {
    (void)_client;
    (void) _strAryPicklist;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to remove the picklist from HMI.
 */
void hmiVRStubDefault::hidePickList(const std::shared_ptr<CommonAPI::ClientId> _client, hidePickListReply_t _reply) {
    (void)_client;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to select an item from the pick list.
 */
void hmiVRStubDefault::setFocusedItem(const std::shared_ptr<CommonAPI::ClientId> _client, int32_t _iLineNo, setFocusedItemReply_t _reply) {
    (void)_client;
    (void) _iLineNo;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to switch to the required HMI screen.
 */
void hmiVRStubDefault::setScreen(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _strScreenName, setScreenReply_t _reply) {
    (void)_client;
    (void) _strScreenName;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to switch to different categories during media browse.
 */
void hmiVRStubDefault::mediaFilterListShow(const std::shared_ptr<CommonAPI::ClientId> _client, ::v0::com::harman::hmi::hmiVRTypes::EFilterIDType _eFilterType, int64_t _iFilterId, mediaFilterListShowReply_t _reply) {
    (void)_client;
    (void) _eFilterType;
    (void) _iFilterId;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to display contact details of the particular contact.
 */
void hmiVRStubDefault::showContact(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _strDatabaseType, int32_t _iContactId, showContactReply_t _reply) {
    (void)_client;
    (void) _strDatabaseType;
    (void) _iContactId;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}

/**
 * description: Method to be invoked to set the focus on a particular category.
 */
void hmiVRStubDefault::focusSelectedCategory(const std::shared_ptr<CommonAPI::ClientId> _client, std::string _strCategory, focusSelectedCategoryReply_t _reply) {
    (void)_client;
    (void) _strCategory;
    ::v0::com::harman::hmi::hmiVRTypes::EResponseType eResp = ::v0::com::harman::hmi::hmiVRTypes::EResponseType::EN_SUCCESS;
    if (!eResp.validate()) {
        return;
    }
    _reply(eResp);
}


/**
 * description: Signal shall be broadcast to activate VR.
 */
void hmiVRStubDefault::fireActivateVREvent(const ::v0::com::harman::hmi::hmiVRTypes::EKeyState &_eKeyState, const ::v0::com::harman::hmi::hmiVRTypes::EScreenName &_eScreenName) {
    if (!_eKeyState.validate()) {
        return;
    }
    if (!_eScreenName.validate()) {
        return;
    }
    assert((CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireActivateVREvent(_eKeyState, _eScreenName);
}
/**
 * description: Signal shall be broadcast to activate VR.
 */
void hmiVRStubDefault::fireActivateVREvent(const ::v0::com::harman::hmi::hmiVRTypes::EKeyState &_eKeyState) {
    if (!_eKeyState.validate()) {
        return;
    }
    assert((CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireActivateVREvent(_eKeyState);
}
/**
 * description: Signal shall be broadcast to de-activate VR.
 */
void hmiVRStubDefault::fireCancelVREvent() {
    assert((CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireCancelVREvent();
}
/**
 * description: Signal shall be broadcast when ever any pick list item is selected from HMI.
 */
void hmiVRStubDefault::fireListItemTouchEvent(const int32_t &_iFocusedItem) {
    assert((CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<hmiVRStubAdapter, hmiVRStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireListItemTouchEvent(_iFocusedItem);
}


hmiVRStubDefault::RemoteEventHandler::RemoteEventHandler(hmiVRStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace hmi
} // namespace harman
} // namespace com
} // namespace v0
