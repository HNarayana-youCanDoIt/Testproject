/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Orinoco specific tuner data type collection.
 * author: Harman, CoC Tuner, Dirk Engel (c) copyright 2016
 */
#ifndef V3_COM_HARMAN_TUNER_Orinoco_Tuner_Types_HPP_
#define V3_COM_HARMAN_TUNER_Orinoco_Tuner_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace com {
namespace harman {
namespace tuner {

struct OrinocoTunerTypes {
    
    struct Source : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SRC_NONE = 0,
            SRC_FM = 1,
            SRC_SW = 2,
            SRC_MW = 4,
            SRC_LW = 8,
            SRC_DAB = 16,
            SRC_DRM = 32,
            SRC_HD = 64
        };
        
        Source() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SRC_NONE)) {}
        Source(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SRC_NONE):
                case static_cast<int32_t>(Literal::SRC_FM):
                case static_cast<int32_t>(Literal::SRC_SW):
                case static_cast<int32_t>(Literal::SRC_MW):
                case static_cast<int32_t>(Literal::SRC_LW):
                case static_cast<int32_t>(Literal::SRC_DAB):
                case static_cast<int32_t>(Literal::SRC_DRM):
                case static_cast<int32_t>(Literal::SRC_HD):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Source &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Source &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Source &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Source &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Source &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Source &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StationSeekMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SEEK_OFF = 0,
            SEEK_MAN_UP = 1,
            SEEK_MAN_DOWN = 2,
            SEEK_AUTO_UP = 3,
            SEEK_AUTO_DOWN = 4,
            SEEK_ENDLESS_UP = 5,
            SEEK_ENDLESS_DOWN = 6,
            SEEK_SCAN_UP = 7,
            SEEK_SCAN_SKIP_UP = 8,
            SEEK_SCAN_DOWN = 9,
            SEEK_SCAN_SKIP_DOWN = 10,
            SEEK_FULL_AUTOSTORE = 11,
            SEEK_FULL_BACKGROUND = 12,
            SEEK_LIKE = 256,
            SEEK_LIKE_AUTO_UP = 259,
            SEEK_LIKE_AUTO_DOWN = 260,
            SEEK_LIKE_ENDLESS_UP = 261,
            SEEK_LIKE_ENDLESS_DOWN = 262,
            SEEK_LIKE_SCAN_UP = 263,
            SEEK_LIKE_SCAN_SKIP_UP = 264,
            SEEK_LIKE_SCAN_DOWN = 265,
            SEEK_LIKE_SCAN_SKIP_DOWN = 266,
            SEEK_LIKE_FULL_AUTOSTORE = 267,
            SEEK_LIKE_FULL_BACKGROUND = 268,
            SEEK_PTYMASK = 512,
            SEEK_PTYMASK_AUTO_UP = 515,
            SEEK_PTYMASK_AUTO_DOWN = 516,
            SEEK_PTYMASK_ENDLESS_UP = 517,
            SEEK_PTYMASK_ENDLESS_DOWN = 518,
            SEEK_PTYMASK_SCAN_UP = 519,
            SEEK_PTYMASK_SCAN_SKIP_UP = 520,
            SEEK_PTYMASK_SCAN_DOWN = 521,
            SEEK_PTYMASK_SCAN_SKIP_DOWN = 522,
            SEEK_PTYMASK_FULL_AUTOSTORE = 523,
            SEEK_PTYMASK_FULL_BACKGROUND = 524
        };
        
        StationSeekMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SEEK_OFF)) {}
        StationSeekMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SEEK_OFF):
                case static_cast<int32_t>(Literal::SEEK_MAN_UP):
                case static_cast<int32_t>(Literal::SEEK_MAN_DOWN):
                case static_cast<int32_t>(Literal::SEEK_AUTO_UP):
                case static_cast<int32_t>(Literal::SEEK_AUTO_DOWN):
                case static_cast<int32_t>(Literal::SEEK_ENDLESS_UP):
                case static_cast<int32_t>(Literal::SEEK_ENDLESS_DOWN):
                case static_cast<int32_t>(Literal::SEEK_SCAN_UP):
                case static_cast<int32_t>(Literal::SEEK_SCAN_SKIP_UP):
                case static_cast<int32_t>(Literal::SEEK_SCAN_DOWN):
                case static_cast<int32_t>(Literal::SEEK_SCAN_SKIP_DOWN):
                case static_cast<int32_t>(Literal::SEEK_FULL_AUTOSTORE):
                case static_cast<int32_t>(Literal::SEEK_FULL_BACKGROUND):
                case static_cast<int32_t>(Literal::SEEK_LIKE):
                case static_cast<int32_t>(Literal::SEEK_LIKE_AUTO_UP):
                case static_cast<int32_t>(Literal::SEEK_LIKE_AUTO_DOWN):
                case static_cast<int32_t>(Literal::SEEK_LIKE_ENDLESS_UP):
                case static_cast<int32_t>(Literal::SEEK_LIKE_ENDLESS_DOWN):
                case static_cast<int32_t>(Literal::SEEK_LIKE_SCAN_UP):
                case static_cast<int32_t>(Literal::SEEK_LIKE_SCAN_SKIP_UP):
                case static_cast<int32_t>(Literal::SEEK_LIKE_SCAN_DOWN):
                case static_cast<int32_t>(Literal::SEEK_LIKE_SCAN_SKIP_DOWN):
                case static_cast<int32_t>(Literal::SEEK_LIKE_FULL_AUTOSTORE):
                case static_cast<int32_t>(Literal::SEEK_LIKE_FULL_BACKGROUND):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_AUTO_UP):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_AUTO_DOWN):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_ENDLESS_UP):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_ENDLESS_DOWN):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_SCAN_UP):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_SCAN_SKIP_UP):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_SCAN_DOWN):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_SCAN_SKIP_DOWN):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_FULL_AUTOSTORE):
                case static_cast<int32_t>(Literal::SEEK_PTYMASK_FULL_BACKGROUND):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StationSeekMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StationSeekMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StationSeekMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StationSeekMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StationSeekMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StationSeekMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AnnouncementState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ANN_OFF = 0,
            ANN_ON_NONE = 1,
            ANN_ON_INACTIVE = 2,
            ANN_ON_ACTIVE = 3
        };
        
        AnnouncementState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ANN_OFF)) {}
        AnnouncementState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ANN_OFF):
                case static_cast<int32_t>(Literal::ANN_ON_NONE):
                case static_cast<int32_t>(Literal::ANN_ON_INACTIVE):
                case static_cast<int32_t>(Literal::ANN_ON_ACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AnnouncementState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AnnouncementState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AnnouncementState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AnnouncementState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AnnouncementState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AnnouncementState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmRegionCode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ARC_NONE = 65535,
            ARC_EUROPE = 0,
            ARC_NORTH_AMERICA = 1,
            ARC_SOUTH_AMERICA = 2,
            ARC_CANADA = 3,
            ARC_ASIA = 4,
            ARC_JAPAN = 5,
            ARC_SOUTH_KOREA = 6,
            ARC_CHINA = 7,
            ARC_AUSTRALIA = 8,
            ARC_SOUTH_AFRICA = 9,
            ARC_SOUTH_OCEANIA = 10,
            ARC_SOUTH_ROW = 11,
            ARC_SOUTH_BRAZIL = 12,
            ARC_SOUTH_MIDDLE_EAST = 13,
            ARC_SOUTH_INDIA = 14,
            ARC_SOUTH_RUSSIA = 15
        };
        
        AmFmRegionCode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ARC_NONE)) {}
        AmFmRegionCode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ARC_NONE):
                case static_cast<int32_t>(Literal::ARC_EUROPE):
                case static_cast<int32_t>(Literal::ARC_NORTH_AMERICA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_AMERICA):
                case static_cast<int32_t>(Literal::ARC_CANADA):
                case static_cast<int32_t>(Literal::ARC_ASIA):
                case static_cast<int32_t>(Literal::ARC_JAPAN):
                case static_cast<int32_t>(Literal::ARC_SOUTH_KOREA):
                case static_cast<int32_t>(Literal::ARC_CHINA):
                case static_cast<int32_t>(Literal::ARC_AUSTRALIA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_AFRICA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_OCEANIA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_ROW):
                case static_cast<int32_t>(Literal::ARC_SOUTH_BRAZIL):
                case static_cast<int32_t>(Literal::ARC_SOUTH_MIDDLE_EAST):
                case static_cast<int32_t>(Literal::ARC_SOUTH_INDIA):
                case static_cast<int32_t>(Literal::ARC_SOUTH_RUSSIA):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmRegionCode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmRegionCode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmRegionCode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmRegionCode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmRegionCode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmRegionCode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct DabRegionCode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DRC_NONE = 65535,
            DRC_EUROPE = 0,
            DRC_CANADA = 1,
            DRC_KOREA = 2,
            DRC_CHINA = 3,
            DRC_NEW_ZEALAND = 7
        };
        
        DabRegionCode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DRC_NONE)) {}
        DabRegionCode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DRC_NONE):
                case static_cast<int32_t>(Literal::DRC_EUROPE):
                case static_cast<int32_t>(Literal::DRC_CANADA):
                case static_cast<int32_t>(Literal::DRC_KOREA):
                case static_cast<int32_t>(Literal::DRC_CHINA):
                case static_cast<int32_t>(Literal::DRC_NEW_ZEALAND):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DabRegionCode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DabRegionCode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DabRegionCode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DabRegionCode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DabRegionCode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DabRegionCode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmCodingFlag : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            COD_AMFM_NONE = 0,
            COD_AMFM_BACKGROUND_AM = 1,
            COD_AMFM_BACKGROUND_FM = 2,
            COD_AMFM_HD = 4,
            COD_AMFM_DRM = 8
        };
        
        AmFmCodingFlag() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::COD_AMFM_NONE)) {}
        AmFmCodingFlag(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::COD_AMFM_NONE):
                case static_cast<int32_t>(Literal::COD_AMFM_BACKGROUND_AM):
                case static_cast<int32_t>(Literal::COD_AMFM_BACKGROUND_FM):
                case static_cast<int32_t>(Literal::COD_AMFM_HD):
                case static_cast<int32_t>(Literal::COD_AMFM_DRM):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmCodingFlag &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmCodingFlag &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmCodingFlag &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmCodingFlag &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmCodingFlag &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmCodingFlag &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct DabCodingFlag : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            COD_DAB_NONE = 0,
            COD_DAB_BACKGROUND = 1
        };
        
        DabCodingFlag() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::COD_DAB_NONE)) {}
        DabCodingFlag(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::COD_DAB_NONE):
                case static_cast<int32_t>(Literal::COD_DAB_BACKGROUND):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const DabCodingFlag &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const DabCodingFlag &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const DabCodingFlag &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const DabCodingFlag &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const DabCodingFlag &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const DabCodingFlag &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmHdMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            HD_ANALOG = 0,
            HD_AUTOMATIC = 1,
            HD_AUTOMATIC_AM = 2,
            HD_AUTOMATIC_FM = 3
        };
        
        AmFmHdMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::HD_ANALOG)) {}
        AmFmHdMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::HD_ANALOG):
                case static_cast<int32_t>(Literal::HD_AUTOMATIC):
                case static_cast<int32_t>(Literal::HD_AUTOMATIC_AM):
                case static_cast<int32_t>(Literal::HD_AUTOMATIC_FM):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmHdMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmHdMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmHdMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmHdMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmHdMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmHdMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StationListType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LIST_BACKGROUND = 0,
            LIST_AUTOSTORE = 1,
            LIST_PRESET = 2
        };
        
        StationListType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LIST_BACKGROUND)) {}
        StationListType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LIST_BACKGROUND):
                case static_cast<int32_t>(Literal::LIST_AUTOSTORE):
                case static_cast<int32_t>(Literal::LIST_PRESET):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StationListType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StationListType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StationListType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StationListType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StationListType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StationListType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TagType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TAG_ALARM = 0,
            TAG_TITLE = 1,
            TAG_ARTIST = 2,
            TAG_BAND = 3,
            TAG_NEWS = 4,
            TAG_NEWS_LOCAL = 5,
            TAG_NOW = 6,
            TAG_NEXT = 7,
            TAG_PHONE_HOTLINE = 8,
            TAG_EMAIL_HOTLINE = 9,
            TAG_HOMEPAGE = 10,
            TAG_TRAFFIC = 11,
            TAG_WEATHER = 12,
            TAG_EDITORIAL = 13,
            TAG_ALBUM = 14,
            TAG_COMPOSITION = 15,
            TAG_GENRE = 16,
            TAG_STOCK_MARKET = 17,
            TAG_SPORT = 18
        };
        
        TagType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TAG_ALARM)) {}
        TagType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TAG_ALARM):
                case static_cast<int32_t>(Literal::TAG_TITLE):
                case static_cast<int32_t>(Literal::TAG_ARTIST):
                case static_cast<int32_t>(Literal::TAG_BAND):
                case static_cast<int32_t>(Literal::TAG_NEWS):
                case static_cast<int32_t>(Literal::TAG_NEWS_LOCAL):
                case static_cast<int32_t>(Literal::TAG_NOW):
                case static_cast<int32_t>(Literal::TAG_NEXT):
                case static_cast<int32_t>(Literal::TAG_PHONE_HOTLINE):
                case static_cast<int32_t>(Literal::TAG_EMAIL_HOTLINE):
                case static_cast<int32_t>(Literal::TAG_HOMEPAGE):
                case static_cast<int32_t>(Literal::TAG_TRAFFIC):
                case static_cast<int32_t>(Literal::TAG_WEATHER):
                case static_cast<int32_t>(Literal::TAG_EDITORIAL):
                case static_cast<int32_t>(Literal::TAG_ALBUM):
                case static_cast<int32_t>(Literal::TAG_COMPOSITION):
                case static_cast<int32_t>(Literal::TAG_GENRE):
                case static_cast<int32_t>(Literal::TAG_STOCK_MARKET):
                case static_cast<int32_t>(Literal::TAG_SPORT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TagType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TagType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TagType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TagType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TagType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TagType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ProcessedMethod : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RSP_STATIONSELECTSTATION = 0,
            RSP_STATIONSTOREPRESET = 1,
            RSP_STATIONDELETEPRESET = 2,
            RSP_AUDIOSETSTATIONUPDATEMODE = 3,
            RSP_ANNOUNCEMENTSETCONFIGURATION = 4,
            RSP_ANNOUNCEMENTABORT = 5,
            RSP_AMFMCONTROLSETAFSWITCH = 6,
            RSP_AMFMCONTROLSETREGSWITCH = 7,
            RSP_AMFMCONTROLSETHDMODE = 8,
            RSP_AMFMCONTROLSETHDBALLGAMEMODE = 9,
            RSP_DABCONTROLSETFOLLOWINGSWITCH = 10
        };
        
        ProcessedMethod() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RSP_STATIONSELECTSTATION)) {}
        ProcessedMethod(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RSP_STATIONSELECTSTATION):
                case static_cast<int32_t>(Literal::RSP_STATIONSTOREPRESET):
                case static_cast<int32_t>(Literal::RSP_STATIONDELETEPRESET):
                case static_cast<int32_t>(Literal::RSP_AUDIOSETSTATIONUPDATEMODE):
                case static_cast<int32_t>(Literal::RSP_ANNOUNCEMENTSETCONFIGURATION):
                case static_cast<int32_t>(Literal::RSP_ANNOUNCEMENTABORT):
                case static_cast<int32_t>(Literal::RSP_AMFMCONTROLSETAFSWITCH):
                case static_cast<int32_t>(Literal::RSP_AMFMCONTROLSETREGSWITCH):
                case static_cast<int32_t>(Literal::RSP_AMFMCONTROLSETHDMODE):
                case static_cast<int32_t>(Literal::RSP_AMFMCONTROLSETHDBALLGAMEMODE):
                case static_cast<int32_t>(Literal::RSP_DABCONTROLSETFOLLOWINGSWITCH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ProcessedMethod &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ProcessedMethod &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ProcessedMethod &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ProcessedMethod &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ProcessedMethod &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ProcessedMethod &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Result : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RES_DONE = 0,
            RES_DELAYED = 1,
            RES_ERROR = 2
        };
        
        Result() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RES_DONE)) {}
        Result(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RES_DONE):
                case static_cast<int32_t>(Literal::RES_DELAYED):
                case static_cast<int32_t>(Literal::RES_ERROR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Result &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Result &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Result &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Result &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Result &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Result &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct UserSelection : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            USEL_UNCHANGED = 0,
            USEL_ACTIVATE = 1,
            USEL_DEACTIVATE = 2
        };
        
        UserSelection() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::USEL_UNCHANGED)) {}
        UserSelection(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::USEL_UNCHANGED):
                case static_cast<int32_t>(Literal::USEL_ACTIVATE):
                case static_cast<int32_t>(Literal::USEL_DEACTIVATE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const UserSelection &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const UserSelection &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const UserSelection &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const UserSelection &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const UserSelection &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const UserSelection &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GenreSpecifics : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            GESP_NONE = 0,
            GESP_DIGITAL = 1,
            GESP_DIGITAL_FIRST_SERVICE = 2,
            GESP_AMFM_RDS_TP = 256,
            GESP_AMFM_RDS_TMC = 512
        };
        
        GenreSpecifics() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::GESP_NONE)) {}
        GenreSpecifics(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::GESP_NONE):
                case static_cast<int32_t>(Literal::GESP_DIGITAL):
                case static_cast<int32_t>(Literal::GESP_DIGITAL_FIRST_SERVICE):
                case static_cast<int32_t>(Literal::GESP_AMFM_RDS_TP):
                case static_cast<int32_t>(Literal::GESP_AMFM_RDS_TMC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GenreSpecifics &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GenreSpecifics &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GenreSpecifics &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GenreSpecifics &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GenreSpecifics &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GenreSpecifics &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StationUpdateMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            STUM_NO_INFO_NO_META = 0,
            STUM_INFO_NAME = 1,
            STUM_INFO_LOGO = 2,
            STUM_ALL_INFO_NO_META = 3,
            STUM_META_RADIOTEXT = 4,
            STUM_META_TAGGED = 8,
            STUM_META_IMAGE = 16,
            STUM_META_EPG = 32,
            STUM_ALL_INFO_ALL_META = 63
        };
        
        StationUpdateMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::STUM_NO_INFO_NO_META)) {}
        StationUpdateMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::STUM_NO_INFO_NO_META):
                case static_cast<int32_t>(Literal::STUM_INFO_NAME):
                case static_cast<int32_t>(Literal::STUM_INFO_LOGO):
                case static_cast<int32_t>(Literal::STUM_ALL_INFO_NO_META):
                case static_cast<int32_t>(Literal::STUM_META_RADIOTEXT):
                case static_cast<int32_t>(Literal::STUM_META_TAGGED):
                case static_cast<int32_t>(Literal::STUM_META_IMAGE):
                case static_cast<int32_t>(Literal::STUM_META_EPG):
                case static_cast<int32_t>(Literal::STUM_ALL_INFO_ALL_META):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StationUpdateMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StationUpdateMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StationUpdateMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StationUpdateMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StationUpdateMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StationUpdateMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct AmFmHdBallgameMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            HDBG_ALWAYS_DIGITAL = 0,
            HDBG_ALWAYS_ANALOG = 1
        };
        
        AmFmHdBallgameMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::HDBG_ALWAYS_DIGITAL)) {}
        AmFmHdBallgameMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::HDBG_ALWAYS_DIGITAL):
                case static_cast<int32_t>(Literal::HDBG_ALWAYS_ANALOG):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const AmFmHdBallgameMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const AmFmHdBallgameMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const AmFmHdBallgameMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const AmFmHdBallgameMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const AmFmHdBallgameMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const AmFmHdBallgameMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct StationListSortingMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SLSM_NONE = 0,
            SLSM_QUALITY = 1,
            SLSM_TAG = 2,
            SLSM_NAME = 3
        };
        
        StationListSortingMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SLSM_NONE)) {}
        StationListSortingMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SLSM_NONE):
                case static_cast<int32_t>(Literal::SLSM_QUALITY):
                case static_cast<int32_t>(Literal::SLSM_TAG):
                case static_cast<int32_t>(Literal::SLSM_NAME):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const StationListSortingMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const StationListSortingMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const StationListSortingMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const StationListSortingMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const StationListSortingMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const StationListSortingMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Vector of UInt32
     */
    typedef std::vector<uint32_t> UInt32s;
    /**
     * description: Current tuner source
     */
    struct CurrentSource : CommonAPI::Struct<uint32_t, uint32_t> {
    	
    	CurrentSource() {
    	}
    	CurrentSource(const uint32_t &_source, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The tuner source as a bit compination of enumeration "Source". It's project
    	 *   dependend whehter a combination is valid or not.       Examples:       1. Your
    	 *   project separates FM, SW, MW, LW - each waveband is displayed in a separated
    	 *   widget with separated audio settings. Also DAB is realized as a tuner
    	 *   sub-application (waveband like):          Valid combinations are: FM ->
    	 *   SRC_FM, SW -> SRC_SW, MW -> SRC_MW, LW -> SRC_LW, DAB -> SRC_DAB       2. Your
    	 *   project separates FM from AM but AM does not distinguish between SW, MW, LW.
    	 *   DRM is realized as a tuner sub-application (waveband like):          Valid
    	 *   combinations are: FM -> SRC_FM, SW -> SRC_SW | SRC_MW | SRC_LW, DRM -> SRC_DRM
    	 *              3. Your project separates FM from AM but AM does not distinguish
    	 *   between SW, MW, LW. HD is part of FM and DRM is part of AM:          Valid
    	 *   combinations are: FM -> SRC_FM | SRC_HD, SW -> SRC_SW | SRC_MW | SRC_LW |
    	 *   SRC_DRM          4. FM and DAB are shown as one combined list, no AM:         
    	 *   Valid combinations are: FM + DAB -> SRC_FM | SRC_DAB       Note: Usually
    	 *   you'll have an on-to-one correspondence between HMI and audio source. That
    	 *   means if you have dedicated HMI views for FM, SW, MW, LW and DAB you'll also
    	 *   have dedicated logical audio sources with dedicated audio settings.           
    	 *                     If you have a combined FM + DAB view you'll also have a
    	 *   common audio source etc.. Because of that and to ensure correct
    	 *   synchronization with the audio management there is no explicit "selectSource"
    	 *   method defined within this interface.       The tuner will follow the
    	 *   requests/notifications it gets from the audio management.
    	 */
    	inline const uint32_t &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CurrentSource& _other) const {
                return (getSource() == _other.getSource() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentSource &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station genre
     */
    struct StationGenre : CommonAPI::Struct<uint32_t, uint32_t> {
    	
    	StationGenre() {
    	}
    	StationGenre(const uint32_t &_pty, const uint32_t &_specifics)
    	{
    		std::get<0>(values_) = _pty;
    		std::get<1>(values_) = _specifics;
    	}
    	/**
    	 * description: PTY code, usually a number from 0..31 except if used with SEEK_PTYMASK_ seek
    	 *   modes             CAUTION if use together with SEEK_PTYMASK_ seek modes you
    	 *   have not to pass the simple pty code but an ORed bitmask of 2 POW pty-1 or 1
    	 *   LSH pty-1
    	 */
    	inline const uint32_t &getPty() const { return std::get<0>(values_); }
    	inline void setPty(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Bitmaks of GenreSpecifics
    	 */
    	inline const uint32_t &getSpecifics() const { return std::get<1>(values_); }
    	inline void setSpecifics(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const StationGenre& _other) const {
                return (getPty() == _other.getPty() && getSpecifics() == _other.getSpecifics());
        }
    	inline bool operator!=(const StationGenre &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: All necessary information for station selection or identification:       Send
     *   from tuner device (attributes): All parameters are set to reflect current
     *   state.       Send to tuner device:       Only one of the four parameters is
     *   needed, the parameters are evaluated like the following:       a) tag != 0:
     *   tag is used for station selection (i.e. station selection from list)       b)
     *   tag == 0, frequency != 0: frequency is used (i.e. direct frequency input)     
     *    c) tag == 0, frequency == 0, preset != 0: preset number is used (i.e. preset
     *   recall)       d) tag == 0, frequency == 0, preset == 0: Evaluate seek mode
     */
    struct StationSelector : CommonAPI::Struct<uint64_t, uint32_t, uint32_t, StationSeekMode, StationGenre> {
    	
    	StationSelector() {
    	}
    	StationSelector(const uint64_t &_tag, const uint32_t &_frequency, const uint32_t &_preset, const StationSeekMode &_seekMode, const StationGenre &_genre)
    	{
    		std::get<0>(values_) = _tag;
    		std::get<1>(values_) = _frequency;
    		std::get<2>(values_) = _preset;
    		std::get<3>(values_) = _seekMode;
    		std::get<4>(values_) = _genre;
    	}
    	/**
    	 * description: Unique station idenfier
    	 */
    	inline const uint64_t &getTag() const { return std::get<0>(values_); }
    	inline void setTag(const uint64_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Frequency [KHz]
    	 */
    	inline const uint32_t &getFrequency() const { return std::get<1>(values_); }
    	inline void setFrequency(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Preset number (0: invalid)
    	 */
    	inline const uint32_t &getPreset() const { return std::get<2>(values_); }
    	inline void setPreset(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Seek mode
    	 */
    	inline const StationSeekMode &getSeekMode() const { return std::get<3>(values_); }
    	inline void setSeekMode(const StationSeekMode &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Station genre
    	 */
    	inline const StationGenre &getGenre() const { return std::get<4>(values_); }
    	inline void setGenre(const StationGenre &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const StationSelector& _other) const {
                return (getTag() == _other.getTag() && getFrequency() == _other.getFrequency() && getPreset() == _other.getPreset() && getSeekMode() == _other.getSeekMode() && getGenre() == _other.getGenre());
        }
    	inline bool operator!=(const StationSelector &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: FM RDS Radiotext plus / DAB Dynamic Label plus / HD metadata element
     */
    struct TaggedElement : CommonAPI::Struct<TagType, std::string> {
    	
    	TaggedElement() {
    	}
    	TaggedElement(const TagType &_type, const std::string &_text)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _text;
    	}
    	/**
    	 * description: Element type
    	 */
    	inline const TagType &getType() const { return std::get<0>(values_); }
    	inline void setType(const TagType &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Text that fits to "type"
    	 */
    	inline const std::string &getText() const { return std::get<1>(values_); }
    	inline void setText(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const TaggedElement& _other) const {
                return (getType() == _other.getType() && getText() == _other.getText());
        }
    	inline bool operator!=(const TaggedElement &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List of TaggedElement
     */
    typedef std::vector<OrinocoTunerTypes::TaggedElement> TaggedElements;
    /**
     * description: Time period
     */
    struct Period : CommonAPI::Struct<uint32_t, uint32_t> {
    	
    	Period() {
    	}
    	Period(const uint32_t &_startTime, const uint32_t &_endTime)
    	{
    		std::get<0>(values_) = _startTime;
    		std::get<1>(values_) = _endTime;
    	}
    	/**
    	 * description: Start time (UTC, unix-epoch based)
    	 */
    	inline const uint32_t &getStartTime() const { return std::get<0>(values_); }
    	inline void setStartTime(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: End time (UTC, unix-epoch based)
    	 */
    	inline const uint32_t &getEndTime() const { return std::get<1>(values_); }
    	inline void setEndTime(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Period& _other) const {
                return (getStartTime() == _other.getStartTime() && getEndTime() == _other.getEndTime());
        }
    	inline bool operator!=(const Period &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: EPG (Electronic Program Guide) event
     */
    struct EpgEvent : CommonAPI::Struct<Period, std::string, std::string, std::string> {
    	
    	EpgEvent() {
    	}
    	EpgEvent(const Period &_period, const std::string &_nameShort, const std::string &_nameLong, const std::string &_description)
    	{
    		std::get<0>(values_) = _period;
    		std::get<1>(values_) = _nameShort;
    		std::get<2>(values_) = _nameLong;
    		std::get<3>(values_) = _description;
    	}
    	/**
    	 * description: Start and end time of the event
    	 */
    	inline const Period &getPeriod() const { return std::get<0>(values_); }
    	inline void setPeriod(const Period &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Event short name
    	 */
    	inline const std::string &getNameShort() const { return std::get<1>(values_); }
    	inline void setNameShort(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Event long name
    	 */
    	inline const std::string &getNameLong() const { return std::get<2>(values_); }
    	inline void setNameLong(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Event description
    	 */
    	inline const std::string &getDescription() const { return std::get<3>(values_); }
    	inline void setDescription(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const EpgEvent& _other) const {
                return (getPeriod() == _other.getPeriod() && getNameShort() == _other.getNameShort() && getNameLong() == _other.getNameLong() && getDescription() == _other.getDescription());
        }
    	inline bool operator!=(const EpgEvent &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List of TaggedElement
     */
    typedef std::vector<OrinocoTunerTypes::EpgEvent> EpgEvents;
    /**
     * description: Station metadata
     */
    struct StationMetadata : CommonAPI::Struct<std::string, TaggedElements, std::string, EpgEvents> {
    	
    	StationMetadata() {
    	}
    	StationMetadata(const std::string &_radiotext, const TaggedElements &_tagged, const std::string &_imagePath, const EpgEvents &_epgNowNext)
    	{
    		std::get<0>(values_) = _radiotext;
    		std::get<1>(values_) = _tagged;
    		std::get<2>(values_) = _imagePath;
    		std::get<3>(values_) = _epgNowNext;
    	}
    	/**
    	 * description: FM RDS Radiotext / DAB Dynamic Label
    	 */
    	inline const std::string &getRadiotext() const { return std::get<0>(values_); }
    	inline void setRadiotext(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Active FM RDS Radiotext+ / DAB Dynamic Label+ / HD metadata elements
    	 */
    	inline const TaggedElements &getTagged() const { return std::get<1>(values_); }
    	inline void setTagged(const TaggedElements &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: File system path to slideshow or HD album cover image
    	 */
    	inline const std::string &getImagePath() const { return std::get<2>(values_); }
    	inline void setImagePath(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Optional EPG now/new event information (time-orderd vector, vector is empty if
    	 *   no EPG is available)
    	 */
    	inline const EpgEvents &getEpgNowNext() const { return std::get<3>(values_); }
    	inline void setEpgNowNext(const EpgEvents &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const StationMetadata& _other) const {
                return (getRadiotext() == _other.getRadiotext() && getTagged() == _other.getTagged() && getImagePath() == _other.getImagePath() && getEpgNowNext() == _other.getEpgNowNext());
        }
    	inline bool operator!=(const StationMetadata &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Group information
     */
    struct GroupInfo : CommonAPI::Struct<uint32_t, std::string, std::string, uint32_t, std::string, std::string> {
    	
    	GroupInfo() {
    	}
    	GroupInfo(const uint32_t &_superId, const std::string &_superName, const std::string &_superNameShort, const uint32_t &_subId, const std::string &_subName, const std::string &_subNameShort)
    	{
    		std::get<0>(values_) = _superId;
    		std::get<1>(values_) = _superName;
    		std::get<2>(values_) = _superNameShort;
    		std::get<3>(values_) = _subId;
    		std::get<4>(values_) = _subName;
    		std::get<5>(values_) = _subNameShort;
    	}
    	/**
    	 * description: Super group identifier
    	 */
    	inline const uint32_t &getSuperId() const { return std::get<0>(values_); }
    	inline void setSuperId(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Super group long name (e.g. DAB ensemble name)
    	 */
    	inline const std::string &getSuperName() const { return std::get<1>(values_); }
    	inline void setSuperName(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Super group short name (e.g. DAB ensemble name)
    	 */
    	inline const std::string &getSuperNameShort() const { return std::get<2>(values_); }
    	inline void setSuperNameShort(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Subelement identifier E.g. HD service index: 0/1: No HD/MPS, 2..8: SPS
    	 */
    	inline const uint32_t &getSubId() const { return std::get<3>(values_); }
    	inline void setSubId(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Subelement long name (e.g. DAB subcomponent label)
    	 */
    	inline const std::string &getSubName() const { return std::get<4>(values_); }
    	inline void setSubName(const std::string &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Subelement short name (e.g. DAB subcomponent label)
    	 */
    	inline const std::string &getSubNameShort() const { return std::get<5>(values_); }
    	inline void setSubNameShort(const std::string &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const GroupInfo& _other) const {
                return (getSuperId() == _other.getSuperId() && getSuperName() == _other.getSuperName() && getSuperNameShort() == _other.getSuperNameShort() && getSubId() == _other.getSubId() && getSubName() == _other.getSubName() && getSubNameShort() == _other.getSubNameShort());
        }
    	inline bool operator!=(const GroupInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station names
     */
    struct StationInfo : CommonAPI::Struct<std::string, std::string, GroupInfo, std::string> {
    	
    	StationInfo() {
    	}
    	StationInfo(const std::string &_name, const std::string &_nameShort, const GroupInfo &_group, const std::string &_logoPath)
    	{
    		std::get<0>(values_) = _name;
    		std::get<1>(values_) = _nameShort;
    		std::get<2>(values_) = _group;
    		std::get<3>(values_) = _logoPath;
    	}
    	/**
    	 * description: RDS PS code / service long name
    	 */
    	inline const std::string &getName() const { return std::get<0>(values_); }
    	inline void setName(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: RDS PS code / service short name
    	 */
    	inline const std::string &getNameShort() const { return std::get<1>(values_); }
    	inline void setNameShort(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Grouping information
    	 */
    	inline const GroupInfo &getGroup() const { return std::get<2>(values_); }
    	inline void setGroup(const GroupInfo &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: File system path station logo image
    	 */
    	inline const std::string &getLogoPath() const { return std::get<3>(values_); }
    	inline void setLogoPath(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const StationInfo& _other) const {
                return (getName() == _other.getName() && getNameShort() == _other.getNameShort() && getGroup() == _other.getGroup() && getLogoPath() == _other.getLogoPath());
        }
    	inline bool operator!=(const StationInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Addional station flags
     */
    struct StationFlags : CommonAPI::Struct<bool, bool, bool> {
    	
    	StationFlags() {
    		std::get<0>(values_) = false;
    		std::get<1>(values_) = false;
    		std::get<2>(values_) = false;
    	}
    	StationFlags(const bool &_isDigital, const bool &_isMuted, const bool &_isLive)
    	{
    		std::get<0>(values_) = _isDigital;
    		std::get<1>(values_) = _isMuted;
    		std::get<2>(values_) = _isLive;
    	}
    	/**
    	 * description: True -> Digital audio signal (check "source" to determine if it is DAB/DRM/HD) 
    	 *        False -> Analog audio signal, i.e. in case of DAB: Linking to FM; in case
    	 *   of HD-MPS: analog FM station
    	 */
    	inline const bool &getIsDigital() const { return std::get<0>(values_); }
    	inline void setIsDigital(const bool _value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: [isDigital==true] Station is muted (only in case of digital audio signal)
    	 */
    	inline const bool &getIsMuted() const { return std::get<1>(values_); }
    	inline void setIsMuted(const bool _value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: True -> E.g. HD ballgame mode active       False -> Audio might be delayed
    	 *   (e.g. no HD ballgame mode active)
    	 */
    	inline const bool &getIsLive() const { return std::get<2>(values_); }
    	inline void setIsLive(const bool _value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const StationFlags& _other) const {
                return (getIsDigital() == _other.getIsDigital() && getIsMuted() == _other.getIsMuted() && getIsLive() == _other.getIsLive());
        }
    	inline bool operator!=(const StationFlags &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station quality data
     */
    struct StationQuality : CommonAPI::Struct<int32_t, int32_t> {
    	
    	StationQuality() {
    	}
    	StationQuality(const int32_t &_fieldStrength, const int32_t &_quality)
    	{
    		std::get<0>(values_) = _fieldStrength;
    		std::get<1>(values_) = _quality;
    	}
    	/**
    	 * description: Field strenght
    	 */
    	inline const int32_t &getFieldStrength() const { return std::get<0>(values_); }
    	inline void setFieldStrength(const int32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Standard specific quality indicator
    	 */
    	inline const int32_t &getQuality() const { return std::get<1>(values_); }
    	inline void setQuality(const int32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const StationQuality& _other) const {
                return (getFieldStrength() == _other.getFieldStrength() && getQuality() == _other.getQuality());
        }
    	inline bool operator!=(const StationQuality &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Current station data
     */
    struct CurrentStation : CommonAPI::Struct<uint32_t, StationSelector, StationInfo, StationMetadata, StationFlags, StationQuality, uint32_t> {
    	
    	CurrentStation() {
    	}
    	CurrentStation(const uint32_t &_source, const StationSelector &_sel, const StationInfo &_info, const StationMetadata &_meta, const StationFlags &_flags, const StationQuality &_quality, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _sel;
    		std::get<2>(values_) = _info;
    		std::get<3>(values_) = _meta;
    		std::get<4>(values_) = _flags;
    		std::get<5>(values_) = _quality;
    		std::get<6>(values_) = _handle;
    	}
    	/**
    	 * description: The sending source of this current station update as a bit compination of
    	 *   enumeration "Source":          In contrast to "CurrentSource.source" and
    	 *   "StationList.source" the valid bit combinations are not depending on project
    	 *   settings but reflect the actual way of reception.          Valid comibations
    	 *   are: SRC_FM, SRC_SW, SRC_MW, SRC_LW, SRC_DAB, SRC_FM | SRC_HD, SRC_MW |
    	 *   SRC_HD, SRC_MW |SRC_DRM, SRC_SW | SRC_DRM.
    	 */
    	inline const uint32_t &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station identification, seek state
    	 */
    	inline const StationSelector &getSel() const { return std::get<1>(values_); }
    	inline void setSel(const StationSelector &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Station info
    	 */
    	inline const StationInfo &getInfo() const { return std::get<2>(values_); }
    	inline void setInfo(const StationInfo &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Station metadata
    	 */
    	inline const StationMetadata &getMeta() const { return std::get<3>(values_); }
    	inline void setMeta(const StationMetadata &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: Additional station flags
    	 */
    	inline const StationFlags &getFlags() const { return std::get<4>(values_); }
    	inline void setFlags(const StationFlags &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Station quality information
    	 */
    	inline const StationQuality &getQuality() const { return std::get<5>(values_); }
    	inline void setQuality(const StationQuality &_value) { std::get<5>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<6>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<6>(values_) = _value; }
    	inline bool operator==(const CurrentStation& _other) const {
                return (getSource() == _other.getSource() && getSel() == _other.getSel() && getInfo() == _other.getInfo() && getMeta() == _other.getMeta() && getFlags() == _other.getFlags() && getQuality() == _other.getQuality() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentStation &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: The station update mode for the current active tuner audio source
     */
    struct AudioStationUpdateMode : CommonAPI::Struct<StationUpdateMode, uint32_t> {
    	
    	AudioStationUpdateMode() {
    	}
    	AudioStationUpdateMode(const StationUpdateMode &_mode, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _mode;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The the station update mode for the current active tuner audio source
    	 */
    	inline const StationUpdateMode &getMode() const { return std::get<0>(values_); }
    	inline void setMode(const StationUpdateMode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const AudioStationUpdateMode& _other) const {
                return (getMode() == _other.getMode() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const AudioStationUpdateMode &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List station (reduced data compared to "CurrentStation")
     */
    struct ListStation : CommonAPI::Struct<uint32_t, StationSelector, StationInfo> {
    	
    	ListStation() {
    	}
    	ListStation(const uint32_t &_source, const StationSelector &_sel, const StationInfo &_info)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _sel;
    		std::get<2>(values_) = _info;
    	}
    	/**
    	 * description: The sending source of this station element as a bit compination of enumeration
    	 *   "Source":          In contrast to "CurrentSource.source" and
    	 *   "StationList.source" the valid bit combinations are not depending on project
    	 *   settings but reflect the actual way of reception.          Valid comibations
    	 *   are: SRC_FM, SRC_SW, SRC_MW, SRC_LW, SRC_DAB, SRC_FM | SRC_HD, SRC_MW |
    	 *   SRC_HD, SRC_MW |SRC_DRM, SRC_SW | SRC_DRM.
    	 */
    	inline const uint32_t &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station identification
    	 */
    	inline const StationSelector &getSel() const { return std::get<1>(values_); }
    	inline void setSel(const StationSelector &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Station info
    	 */
    	inline const StationInfo &getInfo() const { return std::get<2>(values_); }
    	inline void setInfo(const StationInfo &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const ListStation& _other) const {
                return (getSource() == _other.getSource() && getSel() == _other.getSel() && getInfo() == _other.getInfo());
        }
    	inline bool operator!=(const ListStation &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: List of ListStation
     */
    typedef std::vector<OrinocoTunerTypes::ListStation> ListStations;
    /**
     * description: The currently selected station of the current active tuner audio source
     */
    struct AudioCurrentStation : CommonAPI::Struct<bool, CurrentStation, ListStations> {
    	
    	AudioCurrentStation() {
    		std::get<0>(values_) = false;
    	}
    	AudioCurrentStation(const bool &_sourceChanging, const CurrentStation &_station, const ListStations &_subs)
    	{
    		std::get<0>(values_) = _sourceChanging;
    		std::get<1>(values_) = _station;
    		std::get<2>(values_) = _subs;
    	}
    	/**
    	 * description: Tuner audio source is currently changing and hence the audioXYZ attributes
    	 *   might be inconsistent
    	 */
    	inline const bool &getSourceChanging() const { return std::get<0>(values_); }
    	inline void setSourceChanging(const bool _value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Information about the active station
    	 */
    	inline const CurrentStation &getStation() const { return std::get<1>(values_); }
    	inline void setStation(const CurrentStation &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: List of sub stations (e.g DAB subcomponents, HD SPS)           NOTE: The use of
    	 *   this parameter depends on configuration and is only filled in "tree-view"
    	 *   mode: "stations" shows only the main station; sub-services are only listed in
    	 *   "subs"           Otherwise this list is empty and all information (stations as
    	 *   well as sub-services) is available via "stations".
    	 */
    	inline const ListStations &getSubs() const { return std::get<2>(values_); }
    	inline void setSubs(const ListStations &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const AudioCurrentStation& _other) const {
                return (getSourceChanging() == _other.getSourceChanging() && getStation() == _other.getStation() && getSubs() == _other.getSubs());
        }
    	inline bool operator!=(const AudioCurrentStation &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Station list
     */
    struct StationList : CommonAPI::Struct<uint32_t, StationListType, ListStations, uint32_t> {
    	
    	StationList() {
    	}
    	StationList(const uint32_t &_source, const StationListType &_listType, const ListStations &_stations, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _source;
    		std::get<1>(values_) = _listType;
    		std::get<2>(values_) = _stations;
    		std::get<3>(values_) = _handle;
    	}
    	/**
    	 * description: The sending source this station list update (depends on project configuration):
    	 *            In case project distinguishs different AM bands source will be
    	 *   =SRC_LW or =SRC_MW or =SRC_SW for AM otherwise =SRC_LW|SRC_MW|SRC_SW
    	 *   (distributed in one list).           If project supports a unified DAB/FM view
    	 *   the source will be =SRC_DAB|SRC_FM for combined DAB/FM otherwise separate
    	 *   source updates for =SRC_DAB and =SRC_FM will exist.          But note that
    	 *   this "source" attribute is only about the list source type, even in case of
    	 *   combined list updates every station contains the information of its actual
    	 *   source stations[i].source.          If HD or DRM station are part of the
    	 *   standard list updates SRC_HD and SRC_DRM is "OR"ed to the source bitmask. It's
    	 *   also possible to have SRC_DRM distributed as separated list for instance.
    	 */
    	inline const uint32_t &getSource() const { return std::get<0>(values_); }
    	inline void setSource(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Station list type
    	 */
    	inline const StationListType &getListType() const { return std::get<1>(values_); }
    	inline void setListType(const StationListType &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: List of stations
    	 */
    	inline const ListStations &getStations() const { return std::get<2>(values_); }
    	inline void setStations(const ListStations &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<3>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const StationList& _other) const {
                return (getSource() == _other.getSource() && getListType() == _other.getListType() && getStations() == _other.getStations() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const StationList &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: The station list of the current active tuner audio source
     */
    struct AudioStationList : CommonAPI::Struct<StationList, ListStations> {
    	
    	AudioStationList() {
    	}
    	AudioStationList(const StationList &_stations, const ListStations &_supers)
    	{
    		std::get<0>(values_) = _stations;
    		std::get<1>(values_) = _supers;
    	}
    	/**
    	 * description: List of stations            NOTE: See also description of parameter "supers"
    	 */
    	inline const StationList &getStations() const { return std::get<0>(values_); }
    	inline void setStations(const StationList &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: List of super stations (e.g DAB ensembles)           NOTE: The use of this
    	 *   parameter depends on configuration and is only filled in "tree-view" mode:
    	 *   "stations" shows only the stations of the currently selected "super".         
    	 *    Otherwise this list is empty and all information (super information is part
    	 *   of normal stations and is not listed separately) is available via "stations".
    	 */
    	inline const ListStations &getSupers() const { return std::get<1>(values_); }
    	inline void setSupers(const ListStations &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const AudioStationList& _other) const {
                return (getStations() == _other.getStations() && getSupers() == _other.getSupers());
        }
    	inline bool operator!=(const AudioStationList &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Announcement configuration, defines whether an announcement type has to be
     *   monitored or not.
     */
    struct AnnouncementConfiguration : CommonAPI::Struct<UserSelection, UserSelection, UserSelection> {
    	
    	AnnouncementConfiguration() {
    	}
    	AnnouncementConfiguration(const UserSelection &_trafficEnable, const UserSelection &_alarmEnable, const UserSelection &_newsEnable)
    	{
    		std::get<0>(values_) = _trafficEnable;
    		std::get<1>(values_) = _alarmEnable;
    		std::get<2>(values_) = _newsEnable;
    	}
    	/**
    	 * description: Enable/disable announcement type traffic for DAB and FM
    	 */
    	inline const UserSelection &getTrafficEnable() const { return std::get<0>(values_); }
    	inline void setTrafficEnable(const UserSelection &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Enable/disable announcement type alarm for DAB and FM
    	 */
    	inline const UserSelection &getAlarmEnable() const { return std::get<1>(values_); }
    	inline void setAlarmEnable(const UserSelection &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Enable/disable announcement type news for FM
    	 */
    	inline const UserSelection &getNewsEnable() const { return std::get<2>(values_); }
    	inline void setNewsEnable(const UserSelection &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const AnnouncementConfiguration& _other) const {
                return (getTrafficEnable() == _other.getTrafficEnable() && getAlarmEnable() == _other.getAlarmEnable() && getNewsEnable() == _other.getNewsEnable());
        }
    	inline bool operator!=(const AnnouncementConfiguration &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Announcement states
     */
    struct AnnouncementStates : CommonAPI::Struct<AnnouncementState, AnnouncementState, AnnouncementState> {
    	
    	AnnouncementStates() {
    	}
    	AnnouncementStates(const AnnouncementState &_traffic, const AnnouncementState &_alarm, const AnnouncementState &_news)
    	{
    		std::get<0>(values_) = _traffic;
    		std::get<1>(values_) = _alarm;
    		std::get<2>(values_) = _news;
    	}
    	/**
    	 * description: Current static of announcement type traffic
    	 */
    	inline const AnnouncementState &getTraffic() const { return std::get<0>(values_); }
    	inline void setTraffic(const AnnouncementState &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Current static of announcement type alarm
    	 */
    	inline const AnnouncementState &getAlarm() const { return std::get<1>(values_); }
    	inline void setAlarm(const AnnouncementState &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Current static of announcement type news
    	 */
    	inline const AnnouncementState &getNews() const { return std::get<2>(values_); }
    	inline void setNews(const AnnouncementState &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const AnnouncementStates& _other) const {
                return (getTraffic() == _other.getTraffic() && getAlarm() == _other.getAlarm() && getNews() == _other.getNews());
        }
    	inline bool operator!=(const AnnouncementStates &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Additional data for an active announcemnt
     */
    struct AnnouncementActiveData : CommonAPI::Struct<bool, Source, StationSelector, StationInfo> {
    	
    	AnnouncementActiveData() {
    		std::get<0>(values_) = false;
    	}
    	AnnouncementActiveData(const bool &_active, const Source &_source, const StationSelector &_sel, const StationInfo &_info)
    	{
    		std::get<0>(values_) = _active;
    		std::get<1>(values_) = _source;
    		std::get<2>(values_) = _sel;
    		std::get<3>(values_) = _info;
    	}
    	/**
    	 * description: Indicates whether an announcemnt is active or not. The following parameters are
    	 *   only valid if active==true.
    	 */
    	inline const bool &getActive() const { return std::get<0>(values_); }
    	inline void setActive(const bool _value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: [active==true] Announcemnet providing source: FM or DAB
    	 */
    	inline const Source &getSource() const { return std::get<1>(values_); }
    	inline void setSource(const Source &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: [active==true] Station identification of announcemnt providing station.
    	 */
    	inline const StationSelector &getSel() const { return std::get<2>(values_); }
    	inline void setSel(const StationSelector &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: [active==true] Station names of announcement providing station.
    	 */
    	inline const StationInfo &getInfo() const { return std::get<3>(values_); }
    	inline void setInfo(const StationInfo &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const AnnouncementActiveData& _other) const {
                return (getActive() == _other.getActive() && getSource() == _other.getSource() && getSel() == _other.getSel() && getInfo() == _other.getInfo());
        }
    	inline bool operator!=(const AnnouncementActiveData &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Announcement status information
     */
    struct AnnouncementStatus : CommonAPI::Struct<AnnouncementStates, AnnouncementActiveData, uint32_t> {
    	
    	AnnouncementStatus() {
    	}
    	AnnouncementStatus(const AnnouncementStates &_states, const AnnouncementActiveData &_activeData, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _states;
    		std::get<1>(values_) = _activeData;
    		std::get<2>(values_) = _handle;
    	}
    	/**
    	 * description: Current state of announcement configuration and monitoring. Note that only one
    	 *   type can be ANN_ON_ACTIVE at the same time. A currently active announcemnt
    	 *   this is also indicated by activeData.active
    	 */
    	inline const AnnouncementStates &getStates() const { return std::get<0>(values_); }
    	inline void setStates(const AnnouncementStates &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Active data indicates if an announcemnt is currently active and who is
    	 *   providing this announcemnt. The announcemnt type of an active announcement is
    	 *   given via "states".
    	 */
    	inline const AnnouncementActiveData &getActiveData() const { return std::get<1>(values_); }
    	inline void setActiveData(const AnnouncementActiveData &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<2>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const AnnouncementStatus& _other) const {
                return (getStates() == _other.getStates() && getActiveData() == _other.getActiveData() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const AnnouncementStatus &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: AM/FM waveband grid information
     */
    struct AmFmWavebandGrid : CommonAPI::Struct<uint32_t, uint32_t, uint32_t, uint32_t> {
    	
    	AmFmWavebandGrid() {
    	}
    	AmFmWavebandGrid(const uint32_t &_lowerLimit, const uint32_t &_upperLimit, const uint32_t &_stepWidth, const uint32_t &_smallStep)
    	{
    		std::get<0>(values_) = _lowerLimit;
    		std::get<1>(values_) = _upperLimit;
    		std::get<2>(values_) = _stepWidth;
    		std::get<3>(values_) = _smallStep;
    	}
    	/**
    	 * description: Lower limit of band [KHz]
    	 */
    	inline const uint32_t &getLowerLimit() const { return std::get<0>(values_); }
    	inline void setLowerLimit(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Upper limit of band [KHz]
    	 */
    	inline const uint32_t &getUpperLimit() const { return std::get<1>(values_); }
    	inline void setUpperLimit(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Step size used for background lists [KHz]
    	 */
    	inline const uint32_t &getStepWidth() const { return std::get<2>(values_); }
    	inline void setStepWidth(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Smaller step size than "stepWidth" that can be used for manual tuning [KHz]
    	 */
    	inline const uint32_t &getSmallStep() const { return std::get<3>(values_); }
    	inline void setSmallStep(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const AmFmWavebandGrid& _other) const {
                return (getLowerLimit() == _other.getLowerLimit() && getUpperLimit() == _other.getUpperLimit() && getStepWidth() == _other.getStepWidth() && getSmallStep() == _other.getSmallStep());
        }
    	inline bool operator!=(const AmFmWavebandGrid &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Wavband information for all bands
     */
    struct AmFmWavebandGrids : CommonAPI::Struct<AmFmWavebandGrid, AmFmWavebandGrid, AmFmWavebandGrid, AmFmWavebandGrid> {
    	
    	AmFmWavebandGrids() {
    	}
    	AmFmWavebandGrids(const AmFmWavebandGrid &_fm, const AmFmWavebandGrid &_sw, const AmFmWavebandGrid &_mw, const AmFmWavebandGrid &_lw)
    	{
    		std::get<0>(values_) = _fm;
    		std::get<1>(values_) = _sw;
    		std::get<2>(values_) = _mw;
    		std::get<3>(values_) = _lw;
    	}
    	/**
    	 * description: FM grid
    	 */
    	inline const AmFmWavebandGrid &getFm() const { return std::get<0>(values_); }
    	inline void setFm(const AmFmWavebandGrid &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: SW grid
    	 */
    	inline const AmFmWavebandGrid &getSw() const { return std::get<1>(values_); }
    	inline void setSw(const AmFmWavebandGrid &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: MW grid
    	 */
    	inline const AmFmWavebandGrid &getMw() const { return std::get<2>(values_); }
    	inline void setMw(const AmFmWavebandGrid &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: LW grid
    	 */
    	inline const AmFmWavebandGrid &getLw() const { return std::get<3>(values_); }
    	inline void setLw(const AmFmWavebandGrid &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const AmFmWavebandGrids& _other) const {
                return (getFm() == _other.getFm() && getSw() == _other.getSw() && getMw() == _other.getMw() && getLw() == _other.getLw());
        }
    	inline bool operator!=(const AmFmWavebandGrids &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: AM/FM region dependent configuration
     */
    struct AmFmRegionInfo : CommonAPI::Struct<AmFmRegionCode, AmFmWavebandGrids, uint32_t> {
    	
    	AmFmRegionInfo() {
    	}
    	AmFmRegionInfo(const AmFmRegionCode &_code, const AmFmWavebandGrids &_grid, const uint32_t &_flags)
    	{
    		std::get<0>(values_) = _code;
    		std::get<1>(values_) = _grid;
    		std::get<2>(values_) = _flags;
    	}
    	/**
    	 * description: The region code
    	 */
    	inline const AmFmRegionCode &getCode() const { return std::get<0>(values_); }
    	inline void setCode(const AmFmRegionCode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The waveband grid information for all bands
    	 */
    	inline const AmFmWavebandGrids &getGrid() const { return std::get<1>(values_); }
    	inline void setGrid(const AmFmWavebandGrids &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Bit mask of AmFmCodingFlag
    	 */
    	inline const uint32_t &getFlags() const { return std::get<2>(values_); }
    	inline void setFlags(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const AmFmRegionInfo& _other) const {
                return (getCode() == _other.getCode() && getGrid() == _other.getGrid() && getFlags() == _other.getFlags());
        }
    	inline bool operator!=(const AmFmRegionInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: DAB region dependent configuration
     */
    struct DabRegionInfo : CommonAPI::Struct<DabRegionCode, uint32_t> {
    	
    	DabRegionInfo() {
    	}
    	DabRegionInfo(const DabRegionCode &_code, const uint32_t &_flags)
    	{
    		std::get<0>(values_) = _code;
    		std::get<1>(values_) = _flags;
    	}
    	/**
    	 * description: The region code
    	 */
    	inline const DabRegionCode &getCode() const { return std::get<0>(values_); }
    	inline void setCode(const DabRegionCode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: Bit mask of DabCodingFlag
    	 */
    	inline const uint32_t &getFlags() const { return std::get<1>(values_); }
    	inline void setFlags(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const DabRegionInfo& _other) const {
                return (getCode() == _other.getCode() && getFlags() == _other.getFlags());
        }
    	inline bool operator!=(const DabRegionInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Current AM/FM HD mode
     */
    struct CurrentAmFmHdMode : CommonAPI::Struct<AmFmHdMode, uint32_t> {
    	
    	CurrentAmFmHdMode() {
    	}
    	CurrentAmFmHdMode(const AmFmHdMode &_mode, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _mode;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The current AM/FM HD mode
    	 */
    	inline const AmFmHdMode &getMode() const { return std::get<0>(values_); }
    	inline void setMode(const AmFmHdMode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CurrentAmFmHdMode& _other) const {
                return (getMode() == _other.getMode() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentAmFmHdMode &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Current AM/FM HD ballgame mode
     */
    struct CurrentAmFmHdBallgameMode : CommonAPI::Struct<AmFmHdBallgameMode, uint32_t> {
    	
    	CurrentAmFmHdBallgameMode() {
    	}
    	CurrentAmFmHdBallgameMode(const AmFmHdBallgameMode &_mode, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _mode;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The current AM/FM HD ballgame mode
    	 */
    	inline const AmFmHdBallgameMode &getMode() const { return std::get<0>(values_); }
    	inline void setMode(const AmFmHdBallgameMode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CurrentAmFmHdBallgameMode& _other) const {
                return (getMode() == _other.getMode() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentAmFmHdBallgameMode &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Current state of a switch
     */
    struct CurrentSwitchState : CommonAPI::Struct<bool, uint32_t> {
    	
    	CurrentSwitchState() {
    		std::get<0>(values_) = false;
    	}
    	CurrentSwitchState(const bool &_enabled, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _enabled;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The current switch state
    	 */
    	inline const bool &getEnabled() const { return std::get<0>(values_); }
    	inline void setEnabled(const bool _value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CurrentSwitchState& _other) const {
                return (getEnabled() == _other.getEnabled() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentSwitchState &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Current list sorting mode
     */
    struct CurrentStationListSortingMode : CommonAPI::Struct<StationListSortingMode, uint32_t> {
    	
    	CurrentStationListSortingMode() {
    	}
    	CurrentStationListSortingMode(const StationListSortingMode &_mode, const uint32_t &_handle)
    	{
    		std::get<0>(values_) = _mode;
    		std::get<1>(values_) = _handle;
    	}
    	/**
    	 * description: The current list sorting mode
    	 */
    	inline const StationListSortingMode &getMode() const { return std::get<0>(values_); }
    	inline void setMode(const StationListSortingMode &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: A handle to identify the correspoding request
    	 */
    	inline const uint32_t &getHandle() const { return std::get<1>(values_); }
    	inline void setHandle(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const CurrentStationListSortingMode& _other) const {
                return (getMode() == _other.getMode() && getHandle() == _other.getHandle());
        }
    	inline bool operator!=(const CurrentStationListSortingMode &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.tuner.OrinocoTunerTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(3, 1);
}

}; // struct OrinocoTunerTypes

} // namespace tuner
} // namespace harman
} // namespace com
} // namespace v3

namespace CommonAPI {
}


namespace std {
    //Hash for Source
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::Source> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::Source& source) const {
            return static_cast<int32_t>(source);
        }
    };
    //Hash for StationSeekMode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::StationSeekMode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSeekMode& stationSeekMode) const {
            return static_cast<int32_t>(stationSeekMode);
        }
    };
    //Hash for AnnouncementState
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::AnnouncementState> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::AnnouncementState& announcementState) const {
            return static_cast<int32_t>(announcementState);
        }
    };
    //Hash for AmFmRegionCode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::AmFmRegionCode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmRegionCode& amFmRegionCode) const {
            return static_cast<int32_t>(amFmRegionCode);
        }
    };
    //Hash for DabRegionCode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::DabRegionCode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::DabRegionCode& dabRegionCode) const {
            return static_cast<int32_t>(dabRegionCode);
        }
    };
    //Hash for AmFmCodingFlag
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::AmFmCodingFlag> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmCodingFlag& amFmCodingFlag) const {
            return static_cast<int32_t>(amFmCodingFlag);
        }
    };
    //Hash for DabCodingFlag
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::DabCodingFlag> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::DabCodingFlag& dabCodingFlag) const {
            return static_cast<int32_t>(dabCodingFlag);
        }
    };
    //Hash for AmFmHdMode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode& amFmHdMode) const {
            return static_cast<int32_t>(amFmHdMode);
        }
    };
    //Hash for StationListType
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::StationListType> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationListType& stationListType) const {
            return static_cast<int32_t>(stationListType);
        }
    };
    //Hash for TagType
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::TagType> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::TagType& tagType) const {
            return static_cast<int32_t>(tagType);
        }
    };
    //Hash for ProcessedMethod
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::ProcessedMethod> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::ProcessedMethod& processedMethod) const {
            return static_cast<int32_t>(processedMethod);
        }
    };
    //Hash for Result
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::Result> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::Result& result) const {
            return static_cast<int32_t>(result);
        }
    };
    //Hash for UserSelection
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::UserSelection> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::UserSelection& userSelection) const {
            return static_cast<int32_t>(userSelection);
        }
    };
    //Hash for GenreSpecifics
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::GenreSpecifics> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::GenreSpecifics& genreSpecifics) const {
            return static_cast<int32_t>(genreSpecifics);
        }
    };
    //Hash for StationUpdateMode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::StationUpdateMode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationUpdateMode& stationUpdateMode) const {
            return static_cast<int32_t>(stationUpdateMode);
        }
    };
    //Hash for AmFmHdBallgameMode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdBallgameMode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdBallgameMode& amFmHdBallgameMode) const {
            return static_cast<int32_t>(amFmHdBallgameMode);
        }
    };
    //Hash for StationListSortingMode
    template<>
    struct hash<::v3::com::harman::tuner::OrinocoTunerTypes::StationListSortingMode> {
        inline size_t operator()(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationListSortingMode& stationListSortingMode) const {
            return static_cast<int32_t>(stationListSortingMode);
        }
    };
}


// Compatibility
namespace v3_1 = v3;

#endif // V3_COM_HARMAN_TUNER_Orinoco_Tuner_Types_HPP_
