/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: This is a Common API DBUS settings interface of audio presentation controller
 *   for Orinoco 2.0
 * author: AYatheesh
 */
#ifndef V3_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Settings_PROXY_HPP_
#define V3_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Settings_PROXY_HPP_

#include <v3/com/harman/audio/audioPresCtrl/audioPresCtrlSettingsProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace com {
namespace harman {
namespace audio {
namespace audioPresCtrl {

template <typename ... _AttributeExtensions>
class audioPresCtrlSettingsProxy
    : virtual public audioPresCtrlSettings, 
      virtual public audioPresCtrlSettingsProxyBase,
      virtual public _AttributeExtensions... {
public:
    audioPresCtrlSettingsProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~audioPresCtrlSettingsProxy();

    typedef audioPresCtrlSettings InterfaceType;


    /**
     * description: Attribute holding current fade level
     */
    /**
     * Returns the wrapper class that provides access to the attribute Fade.
     */
    virtual FadeAttribute& getFadeAttribute() {
        return delegate_->getFadeAttribute();
    }
    /**
     * description: Attribute holding current Balance level
     */
    /**
     * Returns the wrapper class that provides access to the attribute Balance.
     */
    virtual BalanceAttribute& getBalanceAttribute() {
        return delegate_->getBalanceAttribute();
    }
    /**
     * description: Attribute holding current Bass level
     */
    /**
     * Returns the wrapper class that provides access to the attribute Bass.
     */
    virtual BassAttribute& getBassAttribute() {
        return delegate_->getBassAttribute();
    }
    /**
     * description: Attribute holding current Mid level
     */
    /**
     * Returns the wrapper class that provides access to the attribute Mid.
     */
    virtual MidAttribute& getMidAttribute() {
        return delegate_->getMidAttribute();
    }
    /**
     * description: Attribute holding current Treble level
     */
    /**
     * Returns the wrapper class that provides access to the attribute Treble.
     */
    virtual TrebleAttribute& getTrebleAttribute() {
        return delegate_->getTrebleAttribute();
    }
    /**
     * description: Attribute holding Equalizer set
     */
    /**
     * Returns the wrapper class that provides access to the attribute Equalizer.
     */
    virtual EqualizerAttribute& getEqualizerAttribute() {
        return delegate_->getEqualizerAttribute();
    }
    /**
     * description: Attribute holding Clarifi status (enabled/disabled)
     */
    /**
     * Returns the wrapper class that provides access to the attribute Clarifi.
     */
    virtual ClarifiAttribute& getClarifiAttribute() {
        return delegate_->getClarifiAttribute();
    }
    /**
     * description: Attribute holding Loudness status (enabled/disabled)
     */
    /**
     * Returns the wrapper class that provides access to the attribute Loudness.
     */
    virtual LoudnessAttribute& getLoudnessAttribute() {
        return delegate_->getLoudnessAttribute();
    }
    /**
     * description: Attribute holding current AVCMode level
     */
    /**
     * Returns the wrapper class that provides access to the attribute AVCMode.
     */
    virtual AVCModeAttribute& getAVCModeAttribute() {
        return delegate_->getAVCModeAttribute();
    }
    /**
     * description: Attribute holding Aux offset gain value
     */
    /**
     * Returns the wrapper class that provides access to the attribute AuxOffsetGain.
     */
    virtual AuxOffsetGainAttribute& getAuxOffsetGainAttribute() {
        return delegate_->getAuxOffsetGainAttribute();
    }
    /**
     * description: Attribute holding Mid low value
     */
    /**
     * Returns the wrapper class that provides access to the attribute MidLow.
     */
    virtual MidLowAttribute& getMidLowAttribute() {
        return delegate_->getMidLowAttribute();
    }
    /**
     * description: Attribute holding MidHigh value
     */
    /**
     * Returns the wrapper class that provides access to the attribute MidHigh.
     */
    virtual MidHighAttribute& getMidHighAttribute() {
        return delegate_->getMidHighAttribute();
    }
    /**
     * description: Attribute holding A2dp source offset gain value
     */
    /**
     * Returns the wrapper class that provides access to the attribute A2dpOffsetGain.
     */
    virtual A2dpOffsetGainAttribute& getA2dpOffsetGainAttribute() {
        return delegate_->getA2dpOffsetGainAttribute();
    }
    /**
     * description: Attribute holding Mic gain value
     */
    /**
     * Returns the wrapper class that provides access to the attribute MicGain.
     */
    virtual MicGainAttribute& getMicGainAttribute() {
        return delegate_->getMicGainAttribute();
    }
    /**
     * description: Attribute to hold CUSTOM EQ preset value defined by user
     */
    /**
     * Returns the wrapper class that provides access to the attribute UserDefCustomValue.
     */
    virtual UserDefCustomValueAttribute& getUserDefCustomValueAttribute() {
        return delegate_->getUserDefCustomValueAttribute();
    }
    /**
     * description: Attribute holding mute state of active source
     */
    /**
     * Returns the wrapper class that provides access to the attribute ActiveSrcMute.
     */
    virtual ActiveSrcMuteAttribute& getActiveSrcMuteAttribute() {
        return delegate_->getActiveSrcMuteAttribute();
    }
    /**
     * description: Attribute holding system mute state
     */
    /**
     * Returns the wrapper class that provides access to the attribute MasterMute.
     */
    virtual MasterMuteAttribute& getMasterMuteAttribute() {
        return delegate_->getMasterMuteAttribute();
    }
    /**
     * description: Attribute holding MicMute status
     */
    /**
     * Returns the wrapper class that provides access to the attribute MicMuteStatus.
     */
    virtual MicMuteStatusAttribute& getMicMuteStatusAttribute() {
        return delegate_->getMicMuteStatusAttribute();
    }
    /**
     * description: Attribute holding touch beep tone selection
     */
    /**
     * Returns the wrapper class that provides access to the attribute TouchBeepSelection.
     */
    virtual TouchBeepSelectionAttribute& getTouchBeepSelectionAttribute() {
        return delegate_->getTouchBeepSelectionAttribute();
    }
    /**
     * description: Attribute holding touch beep tone selection
     */
    /**
     * Returns the wrapper class that provides access to the attribute KeypadBeepSelection.
     */
    virtual KeypadBeepSelectionAttribute& getKeypadBeepSelectionAttribute() {
        return delegate_->getKeypadBeepSelectionAttribute();
    }
    /**
     * description: Attribute to hold enable/disable state of all types of Touch beeps like
     *   WARNING, CONFIRMATION etc..
     */
    /**
     * Returns the wrapper class that provides access to the attribute BeepStatus.
     */
    virtual BeepStatusAttribute& getBeepStatusAttribute() {
        return delegate_->getBeepStatusAttribute();
    }
    /**
     * description: Attribute holding occupancy mode selection
     */
    /**
     * Returns the wrapper class that provides access to the attribute OccupancyMode.
     */
    virtual OccupancyModeAttribute& getOccupancyModeAttribute() {
        return delegate_->getOccupancyModeAttribute();
    }
    /**
     * description: Attribute holding AutoPlay Status
     */
    /**
     * Returns the wrapper class that provides access to the attribute USBAutoPlayStatus.
     */
    virtual USBAutoPlayStatusAttribute& getUSBAutoPlayStatusAttribute() {
        return delegate_->getUSBAutoPlayStatusAttribute();
    }
    /**
     * description: Attribute holding last played Tuner source in a power cycle.
     */
    /**
     * Returns the wrapper class that provides access to the attribute LastPlayedTunerSrc.
     */
    virtual LastPlayedTunerSrcAttribute& getLastPlayedTunerSrcAttribute() {
        return delegate_->getLastPlayedTunerSrcAttribute();
    }
    /**
     * description: Attribute holding last played Media source in a power cycle
     */
    /**
     * Returns the wrapper class that provides access to the attribute LastPlayedMediaSrc.
     */
    virtual LastPlayedMediaSrcAttribute& getLastPlayedMediaSrcAttribute() {
        return delegate_->getLastPlayedMediaSrcAttribute();
    }
    /**
     * description: Attribute holding previous Entertainment source in a power cycle. If previous
     *   source is unavailable, FM(default source) will be consider as previous source
     */
    /**
     * Returns the wrapper class that provides access to the attribute PreviousEntSource.
     */
    virtual PreviousEntSourceAttribute& getPreviousEntSourceAttribute() {
        return delegate_->getPreviousEntSourceAttribute();
    }

    /**
     * description: To broadcast volume change signal to HMI to display updated volume level
     */
    /**
     * Returns the wrapper class that provides access to the broadcast VolumeChange.
     */
    virtual VolumeChangeEvent& getVolumeChangeEvent() {
        return delegate_->getVolumeChangeEvent();
    }
    /**
     * description: To broadcast volume update signal to HMI to display updated volume level along
     *   with source volume group name
     */
    /**
     * Returns the wrapper class that provides access to the broadcast VolumeUpdate.
     */
    virtual VolumeUpdateEvent& getVolumeUpdateEvent() {
        return delegate_->getVolumeUpdateEvent();
    }
    /**
     * description: To broadcast system mute state to HMI
     */
    /**
     * Returns the wrapper class that provides access to the broadcast SourceMuteState.
     */
    virtual SourceMuteStateEvent& getSourceMuteStateEvent() {
        return delegate_->getSourceMuteStateEvent();
    }

    /**
     * description: This method is used to set absolute volume of presently playing source.  	If
     *   interrupt source is active, it changes the volume of active interrupt source
     *   	If no interrupts are active, it changes volume of Entertainment source.
     *   	(at)broadast VolumeChange
     * Calls SetVolume with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetVolume(const uint16_t &_absoluteVolume, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to set Volume of presently playing source where volume
     *   change is given in steps example -2 or +2 	(at)broadast VolumeChange
     * Calls SetVolumeStep with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetVolumeStep(const int16_t &_volumeStep, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to set Volume of any source group 	(at)broadast VolumeChange
     * Calls SetSourceVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetSourceVolume(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetSourceVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetSourceVolumeAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volume, SetSourceVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to get Volume of any source 	(at)return eAudioPresErrors
     * Calls GetSourceVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetSourceVolume(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volumeOfSource, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetSourceVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetSourceVolumeAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, GetSourceVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle mute status of currently playing source
     *   	(at)attribute update ActiveSrcMute
     * Calls ToggleActiveSrcMute with Fire&Forget semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleActiveSrcMute(CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to set mute status of any particular source 	(at)broadcast
     *   SourceMuteState
     * Calls SetSourceMute with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetSourceMute(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, const bool &_mute, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to toggle MIC mute status  	(at)attribute update
     *   MicMuteStatus
     * Calls ToggleMicMute with Fire&Forget semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleMicMute(CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to get supported EQ preset, Touch tone list and keyboard
     *   tone list 	(at)return eAudioPresErrors
     * Calls GetList with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetList(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption &_listType, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems &_list, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetListAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption &_listType, GetListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to get mute status of any particular source 	(at)return
     *   eAudioPresErrors
     * Calls GetSourceMute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetSourceMute(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceId, bool &_mute, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetSourceMute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetSourceMuteAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, GetSourceMuteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle mute status of complete system 	(at)attribute
     *   update MasterMute
     * Calls ToggleMasterMute with Fire&Forget semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleMasterMute(CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to set audio settings attributes     You may pass a map of
     *   attributes rather than multiple calls.      For example , the balance and fade
     *   is always a combination 	(at)attribute update
     * Calls setAudioAttribute with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setAudioAttribute(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::mAttribute &_attributesmap, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to do Factory reset or Master reset
     * Calls ResetAudioSettings with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ResetAudioSettings(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eResetType &_resetType, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to set custom EQ preset value
     * Calls SetCustomPreset with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetCustomPreset(const int16_t &_frequencyBandValue, CommonAPI::CallStatus &_internalCallStatus);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<audioPresCtrlSettingsProxyBase> delegate_;
};

typedef audioPresCtrlSettingsProxy<> audioPresCtrlSettingsProxyDefault;

namespace audioPresCtrlSettingsExtensions {
    /**
     * description: Attribute holding current fade level
     */
    template <template <typename > class _ExtensionType>
    class FadeAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::FadeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::FadeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        FadeAttributeExtension() {}
    #endif
    
        FadeAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getFadeAttribute()) {
        }
    
        inline extension_type& getFadeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current Balance level
     */
    template <template <typename > class _ExtensionType>
    class BalanceAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::BalanceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::BalanceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BalanceAttributeExtension() {}
    #endif
    
        BalanceAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getBalanceAttribute()) {
        }
    
        inline extension_type& getBalanceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current Bass level
     */
    template <template <typename > class _ExtensionType>
    class BassAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::BassAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::BassAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BassAttributeExtension() {}
    #endif
    
        BassAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getBassAttribute()) {
        }
    
        inline extension_type& getBassAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current Mid level
     */
    template <template <typename > class _ExtensionType>
    class MidAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::MidAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::MidAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MidAttributeExtension() {}
    #endif
    
        MidAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getMidAttribute()) {
        }
    
        inline extension_type& getMidAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current Treble level
     */
    template <template <typename > class _ExtensionType>
    class TrebleAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::TrebleAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::TrebleAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        TrebleAttributeExtension() {}
    #endif
    
        TrebleAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getTrebleAttribute()) {
        }
    
        inline extension_type& getTrebleAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Equalizer set
     */
    template <template <typename > class _ExtensionType>
    class EqualizerAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::EqualizerAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::EqualizerAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EqualizerAttributeExtension() {}
    #endif
    
        EqualizerAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getEqualizerAttribute()) {
        }
    
        inline extension_type& getEqualizerAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Clarifi status (enabled/disabled)
     */
    template <template <typename > class _ExtensionType>
    class ClarifiAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::ClarifiAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::ClarifiAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ClarifiAttributeExtension() {}
    #endif
    
        ClarifiAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getClarifiAttribute()) {
        }
    
        inline extension_type& getClarifiAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Loudness status (enabled/disabled)
     */
    template <template <typename > class _ExtensionType>
    class LoudnessAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::LoudnessAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::LoudnessAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LoudnessAttributeExtension() {}
    #endif
    
        LoudnessAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getLoudnessAttribute()) {
        }
    
        inline extension_type& getLoudnessAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding current AVCMode level
     */
    template <template <typename > class _ExtensionType>
    class AVCModeAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::AVCModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::AVCModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AVCModeAttributeExtension() {}
    #endif
    
        AVCModeAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getAVCModeAttribute()) {
        }
    
        inline extension_type& getAVCModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Aux offset gain value
     */
    template <template <typename > class _ExtensionType>
    class AuxOffsetGainAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::AuxOffsetGainAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::AuxOffsetGainAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AuxOffsetGainAttributeExtension() {}
    #endif
    
        AuxOffsetGainAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getAuxOffsetGainAttribute()) {
        }
    
        inline extension_type& getAuxOffsetGainAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Mid low value
     */
    template <template <typename > class _ExtensionType>
    class MidLowAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::MidLowAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::MidLowAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MidLowAttributeExtension() {}
    #endif
    
        MidLowAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getMidLowAttribute()) {
        }
    
        inline extension_type& getMidLowAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding MidHigh value
     */
    template <template <typename > class _ExtensionType>
    class MidHighAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::MidHighAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::MidHighAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MidHighAttributeExtension() {}
    #endif
    
        MidHighAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getMidHighAttribute()) {
        }
    
        inline extension_type& getMidHighAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding A2dp source offset gain value
     */
    template <template <typename > class _ExtensionType>
    class A2dpOffsetGainAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::A2dpOffsetGainAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::A2dpOffsetGainAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        A2dpOffsetGainAttributeExtension() {}
    #endif
    
        A2dpOffsetGainAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getA2dpOffsetGainAttribute()) {
        }
    
        inline extension_type& getA2dpOffsetGainAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Mic gain value
     */
    template <template <typename > class _ExtensionType>
    class MicGainAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::MicGainAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::MicGainAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MicGainAttributeExtension() {}
    #endif
    
        MicGainAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getMicGainAttribute()) {
        }
    
        inline extension_type& getMicGainAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to hold CUSTOM EQ preset value defined by user
     */
    template <template <typename > class _ExtensionType>
    class UserDefCustomValueAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::UserDefCustomValueAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::UserDefCustomValueAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UserDefCustomValueAttributeExtension() {}
    #endif
    
        UserDefCustomValueAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getUserDefCustomValueAttribute()) {
        }
    
        inline extension_type& getUserDefCustomValueAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding mute state of active source
     */
    template <template <typename > class _ExtensionType>
    class ActiveSrcMuteAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::ActiveSrcMuteAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::ActiveSrcMuteAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActiveSrcMuteAttributeExtension() {}
    #endif
    
        ActiveSrcMuteAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getActiveSrcMuteAttribute()) {
        }
    
        inline extension_type& getActiveSrcMuteAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding system mute state
     */
    template <template <typename > class _ExtensionType>
    class MasterMuteAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::MasterMuteAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::MasterMuteAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MasterMuteAttributeExtension() {}
    #endif
    
        MasterMuteAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getMasterMuteAttribute()) {
        }
    
        inline extension_type& getMasterMuteAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding MicMute status
     */
    template <template <typename > class _ExtensionType>
    class MicMuteStatusAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::MicMuteStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::MicMuteStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MicMuteStatusAttributeExtension() {}
    #endif
    
        MicMuteStatusAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getMicMuteStatusAttribute()) {
        }
    
        inline extension_type& getMicMuteStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding touch beep tone selection
     */
    template <template <typename > class _ExtensionType>
    class TouchBeepSelectionAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::TouchBeepSelectionAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::TouchBeepSelectionAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        TouchBeepSelectionAttributeExtension() {}
    #endif
    
        TouchBeepSelectionAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getTouchBeepSelectionAttribute()) {
        }
    
        inline extension_type& getTouchBeepSelectionAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding touch beep tone selection
     */
    template <template <typename > class _ExtensionType>
    class KeypadBeepSelectionAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::KeypadBeepSelectionAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::KeypadBeepSelectionAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        KeypadBeepSelectionAttributeExtension() {}
    #endif
    
        KeypadBeepSelectionAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getKeypadBeepSelectionAttribute()) {
        }
    
        inline extension_type& getKeypadBeepSelectionAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to hold enable/disable state of all types of Touch beeps like
     *   WARNING, CONFIRMATION etc..
     */
    template <template <typename > class _ExtensionType>
    class BeepStatusAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::BeepStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::BeepStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BeepStatusAttributeExtension() {}
    #endif
    
        BeepStatusAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getBeepStatusAttribute()) {
        }
    
        inline extension_type& getBeepStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding occupancy mode selection
     */
    template <template <typename > class _ExtensionType>
    class OccupancyModeAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::OccupancyModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::OccupancyModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        OccupancyModeAttributeExtension() {}
    #endif
    
        OccupancyModeAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getOccupancyModeAttribute()) {
        }
    
        inline extension_type& getOccupancyModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding AutoPlay Status
     */
    template <template <typename > class _ExtensionType>
    class USBAutoPlayStatusAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::USBAutoPlayStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::USBAutoPlayStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        USBAutoPlayStatusAttributeExtension() {}
    #endif
    
        USBAutoPlayStatusAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getUSBAutoPlayStatusAttribute()) {
        }
    
        inline extension_type& getUSBAutoPlayStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding last played Tuner source in a power cycle.
     */
    template <template <typename > class _ExtensionType>
    class LastPlayedTunerSrcAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::LastPlayedTunerSrcAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::LastPlayedTunerSrcAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LastPlayedTunerSrcAttributeExtension() {}
    #endif
    
        LastPlayedTunerSrcAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getLastPlayedTunerSrcAttribute()) {
        }
    
        inline extension_type& getLastPlayedTunerSrcAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding last played Media source in a power cycle
     */
    template <template <typename > class _ExtensionType>
    class LastPlayedMediaSrcAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::LastPlayedMediaSrcAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::LastPlayedMediaSrcAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LastPlayedMediaSrcAttributeExtension() {}
    #endif
    
        LastPlayedMediaSrcAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getLastPlayedMediaSrcAttribute()) {
        }
    
        inline extension_type& getLastPlayedMediaSrcAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding previous Entertainment source in a power cycle. If previous
     *   source is unavailable, FM(default source) will be consider as previous source
     */
    template <template <typename > class _ExtensionType>
    class PreviousEntSourceAttributeExtension {
     public:
        typedef _ExtensionType<audioPresCtrlSettingsProxyBase::PreviousEntSourceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<audioPresCtrlSettingsProxyBase::PreviousEntSourceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        PreviousEntSourceAttributeExtension() {}
    #endif
    
        PreviousEntSourceAttributeExtension(audioPresCtrlSettingsProxyBase& proxy): attributeExtension_(proxy.getPreviousEntSourceAttribute()) {
        }
    
        inline extension_type& getPreviousEntSourceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace audioPresCtrlSettingsExtensions

//
// audioPresCtrlSettingsProxy Implementation
//
template <typename ... _AttributeExtensions>
audioPresCtrlSettingsProxy<_AttributeExtensions...>::audioPresCtrlSettingsProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<audioPresCtrlSettingsProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<audioPresCtrlSettingsProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
audioPresCtrlSettingsProxy<_AttributeExtensions...>::~audioPresCtrlSettingsProxy() {
}

/**
 * description: This method is used to set absolute volume of presently playing source.  	If
 *   interrupt source is active, it changes the volume of active interrupt source
 *   	If no interrupts are active, it changes volume of Entertainment source.
 *   	(at)broadast VolumeChange
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::SetVolume(const uint16_t &_absoluteVolume, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->SetVolume(_absoluteVolume, _internalCallStatus);
}
/**
 * description: This method is used to set Volume of presently playing source where volume
 *   change is given in steps example -2 or +2 	(at)broadast VolumeChange
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::SetVolumeStep(const int16_t &_volumeStep, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->SetVolumeStep(_volumeStep, _internalCallStatus);
}
/**
 * description: This method is used to set Volume of any source group 	(at)broadast VolumeChange
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::SetSourceVolume(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetSourceVolume(_volume, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlSettingsProxy<_AttributeExtensions...>::SetSourceVolumeAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volume, SetSourceVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetSourceVolumeAsync(_volume, _callback, _info);
}
/**
 * description: This method is used to get Volume of any source 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::GetSourceVolume(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::sSourceVolume &_volumeOfSource, const CommonAPI::CallInfo *_info) {
    delegate_->GetSourceVolume(_sourceID, _internalCallStatus, _error, _volumeOfSource, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlSettingsProxy<_AttributeExtensions...>::GetSourceVolumeAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, GetSourceVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->GetSourceVolumeAsync(_sourceID, _callback, _info);
}
/**
 * description: This method is used to toggle mute status of currently playing source
 *   	(at)attribute update ActiveSrcMute
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::ToggleActiveSrcMute(CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->ToggleActiveSrcMute(_internalCallStatus);
}
/**
 * description: This method is used to set mute status of any particular source 	(at)broadcast
 *   SourceMuteState
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::SetSourceMute(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, const bool &_mute, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->SetSourceMute(_sourceID, _mute, _internalCallStatus);
}
/**
 * description: This method is used to toggle MIC mute status  	(at)attribute update
 *   MicMuteStatus
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::ToggleMicMute(CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->ToggleMicMute(_internalCallStatus);
}
/**
 * description: This method is used to get supported EQ preset, Touch tone list and keyboard
 *   tone list 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::GetList(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption &_listType, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems &_list, const CommonAPI::CallInfo *_info) {
    if (!_listType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->GetList(_listType, _internalCallStatus, _error, _list, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlSettingsProxy<_AttributeExtensions...>::GetListAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eUserOption &_listType, GetListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_listType.validate()) {
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors error;
        ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::ListItems list = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error, list);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->GetListAsync(_listType, _callback, _info);
}
/**
 * description: This method is used to get mute status of any particular source 	(at)return
 *   eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::GetSourceMute(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, CommonAPI::CallStatus &_internalCallStatus, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eAudioPresErrors &_error, ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceId, bool &_mute, const CommonAPI::CallInfo *_info) {
    delegate_->GetSourceMute(_sourceID, _internalCallStatus, _error, _sourceId, _mute, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> audioPresCtrlSettingsProxy<_AttributeExtensions...>::GetSourceMuteAsync(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::SourceId &_sourceID, GetSourceMuteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->GetSourceMuteAsync(_sourceID, _callback, _info);
}
/**
 * description: This method is used to toggle mute status of complete system 	(at)attribute
 *   update MasterMute
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::ToggleMasterMute(CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->ToggleMasterMute(_internalCallStatus);
}
/**
 * description: This method is used to set audio settings attributes     You may pass a map of
 *   attributes rather than multiple calls.      For example , the balance and fade
 *   is always a combination 	(at)attribute update
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::setAudioAttribute(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::mAttribute &_attributesmap, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->setAudioAttribute(_attributesmap, _internalCallStatus);
}
/**
 * description: This method is used to do Factory reset or Master reset
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::ResetAudioSettings(const ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlTypes::eResetType &_resetType, CommonAPI::CallStatus &_internalCallStatus) {
    if (!_resetType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ResetAudioSettings(_resetType, _internalCallStatus);
}
/**
 * description: This method is used to set custom EQ preset value
 */
template <typename ... _AttributeExtensions>
void audioPresCtrlSettingsProxy<_AttributeExtensions...>::SetCustomPreset(const int16_t &_frequencyBandValue, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->SetCustomPreset(_frequencyBandValue, _internalCallStatus);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &audioPresCtrlSettingsProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool audioPresCtrlSettingsProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool audioPresCtrlSettingsProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& audioPresCtrlSettingsProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& audioPresCtrlSettingsProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace audioPresCtrl
} // namespace audio
} // namespace harman
} // namespace com
} // namespace v3

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsProxy,
    _AttributeExtension> {
    typedef typename ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsProxy<
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::FadeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::BalanceAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::BassAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::MidAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::TrebleAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::EqualizerAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::ClarifiAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::LoudnessAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::AVCModeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::AuxOffsetGainAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::MidLowAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::MidHighAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::A2dpOffsetGainAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::MicGainAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::UserDefCustomValueAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::ActiveSrcMuteAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::MasterMuteAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::MicMuteStatusAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::TouchBeepSelectionAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::KeypadBeepSelectionAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::BeepStatusAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::OccupancyModeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::USBAutoPlayStatusAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::LastPlayedTunerSrcAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::LastPlayedMediaSrcAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::audio::audioPresCtrl::audioPresCtrlSettingsExtensions::PreviousEntSourceAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v3_3 = v3;

#endif // V3_COM_HARMAN_AUDIO_AUDIOPRESCTRL_audio_Pres_Ctrl_Settings_PROXY_HPP_
