/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Orinoco specific tuner interface. This interface is a facade to a bunch of
 *   plattform interfaces in order to provide a simplified access to tuner data and
 *   functionality.
 * author: Harman, CoC Tuner, Dirk Engel (c) copyright 2016
 */
#ifndef V3_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_HPP_
#define V3_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_HPP_

#include <v3/com/harman/tuner/OrinocoTunerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v3 {
namespace com {
namespace harman {
namespace tuner {

template <typename ... _AttributeExtensions>
class OrinocoTunerProxy
    : virtual public OrinocoTuner, 
      virtual public OrinocoTunerProxyBase,
      virtual public _AttributeExtensions... {
public:
    OrinocoTunerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~OrinocoTunerProxy();

    typedef OrinocoTuner InterfaceType;


    /**
     * description: The sorting mode used for station lists (except from type LIST_PRESET)
     */
    /**
     * Returns the wrapper class that provides access to the attribute stationListSortingMode.
     */
    virtual StationListSortingModeAttribute& getStationListSortingModeAttribute() {
        return delegate_->getStationListSortingModeAttribute();
    }
    /**
     * description: The the station update mode for the current active tuner audio source.
     */
    /**
     * Returns the wrapper class that provides access to the attribute audioStationUpdateMode.
     */
    virtual AudioStationUpdateModeAttribute& getAudioStationUpdateModeAttribute() {
        return delegate_->getAudioStationUpdateModeAttribute();
    }
    /**
     * description: The current active tuner source and station.
     */
    /**
     * Returns the wrapper class that provides access to the attribute audioCurrentStation.
     */
    virtual AudioCurrentStationAttribute& getAudioCurrentStationAttribute() {
        return delegate_->getAudioCurrentStationAttribute();
    }
    /**
     * description: The station list of the current tuner audio source
     */
    /**
     * Returns the wrapper class that provides access to the attribute audioStationList.
     */
    virtual AudioStationListAttribute& getAudioStationListAttribute() {
        return delegate_->getAudioStationListAttribute();
    }
    /**
     * description: The preset list of the current tuner audio source (content depends on
     *   configuration: mixed mode or dedicated)
     */
    /**
     * Returns the wrapper class that provides access to the attribute audioPresetList.
     */
    virtual AudioPresetListAttribute& getAudioPresetListAttribute() {
        return delegate_->getAudioPresetListAttribute();
    }
    /**
     * description: All available information about the current settings and state of
     *   announcements. Announcement monitoring can be activated/deactivated by
     *   "announcementSetConfiguration". An active announcement can be aborted by
     *   "announcementAbort".
     */
    /**
     * Returns the wrapper class that provides access to the attribute announcementCurrentStatus.
     */
    virtual AnnouncementCurrentStatusAttribute& getAnnouncementCurrentStatusAttribute() {
        return delegate_->getAnnouncementCurrentStatusAttribute();
    }
    /**
     * description: The AM/FM region code and waveband information
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlRegionInfo.
     */
    virtual AmfmControlRegionInfoAttribute& getAmfmControlRegionInfoAttribute() {
        return delegate_->getAmfmControlRegionInfoAttribute();
    }
    /**
     * description: The current state of the alternative frequency (AF) switch. The switch can be
     *   controlled by the request "amfmControlSetAfSwitch".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlAfSwitch.
     */
    virtual AmfmControlAfSwitchAttribute& getAmfmControlAfSwitchAttribute() {
        return delegate_->getAmfmControlAfSwitchAttribute();
    }
    /**
     * description: The current state of the regionalization (REG) switch. The switch can be
     *   controlled by the request "amfmControlSetRegSwitch".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlRegSwitch.
     */
    virtual AmfmControlRegSwitchAttribute& getAmfmControlRegSwitchAttribute() {
        return delegate_->getAmfmControlRegSwitchAttribute();
    }
    /**
     * description: The current state of the HD ballgame mode switch. The switch can be controlled
     *   by the request "amfmControlSetHdBallgameMode".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlHdBallgameMode.
     */
    virtual AmfmControlHdBallgameModeAttribute& getAmfmControlHdBallgameModeAttribute() {
        return delegate_->getAmfmControlHdBallgameModeAttribute();
    }
    /**
     * description: The current HD mode. The switch can be controlled by the request
     *   "amfmControlSetHdMode".
     */
    /**
     * Returns the wrapper class that provides access to the attribute amfmControlHdMode.
     */
    virtual AmfmControlHdModeAttribute& getAmfmControlHdModeAttribute() {
        return delegate_->getAmfmControlHdModeAttribute();
    }
    /**
     * description: The DAB region code
     */
    /**
     * Returns the wrapper class that provides access to the attribute dabControlRegionInfo.
     */
    virtual DabControlRegionInfoAttribute& getDabControlRegionInfoAttribute() {
        return delegate_->getDabControlRegionInfoAttribute();
    }
    /**
     * description: The current state of the DAB/FM service following switch (DAB/DAB cannot be
     *   disabled via this interface). The switch can be controlled by the request
     *   "dabControlSetFollowingSwitch".
     */
    /**
     * Returns the wrapper class that provides access to the attribute dabControlFollowingSwitch.
     */
    virtual DabControlFollowingSwitchAttribute& getDabControlFollowingSwitchAttribute() {
        return delegate_->getDabControlFollowingSwitchAttribute();
    }

    /**
     * description: Current station update. Updates of different source might happen in parallel
     *   (not only for the current audio source). If FM, for example, is the active
     *   audio source according to attribute "audioCurrentSource" this is also the
     *   currently active tuner station which is audible.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast stationCurrentStation.
     */
    virtual StationCurrentStationEvent& getStationCurrentStationEvent() {
        return delegate_->getStationCurrentStationEvent();
    }
    /**
     * description: List update. Check "stationList.source" and "stationList.listType" to
     *   distinguish between different lists.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast stationStationList.
     */
    virtual StationStationListEvent& getStationStationListEvent() {
        return delegate_->getStationStationListEvent();
    }
    /**
     * description: Optional: Asynchronous method response (will be called after all necessary
     *   action is done to fulfill a specific request call).     Usually, the handle of
     *   the request that caused a change of an attribute is updated within the
     *   attribute. But in case of multiple clients or if many calls are done in quick
     *   succession only the last request will lead to the final state and will be
     *   visible in the attribute.    However, by using this callback you'll be
     *   informed about each processed request even if it's result will have no actual
     *   effect because of overwriting (last wins strategy).
     */
    /**
     * Returns the wrapper class that provides access to the broadcast methodProcessed.
     */
    virtual MethodProcessedEvent& getMethodProcessedEvent() {
        return delegate_->getMethodProcessedEvent();
    }

    /**
     * description: Any manipulation of the current station: Selection by list / direct frequency
     *   tuning / preset selection / starting a search run. As result the information
     *   "stationCurrentStation" is updated with the given handle.
     * Calls stationSelectStation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stationSelectStation(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stationSelectStation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stationSelectStationAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, StationSelectStationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Store the given station in corresponding preset list (depends on project
     *   configuration wether there is ony list per source or one common list) and
     *   assign the given preset number for later recalls (via "stationStartTune").   
     *   As result the corresponding information "stationStationList" is updated with
     *   the given handle.
     * Calls stationStorePreset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stationStorePreset(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stationStorePreset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stationStorePresetAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, StationStorePresetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Remove given preset number from corresponding preset list.     As result the
     *   corresponding information "stationStationList" is updated with the given handle
     * Calls stationDeletePreset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stationDeletePreset(const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls stationDeletePreset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> stationDeletePresetAsync(const uint32_t &_preset, const uint32_t &_handle, StationDeletePresetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Customize the content and updates of current station and station list
     * Calls audioSetStationUpdateMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void audioSetStationUpdateMode(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationUpdateMode &_updateMode, const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls audioSetStationUpdateMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> audioSetStationUpdateModeAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationUpdateMode &_updateMode, const bool &_enable, const uint32_t &_handle, AudioSetStationUpdateModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Enable/disable the announcement monitoring for FM and DAB.    As result the
     *   attribute "announcementCurrentStatus" is updated with the given handle
     * Calls announcementSetConfiguration with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void announcementSetConfiguration(const ::v3::com::harman::tuner::OrinocoTunerTypes::AnnouncementConfiguration &_configuration, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls announcementSetConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> announcementSetConfigurationAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::AnnouncementConfiguration &_configuration, const uint32_t &_handle, AnnouncementSetConfigurationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Abort an active announcement. As a result the attribute
     *   "announcementCurrentStatus" is updated with the given handle.
     * Calls announcementAbort with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void announcementAbort(const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls announcementAbort with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> announcementAbortAsync(const uint32_t &_handle, AnnouncementAbortAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: [AM/FM only] Set the desired RDS alternative frequency (AF) state. As result
     *   the attribute "amfmControlAfSwitch" is updated.
     * Calls amfmControlSetAfSwitch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetAfSwitch(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetAfSwitch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetAfSwitchAsync(const bool &_enable, const uint32_t &_handle, AmfmControlSetAfSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: [AM/FM only] Set the desired RDS regionalisation (REG) state. As result the
     *   attribute "amfmControlRegSwitch" is updated.
     * Calls amfmControlSetRegSwitch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetRegSwitch(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetRegSwitch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetRegSwitchAsync(const bool &_enable, const uint32_t &_handle, AmfmControlSetRegSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: [AM/FM only] Set the desired HD mode. As result the attribute
     *   "amfmControlHdMode" is updated.
     * Calls amfmControlSetHdMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetHdMode(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode &_hdMode, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetHdMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetHdModeAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode &_hdMode, const uint32_t &_handle, AmfmControlSetHdModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: [AM/FM only] Set the desired HD ballgame mode. As result the attribute
     *   "amfmControlHdBallgameMode" is updated.
     * Calls amfmControlSetHdBallgameMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void amfmControlSetHdBallgameMode(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdBallgameMode &_hdBallgameMode, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls amfmControlSetHdBallgameMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> amfmControlSetHdBallgameModeAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdBallgameMode &_hdBallgameMode, const uint32_t &_handle, AmfmControlSetHdBallgameModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Set the desired service following at the FollowingMaster. As result the
     *   attribute "dabControlFollowingSwitch" is updated with the given handle.   
     *   Note: This switch only affects DAB/FM linking, DAB/DAB is always on
     * Calls dabControlSetFollowingSwitch with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void dabControlSetFollowingSwitch(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls dabControlSetFollowingSwitch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> dabControlSetFollowingSwitchAsync(const bool &_enable, const uint32_t &_handle, DabControlSetFollowingSwitchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Request initial broadcast update at startup (stationCurrentStation,
     *   stationStationList) in order to force an "on change" update.
     * Calls forceBroadcastUpdate with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void forceBroadcastUpdate(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls forceBroadcastUpdate with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> forceBroadcastUpdateAsync(ForceBroadcastUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<OrinocoTunerProxyBase> delegate_;
};

typedef OrinocoTunerProxy<> OrinocoTunerProxyDefault;

namespace OrinocoTunerExtensions {
    /**
     * description: The sorting mode used for station lists (except from type LIST_PRESET)
     */
    template <template <typename > class _ExtensionType>
    class StationListSortingModeAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::StationListSortingModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::StationListSortingModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        StationListSortingModeAttributeExtension() {}
    #endif
    
        StationListSortingModeAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getStationListSortingModeAttribute()) {
        }
    
        inline extension_type& getStationListSortingModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The the station update mode for the current active tuner audio source.
     */
    template <template <typename > class _ExtensionType>
    class AudioStationUpdateModeAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AudioStationUpdateModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AudioStationUpdateModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AudioStationUpdateModeAttributeExtension() {}
    #endif
    
        AudioStationUpdateModeAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAudioStationUpdateModeAttribute()) {
        }
    
        inline extension_type& getAudioStationUpdateModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current active tuner source and station.
     */
    template <template <typename > class _ExtensionType>
    class AudioCurrentStationAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AudioCurrentStationAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AudioCurrentStationAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AudioCurrentStationAttributeExtension() {}
    #endif
    
        AudioCurrentStationAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAudioCurrentStationAttribute()) {
        }
    
        inline extension_type& getAudioCurrentStationAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The station list of the current tuner audio source
     */
    template <template <typename > class _ExtensionType>
    class AudioStationListAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AudioStationListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AudioStationListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AudioStationListAttributeExtension() {}
    #endif
    
        AudioStationListAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAudioStationListAttribute()) {
        }
    
        inline extension_type& getAudioStationListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The preset list of the current tuner audio source (content depends on
     *   configuration: mixed mode or dedicated)
     */
    template <template <typename > class _ExtensionType>
    class AudioPresetListAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AudioPresetListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AudioPresetListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AudioPresetListAttributeExtension() {}
    #endif
    
        AudioPresetListAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAudioPresetListAttribute()) {
        }
    
        inline extension_type& getAudioPresetListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: All available information about the current settings and state of
     *   announcements. Announcement monitoring can be activated/deactivated by
     *   "announcementSetConfiguration". An active announcement can be aborted by
     *   "announcementAbort".
     */
    template <template <typename > class _ExtensionType>
    class AnnouncementCurrentStatusAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AnnouncementCurrentStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AnnouncementCurrentStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AnnouncementCurrentStatusAttributeExtension() {}
    #endif
    
        AnnouncementCurrentStatusAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAnnouncementCurrentStatusAttribute()) {
        }
    
        inline extension_type& getAnnouncementCurrentStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The AM/FM region code and waveband information
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlRegionInfoAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlRegionInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlRegionInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlRegionInfoAttributeExtension() {}
    #endif
    
        AmfmControlRegionInfoAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlRegionInfoAttribute()) {
        }
    
        inline extension_type& getAmfmControlRegionInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the alternative frequency (AF) switch. The switch can be
     *   controlled by the request "amfmControlSetAfSwitch".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlAfSwitchAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlAfSwitchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlAfSwitchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlAfSwitchAttributeExtension() {}
    #endif
    
        AmfmControlAfSwitchAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlAfSwitchAttribute()) {
        }
    
        inline extension_type& getAmfmControlAfSwitchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the regionalization (REG) switch. The switch can be
     *   controlled by the request "amfmControlSetRegSwitch".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlRegSwitchAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlRegSwitchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlRegSwitchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlRegSwitchAttributeExtension() {}
    #endif
    
        AmfmControlRegSwitchAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlRegSwitchAttribute()) {
        }
    
        inline extension_type& getAmfmControlRegSwitchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the HD ballgame mode switch. The switch can be controlled
     *   by the request "amfmControlSetHdBallgameMode".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlHdBallgameModeAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlHdBallgameModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlHdBallgameModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlHdBallgameModeAttributeExtension() {}
    #endif
    
        AmfmControlHdBallgameModeAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlHdBallgameModeAttribute()) {
        }
    
        inline extension_type& getAmfmControlHdBallgameModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current HD mode. The switch can be controlled by the request
     *   "amfmControlSetHdMode".
     */
    template <template <typename > class _ExtensionType>
    class AmfmControlHdModeAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::AmfmControlHdModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::AmfmControlHdModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmfmControlHdModeAttributeExtension() {}
    #endif
    
        AmfmControlHdModeAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getAmfmControlHdModeAttribute()) {
        }
    
        inline extension_type& getAmfmControlHdModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The DAB region code
     */
    template <template <typename > class _ExtensionType>
    class DabControlRegionInfoAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::DabControlRegionInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::DabControlRegionInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DabControlRegionInfoAttributeExtension() {}
    #endif
    
        DabControlRegionInfoAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getDabControlRegionInfoAttribute()) {
        }
    
        inline extension_type& getDabControlRegionInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: The current state of the DAB/FM service following switch (DAB/DAB cannot be
     *   disabled via this interface). The switch can be controlled by the request
     *   "dabControlSetFollowingSwitch".
     */
    template <template <typename > class _ExtensionType>
    class DabControlFollowingSwitchAttributeExtension {
     public:
        typedef _ExtensionType<OrinocoTunerProxyBase::DabControlFollowingSwitchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<OrinocoTunerProxyBase::DabControlFollowingSwitchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DabControlFollowingSwitchAttributeExtension() {}
    #endif
    
        DabControlFollowingSwitchAttributeExtension(OrinocoTunerProxyBase& proxy): attributeExtension_(proxy.getDabControlFollowingSwitchAttribute()) {
        }
    
        inline extension_type& getDabControlFollowingSwitchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace OrinocoTunerExtensions

//
// OrinocoTunerProxy Implementation
//
template <typename ... _AttributeExtensions>
OrinocoTunerProxy<_AttributeExtensions...>::OrinocoTunerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<OrinocoTunerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<OrinocoTunerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
OrinocoTunerProxy<_AttributeExtensions...>::~OrinocoTunerProxy() {
}

/**
 * description: Any manipulation of the current station: Selection by list / direct frequency
 *   tuning / preset selection / starting a search run. As result the information
 *   "stationCurrentStation" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::stationSelectStation(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->stationSelectStation(_stationSelector, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::stationSelectStationAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_handle, StationSelectStationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stationSelectStationAsync(_stationSelector, _handle, _callback, _info);
}
/**
 * description: Store the given station in corresponding preset list (depends on project
 *   configuration wether there is ony list per source or one common list) and
 *   assign the given preset number for later recalls (via "stationStartTune").   
 *   As result the corresponding information "stationStationList" is updated with
 *   the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::stationStorePreset(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->stationStorePreset(_stationSelector, _preset, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::stationStorePresetAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationSelector &_stationSelector, const uint32_t &_preset, const uint32_t &_handle, StationStorePresetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stationStorePresetAsync(_stationSelector, _preset, _handle, _callback, _info);
}
/**
 * description: Remove given preset number from corresponding preset list.     As result the
 *   corresponding information "stationStationList" is updated with the given handle
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::stationDeletePreset(const uint32_t &_preset, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->stationDeletePreset(_preset, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::stationDeletePresetAsync(const uint32_t &_preset, const uint32_t &_handle, StationDeletePresetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->stationDeletePresetAsync(_preset, _handle, _callback, _info);
}
/**
 * description: Customize the content and updates of current station and station list
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::audioSetStationUpdateMode(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationUpdateMode &_updateMode, const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_updateMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->audioSetStationUpdateMode(_updateMode, _enable, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::audioSetStationUpdateModeAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::StationUpdateMode &_updateMode, const bool &_enable, const uint32_t &_handle, AudioSetStationUpdateModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_updateMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->audioSetStationUpdateModeAsync(_updateMode, _enable, _handle, _callback, _info);
}
/**
 * description: Enable/disable the announcement monitoring for FM and DAB.    As result the
 *   attribute "announcementCurrentStatus" is updated with the given handle
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::announcementSetConfiguration(const ::v3::com::harman::tuner::OrinocoTunerTypes::AnnouncementConfiguration &_configuration, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->announcementSetConfiguration(_configuration, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::announcementSetConfigurationAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::AnnouncementConfiguration &_configuration, const uint32_t &_handle, AnnouncementSetConfigurationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->announcementSetConfigurationAsync(_configuration, _handle, _callback, _info);
}
/**
 * description: Abort an active announcement. As a result the attribute
 *   "announcementCurrentStatus" is updated with the given handle.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::announcementAbort(const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->announcementAbort(_handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::announcementAbortAsync(const uint32_t &_handle, AnnouncementAbortAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->announcementAbortAsync(_handle, _callback, _info);
}
/**
 * description: [AM/FM only] Set the desired RDS alternative frequency (AF) state. As result
 *   the attribute "amfmControlAfSwitch" is updated.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetAfSwitch(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->amfmControlSetAfSwitch(_enable, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetAfSwitchAsync(const bool &_enable, const uint32_t &_handle, AmfmControlSetAfSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->amfmControlSetAfSwitchAsync(_enable, _handle, _callback, _info);
}
/**
 * description: [AM/FM only] Set the desired RDS regionalisation (REG) state. As result the
 *   attribute "amfmControlRegSwitch" is updated.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetRegSwitch(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->amfmControlSetRegSwitch(_enable, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetRegSwitchAsync(const bool &_enable, const uint32_t &_handle, AmfmControlSetRegSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->amfmControlSetRegSwitchAsync(_enable, _handle, _callback, _info);
}
/**
 * description: [AM/FM only] Set the desired HD mode. As result the attribute
 *   "amfmControlHdMode" is updated.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetHdMode(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode &_hdMode, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_hdMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->amfmControlSetHdMode(_hdMode, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetHdModeAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdMode &_hdMode, const uint32_t &_handle, AmfmControlSetHdModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_hdMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->amfmControlSetHdModeAsync(_hdMode, _handle, _callback, _info);
}
/**
 * description: [AM/FM only] Set the desired HD ballgame mode. As result the attribute
 *   "amfmControlHdBallgameMode" is updated.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetHdBallgameMode(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdBallgameMode &_hdBallgameMode, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_hdBallgameMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->amfmControlSetHdBallgameMode(_hdBallgameMode, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::amfmControlSetHdBallgameModeAsync(const ::v3::com::harman::tuner::OrinocoTunerTypes::AmFmHdBallgameMode &_hdBallgameMode, const uint32_t &_handle, AmfmControlSetHdBallgameModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_hdBallgameMode.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->amfmControlSetHdBallgameModeAsync(_hdBallgameMode, _handle, _callback, _info);
}
/**
 * description: Set the desired service following at the FollowingMaster. As result the
 *   attribute "dabControlFollowingSwitch" is updated with the given handle.   
 *   Note: This switch only affects DAB/FM linking, DAB/DAB is always on
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::dabControlSetFollowingSwitch(const bool &_enable, const uint32_t &_handle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->dabControlSetFollowingSwitch(_enable, _handle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::dabControlSetFollowingSwitchAsync(const bool &_enable, const uint32_t &_handle, DabControlSetFollowingSwitchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->dabControlSetFollowingSwitchAsync(_enable, _handle, _callback, _info);
}
/**
 * description: Request initial broadcast update at startup (stationCurrentStation,
 *   stationStationList) in order to force an "on change" update.
 */
template <typename ... _AttributeExtensions>
void OrinocoTunerProxy<_AttributeExtensions...>::forceBroadcastUpdate(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->forceBroadcastUpdate(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> OrinocoTunerProxy<_AttributeExtensions...>::forceBroadcastUpdateAsync(ForceBroadcastUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->forceBroadcastUpdateAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &OrinocoTunerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool OrinocoTunerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool OrinocoTunerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& OrinocoTunerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& OrinocoTunerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace tuner
} // namespace harman
} // namespace com
} // namespace v3

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v3::com::harman::tuner::OrinocoTunerProxy,
    _AttributeExtension> {
    typedef typename ::v3::com::harman::tuner::OrinocoTunerProxy<
            ::v3::com::harman::tuner::OrinocoTunerExtensions::StationListSortingModeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AudioStationUpdateModeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AudioCurrentStationAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AudioStationListAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AudioPresetListAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AnnouncementCurrentStatusAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AmfmControlRegionInfoAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AmfmControlAfSwitchAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AmfmControlRegSwitchAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AmfmControlHdBallgameModeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::AmfmControlHdModeAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::DabControlRegionInfoAttributeExtension<_AttributeExtension>, 
            ::v3::com::harman::tuner::OrinocoTunerExtensions::DabControlFollowingSwitchAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v3_0 = v3;

#endif // V3_COM_HARMAN_TUNER_Orinoco_Tuner_PROXY_HPP_
