/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_AUDIOPRES_PLUGIN_Tata_Audio_Pres_Plugin_PROXY_HPP_
#define V0_COM_HARMAN_AUDIOPRES_PLUGIN_Tata_Audio_Pres_Plugin_PROXY_HPP_

#include <v0/com/harman/audiopres/plugin/TataAudioPresPluginProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace audiopres {
namespace plugin {

template <typename ... _AttributeExtensions>
class TataAudioPresPluginProxy
    : virtual public TataAudioPresPlugin, 
      virtual public TataAudioPresPluginProxyBase,
      virtual public _AttributeExtensions... {
public:
    TataAudioPresPluginProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~TataAudioPresPluginProxy();

    typedef TataAudioPresPlugin InterfaceType;


    /**
     * description: Attribute holding startUp volume 		This will be changed by HMI by calling
     *   setStarUpVolume API with user selected startup volume.
     */
    /**
     * Returns the wrapper class that provides access to the attribute startupVolume.
     */
    virtual StartupVolumeAttribute& getStartupVolumeAttribute() {
        return delegate_->getStartupVolumeAttribute();
    }
    /**
     * description: Attribute holding SDVC state. 		This will be changed by HMI by calling
     *   setSDVCState API for setting SDVC functionality. It can be set to ON or OFF
     */
    /**
     * Returns the wrapper class that provides access to the attribute sdvcState.
     */
    virtual SdvcStateAttribute& getSdvcStateAttribute() {
        return delegate_->getSdvcStateAttribute();
    }
    /**
     * description: Attribute holding Aux In Gain settings 		This will be changed by HMI by calling
     *   setAuxInGain API for setting Aux In gain settings.
     */
    /**
     * Returns the wrapper class that provides access to the attribute auxInGain.
     */
    virtual AuxInGainAttribute& getAuxInGainAttribute() {
        return delegate_->getAuxInGainAttribute();
    }
    /**
     * description: Attribute holding PDC Mix Mode 		This will be changed by HMI by calling
     *   setPdcMixMode API for enabling - disabling PDC Mix Mode
     */
    /**
     * Returns the wrapper class that provides access to the attribute pdcMixMode.
     */
    virtual PdcMixModeAttribute& getPdcMixModeAttribute() {
        return delegate_->getPdcMixModeAttribute();
    }
    /**
     * description: Attribute holding PDC Mix Mode 		This will be changed by HMI by calling
     *   setPdcMixMode API for enabling - disabling PDC Mix Mode
     */
    /**
     * Returns the wrapper class that provides access to the attribute voiceAlertStatus.
     */
    virtual VoiceAlertStatusAttribute& getVoiceAlertStatusAttribute() {
        return delegate_->getVoiceAlertStatusAttribute();
    }
    /**
     * description: Attribute holding Aux connection state
     */
    /**
     * Returns the wrapper class that provides access to the attribute auxConnectionState.
     */
    virtual AuxConnectionStateAttribute& getAuxConnectionStateAttribute() {
        return delegate_->getAuxConnectionStateAttribute();
    }
    /**
     * description: Attribute holding USB connection State
     */
    /**
     * Returns the wrapper class that provides access to the attribute usbConnectionState.
     */
    virtual UsbConnectionStateAttribute& getUsbConnectionStateAttribute() {
        return delegate_->getUsbConnectionStateAttribute();
    }
    /**
     * description: Attribute holding Ipod connection state
     */
    /**
     * Returns the wrapper class that provides access to the attribute ipodConnectionState.
     */
    virtual IpodConnectionStateAttribute& getIpodConnectionStateAttribute() {
        return delegate_->getIpodConnectionStateAttribute();
    }
    /**
     * description: Attribute holding notification volume level
     */
    /**
     * Returns the wrapper class that provides access to the attribute notificationVolume.
     */
    virtual NotificationVolumeAttribute& getNotificationVolumeAttribute() {
        return delegate_->getNotificationVolumeAttribute();
    }

    /**
     * description: Notification of source state 	Ex : Source X : State : Connecting / Connected /
     *   Disconnecting / Disconnected / Suspended 	This will be helpful in cases where
     *   where HMI wanted to know status of source
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sourceState.
     */
    virtual SourceStateEvent& getSourceStateEvent() {
        return delegate_->getSourceStateEvent();
    }

    /**
     * description: This method is used to set audio entertainment sources
     * Calls SetStartupVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetStartupVolume(const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetStartupVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetStartupVolumeAsync(const uint16_t &_volume, SetStartupVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set SDVC state ON-OFF
     * Calls SetSDVCState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetSDVCState(const bool &_sdvcState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetSDVCState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetSDVCStateAsync(const bool &_sdvcState, SetSDVCStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set Aux In gain values
     * Calls SetAuxInGain with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetAuxInGain(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains &_auxInGain, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetAuxInGain with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetAuxInGainAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains &_auxInGain, SetAuxInGainAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set PDC Mix mode status
     * Calls SetPdcMixMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetPdcMixMode(const bool &_mixMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetPdcMixMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetPdcMixModeAsync(const bool &_mixMode, SetPdcMixModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to play eBeepTypes beep
     * Calls PlayBeep with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void PlayBeep(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes &_beepType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls PlayBeep with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> PlayBeepAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes &_beepType, PlayBeepAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to Activate Audio Source
     * Calls activateSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void activateSource(const uint16_t &_sourceId, const uint16_t &_type, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls activateSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> activateSourceAsync(const uint16_t &_sourceId, const uint16_t &_type, ActivateSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to deactivate Audio Source
     * Calls deactivateSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deactivateSource(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deactivateSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deactivateSourceAsync(const uint16_t &_sourceId, DeactivateSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to play Voice Alert
     * Calls playVoiceAlert with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void playVoiceAlert(const uint16_t &_sourceId, const uint16_t &_id, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls playVoiceAlert with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> playVoiceAlertAsync(const uint16_t &_sourceId, const uint16_t &_id, PlayVoiceAlertAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to cancel Voice Alert
     * Calls cancelVoiceAlert with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelVoiceAlert(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls cancelVoiceAlert with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> cancelVoiceAlertAsync(const uint16_t &_sourceId, CancelVoiceAlertAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to make Sink audio ON-OFF
     * Calls SetAudioOff with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetAudioOff(const bool &_audioState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetAudioOff with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetAudioOffAsync(const bool &_audioState, SetAudioOffAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to reset Audio Settings
     * Calls AudioFactoryReset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void AudioFactoryReset(const uint16_t &_type, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AudioFactoryReset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> AudioFactoryResetAsync(const uint16_t &_type, AudioFactoryResetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle entertianment source in the order specified in
     *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
     *   toggleNextPreviousStrategy with value is defined , method return an error
     *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
     *   entertainment sources in a project 	(at)attribute update activeAudioSource and
     *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
     * Calls ToggleEntertainmentSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleEntertainmentSource(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ToggleEntertainmentSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ToggleEntertainmentSourceAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection &_direction, ToggleEntertainmentSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle mute status of currently playing sources as per
     *   TML mute strategy 	(at)attribute update ActiveSrcMute
     * Calls PlayFromSourceGroup with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void PlayFromSourceGroup(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup &_srcGroupId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls PlayFromSourceGroup with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> PlayFromSourceGroupAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup &_srcGroupId, PlayFromSourceGroupAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to toggle mute status of currently playing sources as per
     *   TML mute strategy 	(at)attribute update ActiveSrcMute
     * Calls ToggleSystemMute with Fire&Forget semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleSystemMute(CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to toggle mute status of currently playing sources as per
     *   TML mute strategy 	(at)attribute update ActiveSrcMute
     * Calls ToggleMute with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ToggleMute(const bool &_userInitiated, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This method is used to get source state from Audiomanager 	This will be helpful
     *   in cases where where HMI wanted to know status of source
     * Calls GetSourceState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetSourceState(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e &_srcState, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetSourceState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetSourceStateAsync(const uint16_t &_sourceId, GetSourceStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to get source state from Audiomanager 	This will be helpful
     *   in cases where where HMI wanted to know status of source
     * Calls GetSourceStateList with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetSourceStateList(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L &_srcStateList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetSourceStateList with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetSourceStateListAsync(GetSourceStateListAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to switch to previous entertainment source from playback
     *   list 	(at)attribute update activeAudioSource and activeEntSrc if a source
     *   switch has happened	 	(at)return eAudioPresErrors
     * Calls SwitchToPreviousEntSource with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SwitchToPreviousEntSource(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SwitchToPreviousEntSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SwitchToPreviousEntSourceAsync(SwitchToPreviousEntSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to register device connection State 		This is mainly used
     *   for USB and IPOD device. Can be extended in futher for other devices
     *   	(at)return eAudioPresErrors
     * Calls deviceConnectionState with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deviceConnectionState(const uint16_t &_sourceId, const std::string &_connectionState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deviceConnectionState with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deviceConnectionStateAsync(const uint16_t &_sourceId, const std::string &_connectionState, DeviceConnectionStateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set notification volume
     * Calls SetNotificationVolume with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetNotificationVolume(const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetNotificationVolume with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetNotificationVolumeAsync(const uint16_t &_volume, SetNotificationVolumeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<TataAudioPresPluginProxyBase> delegate_;
};

typedef TataAudioPresPluginProxy<> TataAudioPresPluginProxyDefault;

namespace TataAudioPresPluginExtensions {
    /**
     * description: Attribute holding startUp volume 		This will be changed by HMI by calling
     *   setStarUpVolume API with user selected startup volume.
     */
    template <template <typename > class _ExtensionType>
    class StartupVolumeAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::StartupVolumeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::StartupVolumeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        StartupVolumeAttributeExtension() {}
    #endif
    
        StartupVolumeAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getStartupVolumeAttribute()) {
        }
    
        inline extension_type& getStartupVolumeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding SDVC state. 		This will be changed by HMI by calling
     *   setSDVCState API for setting SDVC functionality. It can be set to ON or OFF
     */
    template <template <typename > class _ExtensionType>
    class SdvcStateAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::SdvcStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::SdvcStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SdvcStateAttributeExtension() {}
    #endif
    
        SdvcStateAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getSdvcStateAttribute()) {
        }
    
        inline extension_type& getSdvcStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Aux In Gain settings 		This will be changed by HMI by calling
     *   setAuxInGain API for setting Aux In gain settings.
     */
    template <template <typename > class _ExtensionType>
    class AuxInGainAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::AuxInGainAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::AuxInGainAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AuxInGainAttributeExtension() {}
    #endif
    
        AuxInGainAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getAuxInGainAttribute()) {
        }
    
        inline extension_type& getAuxInGainAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding PDC Mix Mode 		This will be changed by HMI by calling
     *   setPdcMixMode API for enabling - disabling PDC Mix Mode
     */
    template <template <typename > class _ExtensionType>
    class PdcMixModeAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::PdcMixModeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::PdcMixModeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        PdcMixModeAttributeExtension() {}
    #endif
    
        PdcMixModeAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getPdcMixModeAttribute()) {
        }
    
        inline extension_type& getPdcMixModeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding PDC Mix Mode 		This will be changed by HMI by calling
     *   setPdcMixMode API for enabling - disabling PDC Mix Mode
     */
    template <template <typename > class _ExtensionType>
    class VoiceAlertStatusAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::VoiceAlertStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::VoiceAlertStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        VoiceAlertStatusAttributeExtension() {}
    #endif
    
        VoiceAlertStatusAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getVoiceAlertStatusAttribute()) {
        }
    
        inline extension_type& getVoiceAlertStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Aux connection state
     */
    template <template <typename > class _ExtensionType>
    class AuxConnectionStateAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::AuxConnectionStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::AuxConnectionStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AuxConnectionStateAttributeExtension() {}
    #endif
    
        AuxConnectionStateAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getAuxConnectionStateAttribute()) {
        }
    
        inline extension_type& getAuxConnectionStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding USB connection State
     */
    template <template <typename > class _ExtensionType>
    class UsbConnectionStateAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::UsbConnectionStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::UsbConnectionStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UsbConnectionStateAttributeExtension() {}
    #endif
    
        UsbConnectionStateAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getUsbConnectionStateAttribute()) {
        }
    
        inline extension_type& getUsbConnectionStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding Ipod connection state
     */
    template <template <typename > class _ExtensionType>
    class IpodConnectionStateAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::IpodConnectionStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::IpodConnectionStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        IpodConnectionStateAttributeExtension() {}
    #endif
    
        IpodConnectionStateAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getIpodConnectionStateAttribute()) {
        }
    
        inline extension_type& getIpodConnectionStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute holding notification volume level
     */
    template <template <typename > class _ExtensionType>
    class NotificationVolumeAttributeExtension {
     public:
        typedef _ExtensionType<TataAudioPresPluginProxyBase::NotificationVolumeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TataAudioPresPluginProxyBase::NotificationVolumeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        NotificationVolumeAttributeExtension() {}
    #endif
    
        NotificationVolumeAttributeExtension(TataAudioPresPluginProxyBase& proxy): attributeExtension_(proxy.getNotificationVolumeAttribute()) {
        }
    
        inline extension_type& getNotificationVolumeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace TataAudioPresPluginExtensions

//
// TataAudioPresPluginProxy Implementation
//
template <typename ... _AttributeExtensions>
TataAudioPresPluginProxy<_AttributeExtensions...>::TataAudioPresPluginProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<TataAudioPresPluginProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<TataAudioPresPluginProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
TataAudioPresPluginProxy<_AttributeExtensions...>::~TataAudioPresPluginProxy() {
}

/**
 * description: This method is used to set audio entertainment sources
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SetStartupVolume(const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetStartupVolume(_volume, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SetStartupVolumeAsync(const uint16_t &_volume, SetStartupVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetStartupVolumeAsync(_volume, _callback, _info);
}
/**
 * description: This method is used to set SDVC state ON-OFF
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SetSDVCState(const bool &_sdvcState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetSDVCState(_sdvcState, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SetSDVCStateAsync(const bool &_sdvcState, SetSDVCStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetSDVCStateAsync(_sdvcState, _callback, _info);
}
/**
 * description: This method is used to set Aux In gain values
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SetAuxInGain(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains &_auxInGain, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_auxInGain.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->SetAuxInGain(_auxInGain, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SetAuxInGainAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAuxInGains &_auxInGain, SetAuxInGainAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_auxInGain.validate()) {
        ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->SetAuxInGainAsync(_auxInGain, _callback, _info);
}
/**
 * description: This method is used to set PDC Mix mode status
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SetPdcMixMode(const bool &_mixMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetPdcMixMode(_mixMode, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SetPdcMixModeAsync(const bool &_mixMode, SetPdcMixModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetPdcMixModeAsync(_mixMode, _callback, _info);
}
/**
 * description: This method is used to play eBeepTypes beep
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::PlayBeep(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes &_beepType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_beepType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->PlayBeep(_beepType, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::PlayBeepAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eBeepTypes &_beepType, PlayBeepAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_beepType.validate()) {
        ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->PlayBeepAsync(_beepType, _callback, _info);
}
/**
 * description: This method is used to Activate Audio Source
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::activateSource(const uint16_t &_sourceId, const uint16_t &_type, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->activateSource(_sourceId, _type, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::activateSourceAsync(const uint16_t &_sourceId, const uint16_t &_type, ActivateSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->activateSourceAsync(_sourceId, _type, _callback, _info);
}
/**
 * description: This method is used to deactivate Audio Source
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::deactivateSource(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->deactivateSource(_sourceId, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::deactivateSourceAsync(const uint16_t &_sourceId, DeactivateSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deactivateSourceAsync(_sourceId, _callback, _info);
}
/**
 * description: This method is used to play Voice Alert
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::playVoiceAlert(const uint16_t &_sourceId, const uint16_t &_id, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->playVoiceAlert(_sourceId, _id, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::playVoiceAlertAsync(const uint16_t &_sourceId, const uint16_t &_id, PlayVoiceAlertAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->playVoiceAlertAsync(_sourceId, _id, _callback, _info);
}
/**
 * description: This method is used to cancel Voice Alert
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::cancelVoiceAlert(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->cancelVoiceAlert(_sourceId, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::cancelVoiceAlertAsync(const uint16_t &_sourceId, CancelVoiceAlertAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->cancelVoiceAlertAsync(_sourceId, _callback, _info);
}
/**
 * description: This method is used to make Sink audio ON-OFF
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SetAudioOff(const bool &_audioState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetAudioOff(_audioState, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SetAudioOffAsync(const bool &_audioState, SetAudioOffAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetAudioOffAsync(_audioState, _callback, _info);
}
/**
 * description: This method is used to reset Audio Settings
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::AudioFactoryReset(const uint16_t &_type, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->AudioFactoryReset(_type, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::AudioFactoryResetAsync(const uint16_t &_type, AudioFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->AudioFactoryResetAsync(_type, _callback, _info);
}
/**
 * description: This method is used to toggle entertianment source in the order specified in
 *   "toggleNextPreviousStrategy" in audiopes.cfg 	If no cfg item
 *   toggleNextPreviousStrategy with value is defined , method return an error
 *   	toggleNextPreviousStrategy should be used to capture the toggle sequence of
 *   entertainment sources in a project 	(at)attribute update activeAudioSource and
 *   activeEntSrc if a source switch has happened	 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::ToggleEntertainmentSource(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection &_direction, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->ToggleEntertainmentSource(_direction, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::ToggleEntertainmentSourceAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eToggleEntSrcDirection &_direction, ToggleEntertainmentSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_direction.validate()) {
        ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->ToggleEntertainmentSourceAsync(_direction, _callback, _info);
}
/**
 * description: This method is used to toggle mute status of currently playing sources as per
 *   TML mute strategy 	(at)attribute update ActiveSrcMute
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::PlayFromSourceGroup(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup &_srcGroupId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    if (!_srcGroupId.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->PlayFromSourceGroup(_srcGroupId, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::PlayFromSourceGroupAsync(const ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eSourceGroup &_srcGroupId, PlayFromSourceGroupAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_srcGroupId.validate()) {
        ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->PlayFromSourceGroupAsync(_srcGroupId, _callback, _info);
}
/**
 * description: This method is used to toggle mute status of currently playing sources as per
 *   TML mute strategy 	(at)attribute update ActiveSrcMute
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::ToggleSystemMute(CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->ToggleSystemMute(_internalCallStatus);
}
/**
 * description: This method is used to toggle mute status of currently playing sources as per
 *   TML mute strategy 	(at)attribute update ActiveSrcMute
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::ToggleMute(const bool &_userInitiated, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->ToggleMute(_userInitiated, _internalCallStatus);
}
/**
 * description: This method is used to get source state from Audiomanager 	This will be helpful
 *   in cases where where HMI wanted to know status of source
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::GetSourceState(const uint16_t &_sourceId, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::ConnectionState_e &_srcState, const CommonAPI::CallInfo *_info) {
    delegate_->GetSourceState(_sourceId, _internalCallStatus, _error, _srcState, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::GetSourceStateAsync(const uint16_t &_sourceId, GetSourceStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->GetSourceStateAsync(_sourceId, _callback, _info);
}
/**
 * description: This method is used to get source state from Audiomanager 	This will be helpful
 *   in cases where where HMI wanted to know status of source
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::GetSourceStateList(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::apres_SourceConnectionState_L &_srcStateList, const CommonAPI::CallInfo *_info) {
    delegate_->GetSourceStateList(_internalCallStatus, _error, _srcStateList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::GetSourceStateListAsync(GetSourceStateListAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->GetSourceStateListAsync(_callback, _info);
}
/**
 * description: This method is used to switch to previous entertainment source from playback
 *   list 	(at)attribute update activeAudioSource and activeEntSrc if a source
 *   switch has happened	 	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SwitchToPreviousEntSource(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SwitchToPreviousEntSource(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SwitchToPreviousEntSourceAsync(SwitchToPreviousEntSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SwitchToPreviousEntSourceAsync(_callback, _info);
}
/**
 * description: This method is used to register device connection State 		This is mainly used
 *   for USB and IPOD device. Can be extended in futher for other devices
 *   	(at)return eAudioPresErrors
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::deviceConnectionState(const uint16_t &_sourceId, const std::string &_connectionState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->deviceConnectionState(_sourceId, _connectionState, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::deviceConnectionStateAsync(const uint16_t &_sourceId, const std::string &_connectionState, DeviceConnectionStateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deviceConnectionStateAsync(_sourceId, _connectionState, _callback, _info);
}
/**
 * description: This method is used to set notification volume
 */
template <typename ... _AttributeExtensions>
void TataAudioPresPluginProxy<_AttributeExtensions...>::SetNotificationVolume(const uint16_t &_volume, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::audiopres::plugin::audioPresPluginTypes::eAudioPresPluginErrors &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetNotificationVolume(_volume, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TataAudioPresPluginProxy<_AttributeExtensions...>::SetNotificationVolumeAsync(const uint16_t &_volume, SetNotificationVolumeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetNotificationVolumeAsync(_volume, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &TataAudioPresPluginProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool TataAudioPresPluginProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool TataAudioPresPluginProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& TataAudioPresPluginProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& TataAudioPresPluginProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace plugin
} // namespace audiopres
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v0::com::harman::audiopres::plugin::TataAudioPresPluginProxy,
    _AttributeExtension> {
    typedef typename ::v0::com::harman::audiopres::plugin::TataAudioPresPluginProxy<
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::StartupVolumeAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::SdvcStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::AuxInGainAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::PdcMixModeAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::VoiceAlertStatusAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::AuxConnectionStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::UsbConnectionStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::IpodConnectionStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::audiopres::plugin::TataAudioPresPluginExtensions::NotificationVolumeAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_AUDIOPRES_PLUGIN_Tata_Audio_Pres_Plugin_PROXY_HPP_
