/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_DCIF_Vehicle_Settings_Type_Collection_HPP_
#define V0_COM_HARMAN_DCIF_Vehicle_Settings_Type_Collection_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace dcif {

struct VehicleSettingsTypeCollection {
    
    struct retStatus_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SUCCESS = 0,
            FAILURE = -1
        };
        
        retStatus_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SUCCESS)) {}
        retStatus_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::FAILURE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const retStatus_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const retStatus_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const retStatus_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const retStatus_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const retStatus_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const retStatus_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct vehicleSettingsTypes_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            USER_CUSTOMIZATION_SETTINGS = 0,
            AMBIENT_LIGHT_SETTINGS = 1,
            MOOD_LIGHT_SETTINGS = 2,
            SETTINGS_END = 3
        };
        
        vehicleSettingsTypes_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::USER_CUSTOMIZATION_SETTINGS)) {}
        vehicleSettingsTypes_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::USER_CUSTOMIZATION_SETTINGS):
                case static_cast<int32_t>(Literal::AMBIENT_LIGHT_SETTINGS):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_SETTINGS):
                case static_cast<int32_t>(Literal::SETTINGS_END):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const vehicleSettingsTypes_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const vehicleSettingsTypes_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const vehicleSettingsTypes_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const vehicleSettingsTypes_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const vehicleSettingsTypes_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const vehicleSettingsTypes_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct settingsAttribute_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            UCS_FMH_VALUE = 1,
            UCS_APPROACH_LAMP_VALUE = 2,
            UCS_HORN_REQUEST_VEHICLE_LOCK = 3,
            UCS_VEHICLE_UNLOCK_RKE = 4,
            UCS_VEHICLE_UNLOCK_PKE = 5,
            UCS_DRIVE_AWAY_LOCKING = 6,
            UCS_AUTO_RELOCK_FUNCTION = 7,
            UCS_BCM_FACTORYSETTING_REQUEST = 8,
            UCS_BCM_DRL_ACTIVE_SIGNAL_VAL = 9,
            UCS_END = 10,
            AMBIENT_MODE_SETTINGS = 11,
            AMBIENT_ILLUMINATION_POSSIBLE_LEVELS = 12,
            AMBIENT_ILLUMINATION_SEL_ACTIVE_VAL = 13,
            AMBIENT_LOAD_SETTINGS = 14,
            AMBIENT_END = 15,
            MOOD_LIGHT_MODE_SETTINGS = 16,
            MOOD_LIGHT_ILLUMINATION_SETTINGS = 17,
            MOOD_LIGHT_LOAD_SETTINGS = 18,
            MOOD_LIGHT_LOCATION_SETTINGS = 19,
            MOOD_LIGHT_COLOR_SETTINGS = 20,
            MOOD_LIGHT_END = 21
        };
        
        settingsAttribute_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::UCS_FMH_VALUE)) {}
        settingsAttribute_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::UCS_FMH_VALUE):
                case static_cast<int32_t>(Literal::UCS_APPROACH_LAMP_VALUE):
                case static_cast<int32_t>(Literal::UCS_HORN_REQUEST_VEHICLE_LOCK):
                case static_cast<int32_t>(Literal::UCS_VEHICLE_UNLOCK_RKE):
                case static_cast<int32_t>(Literal::UCS_VEHICLE_UNLOCK_PKE):
                case static_cast<int32_t>(Literal::UCS_DRIVE_AWAY_LOCKING):
                case static_cast<int32_t>(Literal::UCS_AUTO_RELOCK_FUNCTION):
                case static_cast<int32_t>(Literal::UCS_BCM_FACTORYSETTING_REQUEST):
                case static_cast<int32_t>(Literal::UCS_BCM_DRL_ACTIVE_SIGNAL_VAL):
                case static_cast<int32_t>(Literal::UCS_END):
                case static_cast<int32_t>(Literal::AMBIENT_MODE_SETTINGS):
                case static_cast<int32_t>(Literal::AMBIENT_ILLUMINATION_POSSIBLE_LEVELS):
                case static_cast<int32_t>(Literal::AMBIENT_ILLUMINATION_SEL_ACTIVE_VAL):
                case static_cast<int32_t>(Literal::AMBIENT_LOAD_SETTINGS):
                case static_cast<int32_t>(Literal::AMBIENT_END):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_MODE_SETTINGS):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_ILLUMINATION_SETTINGS):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_LOAD_SETTINGS):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_LOCATION_SETTINGS):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_COLOR_SETTINGS):
                case static_cast<int32_t>(Literal::MOOD_LIGHT_END):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const settingsAttribute_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const settingsAttribute_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const settingsAttribute_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const settingsAttribute_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const settingsAttribute_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const settingsAttribute_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ambientLightMode_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AUTO_MODE = 0,
            OFF_MODE = 1,
            ON_MODE = 2,
            RESERVED = 3
        };
        
        ambientLightMode_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AUTO_MODE)) {}
        ambientLightMode_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AUTO_MODE):
                case static_cast<int32_t>(Literal::OFF_MODE):
                case static_cast<int32_t>(Literal::ON_MODE):
                case static_cast<int32_t>(Literal::RESERVED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ambientLightMode_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ambientLightMode_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ambientLightMode_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ambientLightMode_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ambientLightMode_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ambientLightMode_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ambientLightLoadSettings_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SPOT_LED = 0,
            ROOF_LED = 1,
            FOOT_WELL_LED = 2,
            DOOR_POCKET_LED = 3
        };
        
        ambientLightLoadSettings_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SPOT_LED)) {}
        ambientLightLoadSettings_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SPOT_LED):
                case static_cast<int32_t>(Literal::ROOF_LED):
                case static_cast<int32_t>(Literal::FOOT_WELL_LED):
                case static_cast<int32_t>(Literal::DOOR_POCKET_LED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ambientLightLoadSettings_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ambientLightLoadSettings_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ambientLightLoadSettings_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ambientLightLoadSettings_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ambientLightLoadSettings_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ambientLightLoadSettings_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct moodtLightMode_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RESERVED = 0,
            NO_MODE_SELECTION_MODE = 1,
            OFF_ON_MODE = 2,
            AUTO_OFF_ON_MODE = 3
        };
        
        moodtLightMode_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RESERVED)) {}
        moodtLightMode_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RESERVED):
                case static_cast<int32_t>(Literal::NO_MODE_SELECTION_MODE):
                case static_cast<int32_t>(Literal::OFF_ON_MODE):
                case static_cast<int32_t>(Literal::AUTO_OFF_ON_MODE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const moodtLightMode_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const moodtLightMode_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const moodtLightMode_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const moodtLightMode_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const moodtLightMode_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const moodtLightMode_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct moodtLightLocationOrZone_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ALL_AREA = 0,
            FRONT_RH_AREA = 1,
            FRONT_LH_AREA = 2,
            FLOOR_CONSOLE_AREA = 3,
            REAR_AREA = 4
        };
        
        moodtLightLocationOrZone_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ALL_AREA)) {}
        moodtLightLocationOrZone_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ALL_AREA):
                case static_cast<int32_t>(Literal::FRONT_RH_AREA):
                case static_cast<int32_t>(Literal::FRONT_LH_AREA):
                case static_cast<int32_t>(Literal::FLOOR_CONSOLE_AREA):
                case static_cast<int32_t>(Literal::REAR_AREA):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const moodtLightLocationOrZone_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const moodtLightLocationOrZone_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const moodtLightLocationOrZone_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const moodtLightLocationOrZone_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const moodtLightLocationOrZone_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const moodtLightLocationOrZone_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct parkLampAvailability_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            AVAILABLE = 0,
            NOT_AVAILBLE = 1,
            NOT_SUPPORTED = 2,
            NOT_SUPPORTED_SECURITY_POLICY = 3
        };
        
        parkLampAvailability_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::AVAILABLE)) {}
        parkLampAvailability_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::AVAILABLE):
                case static_cast<int32_t>(Literal::NOT_AVAILBLE):
                case static_cast<int32_t>(Literal::NOT_SUPPORTED):
                case static_cast<int32_t>(Literal::NOT_SUPPORTED_SECURITY_POLICY):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const parkLampAvailability_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const parkLampAvailability_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const parkLampAvailability_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const parkLampAvailability_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const parkLampAvailability_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const parkLampAvailability_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct sParkLampStatus : CommonAPI::Struct<bool, parkLampAvailability_enum> {
    	
    	sParkLampStatus() {
    		std::get<0>(values_) = false;
    	}
    	sParkLampStatus(const bool &_value, const parkLampAvailability_enum &_availStatus)
    	{
    		std::get<0>(values_) = _value;
    		std::get<1>(values_) = _availStatus;
    	}
    	inline const bool &getValue() const { return std::get<0>(values_); }
    	inline void setValue(const bool _value) { std::get<0>(values_) = _value; }
    	inline const parkLampAvailability_enum &getAvailStatus() const { return std::get<1>(values_); }
    	inline void setAvailStatus(const parkLampAvailability_enum &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sParkLampStatus& _other) const {
                return (getValue() == _other.getValue() && getAvailStatus() == _other.getAvailStatus());
        }
    	inline bool operator!=(const sParkLampStatus &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct moodtLightColour_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ICE_BLUE = 0,
            COOL_BLUE = 1,
            POLAR_BRIGHT_WHITE = 2,
            IVORY_OFF_WHITE = 3,
            PURPLE = 4,
            ORANGE = 5,
            FLUORESCENT_GREEN = 6,
            RUBY_RED = 7,
            PURPLE_TAUPE = 8,
            HOT_MAGENTA = 9,
            AERO_BLUE = 10,
            TUSCAN_RED = 11,
            GOLD_YELLOW = 12,
            FRENCH_LIME = 13,
            TEAL_GREEN = 14,
            CYAN_BLUE = 15
        };
        
        moodtLightColour_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ICE_BLUE)) {}
        moodtLightColour_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ICE_BLUE):
                case static_cast<int32_t>(Literal::COOL_BLUE):
                case static_cast<int32_t>(Literal::POLAR_BRIGHT_WHITE):
                case static_cast<int32_t>(Literal::IVORY_OFF_WHITE):
                case static_cast<int32_t>(Literal::PURPLE):
                case static_cast<int32_t>(Literal::ORANGE):
                case static_cast<int32_t>(Literal::FLUORESCENT_GREEN):
                case static_cast<int32_t>(Literal::RUBY_RED):
                case static_cast<int32_t>(Literal::PURPLE_TAUPE):
                case static_cast<int32_t>(Literal::HOT_MAGENTA):
                case static_cast<int32_t>(Literal::AERO_BLUE):
                case static_cast<int32_t>(Literal::TUSCAN_RED):
                case static_cast<int32_t>(Literal::GOLD_YELLOW):
                case static_cast<int32_t>(Literal::FRENCH_LIME):
                case static_cast<int32_t>(Literal::TEAL_GREEN):
                case static_cast<int32_t>(Literal::CYAN_BLUE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const moodtLightColour_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const moodtLightColour_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const moodtLightColour_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const moodtLightColour_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const moodtLightColour_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const moodtLightColour_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct factorySettingsType_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CURRENT_SETTINGS = 0,
            RESTORED_FACTORY_SETTINGS = 1
        };
        
        factorySettingsType_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CURRENT_SETTINGS)) {}
        factorySettingsType_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CURRENT_SETTINGS):
                case static_cast<int32_t>(Literal::RESTORED_FACTORY_SETTINGS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const factorySettingsType_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const factorySettingsType_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const factorySettingsType_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const factorySettingsType_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const factorySettingsType_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const factorySettingsType_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct antitheftKeyConfirmation_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            PAIRING_UNSUCCESSFUL = 0,
            PAIRING_SUCCESSFUL = 1,
            PAIRING_INITIATED = 2,
            PAIRING_NOT_REQUIRED = 3
        };
        
        antitheftKeyConfirmation_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::PAIRING_UNSUCCESSFUL)) {}
        antitheftKeyConfirmation_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::PAIRING_UNSUCCESSFUL):
                case static_cast<int32_t>(Literal::PAIRING_SUCCESSFUL):
                case static_cast<int32_t>(Literal::PAIRING_INITIATED):
                case static_cast<int32_t>(Literal::PAIRING_NOT_REQUIRED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const antitheftKeyConfirmation_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const antitheftKeyConfirmation_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const antitheftKeyConfirmation_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const antitheftKeyConfirmation_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const antitheftKeyConfirmation_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const antitheftKeyConfirmation_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct BcmHuCkdState_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NON_CKD_VEHICLE = 0,
            CKD_VEHICLE = 1
        };
        
        BcmHuCkdState_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NON_CKD_VEHICLE)) {}
        BcmHuCkdState_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NON_CKD_VEHICLE):
                case static_cast<int32_t>(Literal::CKD_VEHICLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const BcmHuCkdState_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const BcmHuCkdState_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const BcmHuCkdState_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const BcmHuCkdState_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const BcmHuCkdState_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const BcmHuCkdState_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.dcif.VehicleSettingsTypeCollection";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

}; // struct VehicleSettingsTypeCollection

} // namespace dcif
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for retStatus_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum& retStatus_enum) const {
            return static_cast<int32_t>(retStatus_enum);
        }
    };
    //Hash for vehicleSettingsTypes_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum& vehicleSettingsTypes_enum) const {
            return static_cast<int32_t>(vehicleSettingsTypes_enum);
        }
    };
    //Hash for settingsAttribute_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum& settingsAttribute_enum) const {
            return static_cast<int32_t>(settingsAttribute_enum);
        }
    };
    //Hash for ambientLightMode_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::ambientLightMode_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::ambientLightMode_enum& ambientLightMode_enum) const {
            return static_cast<int32_t>(ambientLightMode_enum);
        }
    };
    //Hash for ambientLightLoadSettings_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::ambientLightLoadSettings_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::ambientLightLoadSettings_enum& ambientLightLoadSettings_enum) const {
            return static_cast<int32_t>(ambientLightLoadSettings_enum);
        }
    };
    //Hash for moodtLightMode_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::moodtLightMode_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::moodtLightMode_enum& moodtLightMode_enum) const {
            return static_cast<int32_t>(moodtLightMode_enum);
        }
    };
    //Hash for moodtLightLocationOrZone_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::moodtLightLocationOrZone_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::moodtLightLocationOrZone_enum& moodtLightLocationOrZone_enum) const {
            return static_cast<int32_t>(moodtLightLocationOrZone_enum);
        }
    };
    //Hash for parkLampAvailability_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::parkLampAvailability_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::parkLampAvailability_enum& parkLampAvailability_enum) const {
            return static_cast<int32_t>(parkLampAvailability_enum);
        }
    };
    //Hash for moodtLightColour_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::moodtLightColour_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::moodtLightColour_enum& moodtLightColour_enum) const {
            return static_cast<int32_t>(moodtLightColour_enum);
        }
    };
    //Hash for factorySettingsType_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::factorySettingsType_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::factorySettingsType_enum& factorySettingsType_enum) const {
            return static_cast<int32_t>(factorySettingsType_enum);
        }
    };
    //Hash for antitheftKeyConfirmation_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::antitheftKeyConfirmation_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::antitheftKeyConfirmation_enum& antitheftKeyConfirmation_enum) const {
            return static_cast<int32_t>(antitheftKeyConfirmation_enum);
        }
    };
    //Hash for BcmHuCkdState_enum
    template<>
    struct hash<::v0::com::harman::dcif::VehicleSettingsTypeCollection::BcmHuCkdState_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::BcmHuCkdState_enum& bcmHuCkdState_enum) const {
            return static_cast<int32_t>(bcmHuCkdState_enum);
        }
    };
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_DCIF_Vehicle_Settings_Type_Collection_HPP_
