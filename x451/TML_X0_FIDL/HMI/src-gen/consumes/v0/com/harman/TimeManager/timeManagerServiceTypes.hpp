/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_TIMEMANAGER_time_Manager_Service_Types_HPP_
#define V0_COM_HARMAN_TIMEMANAGER_time_Manager_Service_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace TimeManager {

struct timeManagerServiceTypes {
    
    struct TM_States : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TMSTATE_IDLE = 1,
            TMSTATE_NORMAL_ON = 2,
            TMSTATE_STANDBY = 3
        };
        
        TM_States() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TMSTATE_IDLE)) {}
        TM_States(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TMSTATE_IDLE):
                case static_cast<int32_t>(Literal::TMSTATE_NORMAL_ON):
                case static_cast<int32_t>(Literal::TMSTATE_STANDBY):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TM_States &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TM_States &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TM_States &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TM_States &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TM_States &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TM_States &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TM_operationalMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TM_OP_PRIORITY_SOURCE = 1,
            TM_OP_ALL_SOURCE = 2,
            TMSTATE_OP_MANUAL = 3
        };
        
        TM_operationalMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TM_OP_PRIORITY_SOURCE)) {}
        TM_operationalMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TM_OP_PRIORITY_SOURCE):
                case static_cast<int32_t>(Literal::TM_OP_ALL_SOURCE):
                case static_cast<int32_t>(Literal::TMSTATE_OP_MANUAL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TM_operationalMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TM_operationalMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TM_operationalMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TM_operationalMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TM_operationalMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TM_operationalMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TM_Format : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TM_FORMAT_12_HR = 1,
            TM_FORMAT_24_HR = 2
        };
        
        TM_Format() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TM_FORMAT_12_HR)) {}
        TM_Format(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TM_FORMAT_12_HR):
                case static_cast<int32_t>(Literal::TM_FORMAT_24_HR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TM_Format &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TM_Format &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TM_Format &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TM_Format &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TM_Format &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TM_Format &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TM_TimePeriod : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TM_PERIOD_NONE = 1,
            TM_PERIOD_AM = 2,
            TM_PERIOD_PM = 3
        };
        
        TM_TimePeriod() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TM_PERIOD_NONE)) {}
        TM_TimePeriod(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TM_PERIOD_NONE):
                case static_cast<int32_t>(Literal::TM_PERIOD_AM):
                case static_cast<int32_t>(Literal::TM_PERIOD_PM):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TM_TimePeriod &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TM_TimePeriod &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TM_TimePeriod &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TM_TimePeriod &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TM_TimePeriod &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TM_TimePeriod &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct tzSign : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            PLUS = 1,
            MINUS = 2,
            NEUTRAL = 3,
            NOTIMEZONE = 4
        };
        
        tzSign() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::PLUS)) {}
        tzSign(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::PLUS):
                case static_cast<int32_t>(Literal::MINUS):
                case static_cast<int32_t>(Literal::NEUTRAL):
                case static_cast<int32_t>(Literal::NOTIMEZONE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const tzSign &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const tzSign &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const tzSign &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const tzSign &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const tzSign &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const tzSign &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct timeZoneOffset : CommonAPI::Struct<tzSign, int8_t, int8_t> {
    	
    	timeZoneOffset() {
    	}
    	timeZoneOffset(const tzSign &_symbol, const int8_t &_hours, const int8_t &_min)
    	{
    		std::get<0>(values_) = _symbol;
    		std::get<1>(values_) = _hours;
    		std::get<2>(values_) = _min;
    	}
    	inline const tzSign &getSymbol() const { return std::get<0>(values_); }
    	inline void setSymbol(const tzSign &_value) { std::get<0>(values_) = _value; }
    	inline const int8_t &getHours() const { return std::get<1>(values_); }
    	inline void setHours(const int8_t &_value) { std::get<1>(values_) = _value; }
    	inline const int8_t &getMin() const { return std::get<2>(values_); }
    	inline void setMin(const int8_t &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const timeZoneOffset& _other) const {
                return (getSymbol() == _other.getSymbol() && getHours() == _other.getHours() && getMin() == _other.getMin());
        }
    	inline bool operator!=(const timeZoneOffset &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct systemTime : CommonAPI::Struct<int16_t, int16_t, int16_t, int16_t, int16_t, int16_t, int16_t, TM_TimePeriod> {
    	
    	systemTime() {
    	}
    	systemTime(const int16_t &_sec, const int16_t &_minute, const int16_t &_hour, const int16_t &_week, const int16_t &_Day, const int16_t &_month, const int16_t &_Year, const TM_TimePeriod &_period)
    	{
    		std::get<0>(values_) = _sec;
    		std::get<1>(values_) = _minute;
    		std::get<2>(values_) = _hour;
    		std::get<3>(values_) = _week;
    		std::get<4>(values_) = _Day;
    		std::get<5>(values_) = _month;
    		std::get<6>(values_) = _Year;
    		std::get<7>(values_) = _period;
    	}
    	inline const int16_t &getSec() const { return std::get<0>(values_); }
    	inline void setSec(const int16_t &_value) { std::get<0>(values_) = _value; }
    	inline const int16_t &getMinute() const { return std::get<1>(values_); }
    	inline void setMinute(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline const int16_t &getHour() const { return std::get<2>(values_); }
    	inline void setHour(const int16_t &_value) { std::get<2>(values_) = _value; }
    	inline const int16_t &getWeek() const { return std::get<3>(values_); }
    	inline void setWeek(const int16_t &_value) { std::get<3>(values_) = _value; }
    	inline const int16_t &getDay() const { return std::get<4>(values_); }
    	inline void setDay(const int16_t &_value) { std::get<4>(values_) = _value; }
    	inline const int16_t &getMonth() const { return std::get<5>(values_); }
    	inline void setMonth(const int16_t &_value) { std::get<5>(values_) = _value; }
    	inline const int16_t &getYear() const { return std::get<6>(values_); }
    	inline void setYear(const int16_t &_value) { std::get<6>(values_) = _value; }
    	inline const TM_TimePeriod &getPeriod() const { return std::get<7>(values_); }
    	inline void setPeriod(const TM_TimePeriod &_value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const systemTime& _other) const {
                return (getSec() == _other.getSec() && getMinute() == _other.getMinute() && getHour() == _other.getHour() && getWeek() == _other.getWeek() && getDay() == _other.getDay() && getMonth() == _other.getMonth() && getYear() == _other.getYear() && getPeriod() == _other.getPeriod());
        }
    	inline bool operator!=(const systemTime &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.TimeManager.timeManagerServiceTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 2);
}

}; // struct timeManagerServiceTypes

} // namespace TimeManager
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for TM_States
    template<>
    struct hash<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States> {
        inline size_t operator()(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States& tM_States) const {
            return static_cast<int32_t>(tM_States);
        }
    };
    //Hash for TM_operationalMode
    template<>
    struct hash<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode> {
        inline size_t operator()(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode& tM_operationalMode) const {
            return static_cast<int32_t>(tM_operationalMode);
        }
    };
    //Hash for TM_Format
    template<>
    struct hash<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format> {
        inline size_t operator()(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format& tM_Format) const {
            return static_cast<int32_t>(tM_Format);
        }
    };
    //Hash for TM_TimePeriod
    template<>
    struct hash<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_TimePeriod> {
        inline size_t operator()(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_TimePeriod& tM_TimePeriod) const {
            return static_cast<int32_t>(tM_TimePeriod);
        }
    };
    //Hash for tzSign
    template<>
    struct hash<::v0::com::harman::TimeManager::timeManagerServiceTypes::tzSign> {
        inline size_t operator()(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::tzSign& tzSign) const {
            return static_cast<int32_t>(tzSign);
        }
    };
}


// Compatibility
namespace v0_2 = v0;

#endif // V0_COM_HARMAN_TIMEMANAGER_time_Manager_Service_Types_HPP_
