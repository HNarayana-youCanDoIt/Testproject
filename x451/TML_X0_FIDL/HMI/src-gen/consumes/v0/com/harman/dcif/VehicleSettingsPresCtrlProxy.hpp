/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_DCIF_Vehicle_Settings_Pres_Ctrl_PROXY_HPP_
#define V0_COM_HARMAN_DCIF_Vehicle_Settings_Pres_Ctrl_PROXY_HPP_

#include <v0/com/harman/dcif/VehicleSettingsPresCtrlProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace dcif {

template <typename ... _AttributeExtensions>
class VehicleSettingsPresCtrlProxy
    : virtual public VehicleSettingsPresCtrl, 
      virtual public VehicleSettingsPresCtrlProxyBase,
      virtual public _AttributeExtensions... {
public:
    VehicleSettingsPresCtrlProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~VehicleSettingsPresCtrlProxy();

    typedef VehicleSettingsPresCtrl InterfaceType;


    /**
     * description: Attribute for ambientLightModeIlluOnHu as  	enbaled/disabled
     */
    /**
     * Returns the wrapper class that provides access to the attribute ambientLightModeIlluOnHu.
     */
    virtual AmbientLightModeIlluOnHuAttribute& getAmbientLightModeIlluOnHuAttribute() {
        return delegate_->getAmbientLightModeIlluOnHuAttribute();
    }
    /**
     * description: attribute for ParkLampStatus
     */
    /**
     * Returns the wrapper class that provides access to the attribute parkLampStatus.
     */
    virtual ParkLampStatusAttribute& getParkLampStatusAttribute() {
        return delegate_->getParkLampStatusAttribute();
    }
    /**
     * description: Attribute for vehicle speed in Km/hr
     */
    /**
     * Returns the wrapper class that provides access to the attribute vehicleSpeed.
     */
    virtual VehicleSpeedAttribute& getVehicleSpeedAttribute() {
        return delegate_->getVehicleSpeedAttribute();
    }
    /**
     * description: Attribute to get BCmPresence
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmPresence.
     */
    virtual BCmPresenceAttribute& getBCmPresenceAttribute() {
        return delegate_->getBCmPresenceAttribute();
    }
    /**
     * description: Attribute to get BCmUCsState
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmUcsState.
     */
    virtual BCmUcsStateAttribute& getBCmUcsStateAttribute() {
        return delegate_->getBCmUcsStateAttribute();
    }
    /**
     * description: Attribute to get BCmAutoRelockState
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmAutoRelockState.
     */
    virtual BCmAutoRelockStateAttribute& getBCmAutoRelockStateAttribute() {
        return delegate_->getBCmAutoRelockStateAttribute();
    }
    /**
     * description: Attribute to get BCmApproachLampState
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmApproachLampState.
     */
    virtual BCmApproachLampStateAttribute& getBCmApproachLampStateAttribute() {
        return delegate_->getBCmApproachLampStateAttribute();
    }
    /**
     * description: Attribute to get BCmDRLState
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmDRLState.
     */
    virtual BCmDRLStateAttribute& getBCmDRLStateAttribute() {
        return delegate_->getBCmDRLStateAttribute();
    }
    /**
     * description: Attribute to get BCmAntitheftFeatureState
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmAntitheftFeatureState.
     */
    virtual BCmAntitheftFeatureStateAttribute& getBCmAntitheftFeatureStateAttribute() {
        return delegate_->getBCmAntitheftFeatureStateAttribute();
    }
    /**
     * description: Attribute to get BcmHuCkdState
     */
    /**
     * Returns the wrapper class that provides access to the attribute BcmHuCkdState.
     */
    virtual BcmHuCkdStateAttribute& getBcmHuCkdStateAttribute() {
        return delegate_->getBcmHuCkdStateAttribute();
    }
    /**
     * description: Attribute to get BCmAntitheftKeyConfirmation
     */
    /**
     * Returns the wrapper class that provides access to the attribute BCmAntitheftKeyConfirmation.
     */
    virtual BCmAntitheftKeyConfirmationAttribute& getBCmAntitheftKeyConfirmationAttribute() {
        return delegate_->getBCmAntitheftKeyConfirmationAttribute();
    }

    /**
     * description: signal to emit the fmhValue
     */
    /**
     * Returns the wrapper class that provides access to the broadcast fmhValue.
     */
    virtual FmhValueEvent& getFmhValueEvent() {
        return delegate_->getFmhValueEvent();
    }
    /**
     * description: signal to emit the approachLampValue
     */
    /**
     * Returns the wrapper class that provides access to the broadcast approachLampValue.
     */
    virtual ApproachLampValueEvent& getApproachLampValueEvent() {
        return delegate_->getApproachLampValueEvent();
    }
    /**
     * description: signal to emit the drlActiveSignalVal
     */
    /**
     * Returns the wrapper class that provides access to the broadcast drlActiveSignalVal.
     */
    virtual DrlActiveSignalValEvent& getDrlActiveSignalValEvent() {
        return delegate_->getDrlActiveSignalValEvent();
    }
    /**
     * description: signal to emit the hornRequestVehicleLock
     */
    /**
     * Returns the wrapper class that provides access to the broadcast hornRequestVehicleLock.
     */
    virtual HornRequestVehicleLockEvent& getHornRequestVehicleLockEvent() {
        return delegate_->getHornRequestVehicleLockEvent();
    }
    /**
     * description: signal to emit the vehicleUnlockRKE
     */
    /**
     * Returns the wrapper class that provides access to the broadcast vehicleUnlockRKE.
     */
    virtual VehicleUnlockRKEEvent& getVehicleUnlockRKEEvent() {
        return delegate_->getVehicleUnlockRKEEvent();
    }
    /**
     * description: signal to emit the vehicleUnlockPKE
     */
    /**
     * Returns the wrapper class that provides access to the broadcast vehicleUnlockPKE.
     */
    virtual VehicleUnlockPKEEvent& getVehicleUnlockPKEEvent() {
        return delegate_->getVehicleUnlockPKEEvent();
    }
    /**
     * description: signal to emit the driveAwayLocking
     */
    /**
     * Returns the wrapper class that provides access to the broadcast driveAwayLocking.
     */
    virtual DriveAwayLockingEvent& getDriveAwayLockingEvent() {
        return delegate_->getDriveAwayLockingEvent();
    }
    /**
     * description: signal to emit the autoRelockfunction
     */
    /**
     * Returns the wrapper class that provides access to the broadcast autoRelockfunction.
     */
    virtual AutoRelockfunctionEvent& getAutoRelockfunctionEvent() {
        return delegate_->getAutoRelockfunctionEvent();
    }
    /**
     * description: signal to emit the bcmFactorySettingRequest
     */
    /**
     * Returns the wrapper class that provides access to the broadcast bcmFactorySettingRequest.
     */
    virtual BcmFactorySettingRequestEvent& getBcmFactorySettingRequestEvent() {
        return delegate_->getBcmFactorySettingRequestEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast huBCmRequestError.
     */
    virtual HuBCmRequestErrorEvent& getHuBCmRequestErrorEvent() {
        return delegate_->getHuBCmRequestErrorEvent();
    }
    /**
     * description: signal to emit the ambientLightLoadSettings 	Below are ambientLightLoadSettings
     *   		SPOT_LED 		ROOF_LED 		FOOT_WELL_LED 		DOOR_POCKET_LED
     */
    /**
     * Returns the wrapper class that provides access to the broadcast ambientLightLoadSettings.
     */
    virtual AmbientLightLoadSettingsEvent& getAmbientLightLoadSettingsEvent() {
        return delegate_->getAmbientLightLoadSettingsEvent();
    }
    /**
     * description: signal to emit the ambLightMode 	Below are ambLightModes 	 		AUTO_MODE = 0
     *   		OFF_MODE = 1 		ON_MODE =2 		RESERVED = 3
     */
    /**
     * Returns the wrapper class that provides access to the broadcast ambLightMode.
     */
    virtual AmbLightModeEvent& getAmbLightModeEvent() {
        return delegate_->getAmbLightModeEvent();
    }
    /**
     * description: signal to emit the ambLightIllumPossibleLevels 	Below are
     *   ambLightIllumPossibleLevels 	 		value               Description 		0           
     *          Reserved 		1                   No intensity variation possible 		2     
     *                Intensity is varied in 2 levels 		3                   Intensity
     *   is varied in 3 levels 		4                   Intensity is varied in 4 levels
     *   		5                   Intensity is varied in 5 levels 		6                  
     *   Reserved 		7                   Reserved
     */
    /**
     * Returns the wrapper class that provides access to the broadcast ambLightIllumPossibleLevels.
     */
    virtual AmbLightIllumPossibleLevelsEvent& getAmbLightIllumPossibleLevelsEvent() {
        return delegate_->getAmbLightIllumPossibleLevelsEvent();
    }
    /**
     * description: signal to emit the ambientLightIllumSelLevels 	Below are
     *   ambientLightIllumSelLevels 	 		value               Description 		0            
     *         Reserved 		1                   Level 1 Intensity 		2                 
     *   	Level 2 Intensity 		3                   Level 3 Intensity 		4                
     *     Level 4 Intensity 		5                   Level 5 Intensity 		6               
     *      Reserved 		7                   Reserved
     */
    /**
     * Returns the wrapper class that provides access to the broadcast ambientLightIllumSelLevels.
     */
    virtual AmbientLightIllumSelLevelsEvent& getAmbientLightIllumSelLevelsEvent() {
        return delegate_->getAmbientLightIllumSelLevelsEvent();
    }
    /**
     * description: signal to emit the moodLightMode 	Below are the moodLightMode 	    RESERVED = 0
     *   		NO_MODE_SELECTION_MODE = 1 		OFF_ON_MODE =2 		AUTO_OFF_ON_MODE = 3
     */
    /**
     * Returns the wrapper class that provides access to the broadcast moodLightMode.
     */
    virtual MoodLightModeEvent& getMoodLightModeEvent() {
        return delegate_->getMoodLightModeEvent();
    }
    /**
     * description: signal to emit the moodLightlluminationLevels
     */
    /**
     * Returns the wrapper class that provides access to the broadcast moodLightlluminationLevels.
     */
    virtual MoodLightlluminationLevelsEvent& getMoodLightlluminationLevelsEvent() {
        return delegate_->getMoodLightlluminationLevelsEvent();
    }
    /**
     * description: signal to emit the moodLightLocationOrZoneSettings 	Below are
     *   moodLightLocationOrZoneSettings 		ALL_AREA = 0 		FRONT_RH_AREA = 1
     *   		FRONT_LH_AREA =2 		FLOOR_CONSOLE_AREA = 3 		REAR_AREA = 4
     */
    /**
     * Returns the wrapper class that provides access to the broadcast moodLightLocationOrZoneSettings.
     */
    virtual MoodLightLocationOrZoneSettingsEvent& getMoodLightLocationOrZoneSettingsEvent() {
        return delegate_->getMoodLightLocationOrZoneSettingsEvent();
    }
    /**
     * description: signal to emit the moodLightColourSettings 	Below are moodLightColourSettings
     *   		ICE_BLUE = 0 		COOL_BLUE = 1 		POLAR_BRIGHT_WHITE = 2 		IVORY_OFF_WHITE = 3
     *   		PURPLE = 4 		ORANGE = 5 		FLUORESCENT_GREEN = 6 		RUBY_RED = 7
     *   		PURPLE_TAUPE = 8 		HOT_MAGENTA = 9 		AERO_BLUE = 10 //A 		TUSCAN_RED = 11
     *   //B 		GOLD_YELLOW = 12 //C 		FRENCH_LIME = 13 //D 		TEAL_GREEN = 14 //E
     *   		CYAN_BLUE = 15 //F
     */
    /**
     * Returns the wrapper class that provides access to the broadcast moodLightColourSettings.
     */
    virtual MoodLightColourSettingsEvent& getMoodLightColourSettingsEvent() {
        return delegate_->getMoodLightColourSettingsEvent();
    }
    /**
     * description: signal to emit the speedLockOut status
     */
    /**
     * Returns the wrapper class that provides access to the broadcast speedLockOut.
     */
    virtual SpeedLockOutEvent& getSpeedLockOutEvent() {
        return delegate_->getSpeedLockOutEvent();
    }

    /**
     * description: method to return type of configuartion done for setttings type.
     * Calls getSettingsTypeConfiguration with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSettingsTypeConfiguration(CommonAPI::CallStatus &_internalCallStatus, VehicleSettingsPresCtrl::settingsTypeConfiguration &_settingsTypeConfiguration_arr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSettingsTypeConfiguration with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSettingsTypeConfigurationAsync(GetSettingsTypeConfigurationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: method to perform BCM Factory Reset.
     * Calls performBcmFactoryReset with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void performBcmFactoryReset(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::factorySettingsType_enum &_factorySettingsType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls performBcmFactoryReset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> performBcmFactoryResetAsync(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::factorySettingsType_enum &_factorySettingsType, PerformBcmFactoryResetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: method to get the attribute value of vehicle settings type 	Below are the
     *   vehicle settings Type 	 	USER_CUSTOMIZATION_SETTINGS 	AMBIENT_LIGHT_SETTINGS
     *   	MOOD_LIGHT_SETTINGS
     * Calls getValue with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getValue(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getValue with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getValueAsync(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, GetValueAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: method method to set the attribute value of vehicle settings type 	Below are
     *   the vehicle settings Type 	 	USER_CUSTOMIZATION_SETTINGS
     *   	AMBIENT_LIGHT_SETTINGS 	MOOD_LIGHT_SETTINGS
     * Calls setValue with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setValue(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, const int16_t &_value, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setValue with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setValueAsync(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, const int16_t &_value, SetValueAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<VehicleSettingsPresCtrlProxyBase> delegate_;
};

typedef VehicleSettingsPresCtrlProxy<> VehicleSettingsPresCtrlProxyDefault;

namespace VehicleSettingsPresCtrlExtensions {
    /**
     * description: Attribute for ambientLightModeIlluOnHu as  	enbaled/disabled
     */
    template <template <typename > class _ExtensionType>
    class AmbientLightModeIlluOnHuAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::AmbientLightModeIlluOnHuAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::AmbientLightModeIlluOnHuAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AmbientLightModeIlluOnHuAttributeExtension() {}
    #endif
    
        AmbientLightModeIlluOnHuAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getAmbientLightModeIlluOnHuAttribute()) {
        }
    
        inline extension_type& getAmbientLightModeIlluOnHuAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: attribute for ParkLampStatus
     */
    template <template <typename > class _ExtensionType>
    class ParkLampStatusAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::ParkLampStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::ParkLampStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ParkLampStatusAttributeExtension() {}
    #endif
    
        ParkLampStatusAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getParkLampStatusAttribute()) {
        }
    
        inline extension_type& getParkLampStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute for vehicle speed in Km/hr
     */
    template <template <typename > class _ExtensionType>
    class VehicleSpeedAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::VehicleSpeedAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::VehicleSpeedAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        VehicleSpeedAttributeExtension() {}
    #endif
    
        VehicleSpeedAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getVehicleSpeedAttribute()) {
        }
    
        inline extension_type& getVehicleSpeedAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmPresence
     */
    template <template <typename > class _ExtensionType>
    class BCmPresenceAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmPresenceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmPresenceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmPresenceAttributeExtension() {}
    #endif
    
        BCmPresenceAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmPresenceAttribute()) {
        }
    
        inline extension_type& getBCmPresenceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmUCsState
     */
    template <template <typename > class _ExtensionType>
    class BCmUcsStateAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmUcsStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmUcsStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmUcsStateAttributeExtension() {}
    #endif
    
        BCmUcsStateAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmUcsStateAttribute()) {
        }
    
        inline extension_type& getBCmUcsStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmAutoRelockState
     */
    template <template <typename > class _ExtensionType>
    class BCmAutoRelockStateAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmAutoRelockStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmAutoRelockStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmAutoRelockStateAttributeExtension() {}
    #endif
    
        BCmAutoRelockStateAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmAutoRelockStateAttribute()) {
        }
    
        inline extension_type& getBCmAutoRelockStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmApproachLampState
     */
    template <template <typename > class _ExtensionType>
    class BCmApproachLampStateAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmApproachLampStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmApproachLampStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmApproachLampStateAttributeExtension() {}
    #endif
    
        BCmApproachLampStateAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmApproachLampStateAttribute()) {
        }
    
        inline extension_type& getBCmApproachLampStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmDRLState
     */
    template <template <typename > class _ExtensionType>
    class BCmDRLStateAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmDRLStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmDRLStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmDRLStateAttributeExtension() {}
    #endif
    
        BCmDRLStateAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmDRLStateAttribute()) {
        }
    
        inline extension_type& getBCmDRLStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmAntitheftFeatureState
     */
    template <template <typename > class _ExtensionType>
    class BCmAntitheftFeatureStateAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmAntitheftFeatureStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmAntitheftFeatureStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmAntitheftFeatureStateAttributeExtension() {}
    #endif
    
        BCmAntitheftFeatureStateAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmAntitheftFeatureStateAttribute()) {
        }
    
        inline extension_type& getBCmAntitheftFeatureStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BcmHuCkdState
     */
    template <template <typename > class _ExtensionType>
    class BcmHuCkdStateAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BcmHuCkdStateAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BcmHuCkdStateAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BcmHuCkdStateAttributeExtension() {}
    #endif
    
        BcmHuCkdStateAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBcmHuCkdStateAttribute()) {
        }
    
        inline extension_type& getBcmHuCkdStateAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to get BCmAntitheftKeyConfirmation
     */
    template <template <typename > class _ExtensionType>
    class BCmAntitheftKeyConfirmationAttributeExtension {
     public:
        typedef _ExtensionType<VehicleSettingsPresCtrlProxyBase::BCmAntitheftKeyConfirmationAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<VehicleSettingsPresCtrlProxyBase::BCmAntitheftKeyConfirmationAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BCmAntitheftKeyConfirmationAttributeExtension() {}
    #endif
    
        BCmAntitheftKeyConfirmationAttributeExtension(VehicleSettingsPresCtrlProxyBase& proxy): attributeExtension_(proxy.getBCmAntitheftKeyConfirmationAttribute()) {
        }
    
        inline extension_type& getBCmAntitheftKeyConfirmationAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace VehicleSettingsPresCtrlExtensions

//
// VehicleSettingsPresCtrlProxy Implementation
//
template <typename ... _AttributeExtensions>
VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::VehicleSettingsPresCtrlProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<VehicleSettingsPresCtrlProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<VehicleSettingsPresCtrlProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::~VehicleSettingsPresCtrlProxy() {
}

/**
 * description: method to return type of configuartion done for setttings type.
 */
template <typename ... _AttributeExtensions>
void VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getSettingsTypeConfiguration(CommonAPI::CallStatus &_internalCallStatus, VehicleSettingsPresCtrl::settingsTypeConfiguration &_settingsTypeConfiguration_arr, const CommonAPI::CallInfo *_info) {
    delegate_->getSettingsTypeConfiguration(_internalCallStatus, _settingsTypeConfiguration_arr, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getSettingsTypeConfigurationAsync(GetSettingsTypeConfigurationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSettingsTypeConfigurationAsync(_callback, _info);
}
/**
 * description: method to perform BCM Factory Reset.
 */
template <typename ... _AttributeExtensions>
void VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::performBcmFactoryReset(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::factorySettingsType_enum &_factorySettingsType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum &_status, const CommonAPI::CallInfo *_info) {
    if (!_factorySettingsType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->performBcmFactoryReset(_factorySettingsType, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::performBcmFactoryResetAsync(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::factorySettingsType_enum &_factorySettingsType, PerformBcmFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_factorySettingsType.validate()) {
        ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum status = ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum::SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, status);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->performBcmFactoryResetAsync(_factorySettingsType, _callback, _info);
}
/**
 * description: method to get the attribute value of vehicle settings type 	Below are the
 *   vehicle settings Type 	 	USER_CUSTOMIZATION_SETTINGS 	AMBIENT_LIGHT_SETTINGS
 *   	MOOD_LIGHT_SETTINGS
 */
template <typename ... _AttributeExtensions>
void VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getValue(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum &_status, const CommonAPI::CallInfo *_info) {
    if (!_typeOfVehicleSettings.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_settingAttributeType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->getValue(_typeOfVehicleSettings, _settingAttributeType, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getValueAsync(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, GetValueAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_typeOfVehicleSettings.validate()) {
        ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum status = ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum::SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, status);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_settingAttributeType.validate()) {
        ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum status = ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum::SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, status);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->getValueAsync(_typeOfVehicleSettings, _settingAttributeType, _callback, _info);
}
/**
 * description: method method to set the attribute value of vehicle settings type 	Below are
 *   the vehicle settings Type 	 	USER_CUSTOMIZATION_SETTINGS
 *   	AMBIENT_LIGHT_SETTINGS 	MOOD_LIGHT_SETTINGS
 */
template <typename ... _AttributeExtensions>
void VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::setValue(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, const int16_t &_value, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum &_status, const CommonAPI::CallInfo *_info) {
    if (!_typeOfVehicleSettings.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_settingAttributeType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setValue(_typeOfVehicleSettings, _settingAttributeType, _value, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::setValueAsync(const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::vehicleSettingsTypes_enum &_typeOfVehicleSettings, const ::v0::com::harman::dcif::VehicleSettingsTypeCollection::settingsAttribute_enum &_settingAttributeType, const int16_t &_value, SetValueAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_typeOfVehicleSettings.validate()) {
        ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum status = ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum::SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, status);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_settingAttributeType.validate()) {
        ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum status = ::v0::com::harman::dcif::VehicleSettingsTypeCollection::retStatus_enum::SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, status);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setValueAsync(_typeOfVehicleSettings, _settingAttributeType, _value, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& VehicleSettingsPresCtrlProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace dcif
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v0::com::harman::dcif::VehicleSettingsPresCtrlProxy,
    _AttributeExtension> {
    typedef typename ::v0::com::harman::dcif::VehicleSettingsPresCtrlProxy<
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::AmbientLightModeIlluOnHuAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::ParkLampStatusAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::VehicleSpeedAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmPresenceAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmUcsStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmAutoRelockStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmApproachLampStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmDRLStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmAntitheftFeatureStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BcmHuCkdStateAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::dcif::VehicleSettingsPresCtrlExtensions::BCmAntitheftKeyConfirmationAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_DCIF_Vehicle_Settings_Pres_Ctrl_PROXY_HPP_
