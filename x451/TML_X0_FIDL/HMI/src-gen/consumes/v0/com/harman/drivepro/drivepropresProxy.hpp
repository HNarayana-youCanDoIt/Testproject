/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_DRIVEPRO_drivepropres_PROXY_HPP_
#define V0_COM_HARMAN_DRIVEPRO_drivepropres_PROXY_HPP_

#include <v0/com/harman/drivepro/drivepropresProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace drivepro {

template <typename ... _AttributeExtensions>
class drivepropresProxy
    : virtual public drivepropres, 
      virtual public drivepropresProxyBase,
      virtual public _AttributeExtensions... {
public:
    drivepropresProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~drivepropresProxy();

    typedef drivepropres InterfaceType;


    /**
     * description: Attribute that specifies the logging type(Internal/USB Logging)
     */
    /**
     * Returns the wrapper class that provides access to the attribute logType.
     */
    virtual LogTypeAttribute& getLogTypeAttribute() {
        return delegate_->getLogTypeAttribute();
    }
    /**
     * description: Attribute to enable/disable the resetAll option on HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute resetAllOptionEnabled.
     */
    virtual ResetAllOptionEnabledAttribute& getResetAllOptionEnabledAttribute() {
        return delegate_->getResetAllOptionEnabledAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute s_DpVersionInfo.
     */
    virtual S_DpVersionInfoAttribute& getS_DpVersionInfoAttribute() {
        return delegate_->getS_DpVersionInfoAttribute();
    }
    /**
     * description: Attribuite for providing the efficiency information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_EfficiencyInfo.
     */
    virtual S_EfficiencyInfoAttribute& getS_EfficiencyInfoAttribute() {
        return delegate_->getS_EfficiencyInfoAttribute();
    }
    /**
     * description: Attribuite for providing the Driving information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_DrivingInfo.
     */
    virtual S_DrivingInfoAttribute& getS_DrivingInfoAttribute() {
        return delegate_->getS_DrivingInfoAttribute();
    }
    /**
     * description: Attribuite for providing the safety information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_SafetyInfo.
     */
    virtual S_SafetyInfoAttribute& getS_SafetyInfoAttribute() {
        return delegate_->getS_SafetyInfoAttribute();
    }
    /**
     * description: Attribuite for providing user profile information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_UserInfo.
     */
    virtual S_UserInfoAttribute& getS_UserInfoAttribute() {
        return delegate_->getS_UserInfoAttribute();
    }
    /**
     * description: Attribuite for providing the EngineRPM information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_EngineRPmInfo.
     */
    virtual S_EngineRPmInfoAttribute& getS_EngineRPmInfoAttribute() {
        return delegate_->getS_EngineRPmInfoAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AcOnOffDrivingTimeInfo.
     */
    virtual S_AcOnOffDrivingTimeInfoAttribute& getS_AcOnOffDrivingTimeInfoAttribute() {
        return delegate_->getS_AcOnOffDrivingTimeInfoAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_ClutchAccPedalUsageInfo.
     */
    virtual S_ClutchAccPedalUsageInfoAttribute& getS_ClutchAccPedalUsageInfoAttribute() {
        return delegate_->getS_ClutchAccPedalUsageInfoAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_BrakingInstRating.
     */
    virtual S_BrakingInstRatingAttribute& getS_BrakingInstRatingAttribute() {
        return delegate_->getS_BrakingInstRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute brakingCumulativeRating.
     */
    virtual BrakingCumulativeRatingAttribute& getBrakingCumulativeRatingAttribute() {
        return delegate_->getBrakingCumulativeRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_BreakingCountPerReqKM.
     */
    virtual S_BreakingCountPerReqKMAttribute& getS_BreakingCountPerReqKMAttribute() {
        return delegate_->getS_BreakingCountPerReqKMAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AccInstRating.
     */
    virtual S_AccInstRatingAttribute& getS_AccInstRatingAttribute() {
        return delegate_->getS_AccInstRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AccCumulativeRating.
     */
    virtual S_AccCumulativeRatingAttribute& getS_AccCumulativeRatingAttribute() {
        return delegate_->getS_AccCumulativeRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AccPedalPosAnalytics.
     */
    virtual S_AccPedalPosAnalyticsAttribute& getS_AccPedalPosAnalyticsAttribute() {
        return delegate_->getS_AccPedalPosAnalyticsAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AvgAccPedalPos.
     */
    virtual S_AvgAccPedalPosAttribute& getS_AvgAccPedalPosAttribute() {
        return delegate_->getS_AvgAccPedalPosAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AccHarshCount.
     */
    virtual S_AccHarshCountAttribute& getS_AccHarshCountAttribute() {
        return delegate_->getS_AccHarshCountAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute etxmnVariant.
     */
    virtual EtxmnVariantAttribute& getEtxmnVariantAttribute() {
        return delegate_->getEtxmnVariantAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute gSInstRating.
     */
    virtual GSInstRatingAttribute& getGSInstRatingAttribute() {
        return delegate_->getGSInstRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_GSCumRating.
     */
    virtual S_GSCumRatingAttribute& getS_GSCumRatingAttribute() {
        return delegate_->getS_GSCumRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_DriveKmTimeVsGearNumberRating.
     */
    virtual S_DriveKmTimeVsGearNumberRatingAttribute& getS_DriveKmTimeVsGearNumberRatingAttribute() {
        return delegate_->getS_DriveKmTimeVsGearNumberRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_DriveKmTimeInIncorrectGear.
     */
    virtual S_DriveKmTimeInIncorrectGearAttribute& getS_DriveKmTimeInIncorrectGearAttribute() {
        return delegate_->getS_DriveKmTimeInIncorrectGearAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_NumberGearShiftsPerRequiredkms.
     */
    virtual S_NumberGearShiftsPerRequiredkmsAttribute& getS_NumberGearShiftsPerRequiredkmsAttribute() {
        return delegate_->getS_NumberGearShiftsPerRequiredkmsAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_TopSpeed.
     */
    virtual S_TopSpeedAttribute& getS_TopSpeedAttribute() {
        return delegate_->getS_TopSpeedAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute driveInstRating.
     */
    virtual DriveInstRatingAttribute& getDriveInstRatingAttribute() {
        return delegate_->getDriveInstRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_DriveCumuRating.
     */
    virtual S_DriveCumuRatingAttribute& getS_DriveCumuRatingAttribute() {
        return delegate_->getS_DriveCumuRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_TimeinDifferentSpeedBands.
     */
    virtual S_TimeinDifferentSpeedBandsAttribute& getS_TimeinDifferentSpeedBandsAttribute() {
        return delegate_->getS_TimeinDifferentSpeedBandsAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_TripDistance.
     */
    virtual S_TripDistanceAttribute& getS_TripDistanceAttribute() {
        return delegate_->getS_TripDistanceAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_TripDuration.
     */
    virtual S_TripDurationAttribute& getS_TripDurationAttribute() {
        return delegate_->getS_TripDurationAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AverageSpeed.
     */
    virtual S_AverageSpeedAttribute& getS_AverageSpeedAttribute() {
        return delegate_->getS_AverageSpeedAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_AverageFuelEconomy.
     */
    virtual S_AverageFuelEconomyAttribute& getS_AverageFuelEconomyAttribute() {
        return delegate_->getS_AverageFuelEconomyAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute overallScoreInstRating.
     */
    virtual OverallScoreInstRatingAttribute& getOverallScoreInstRatingAttribute() {
        return delegate_->getOverallScoreInstRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_SeatBeltPerTime.
     */
    virtual S_SeatBeltPerTimeAttribute& getS_SeatBeltPerTimeAttribute() {
        return delegate_->getS_SeatBeltPerTimeAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_PerTimeWithoutSeatBelt.
     */
    virtual S_PerTimeWithoutSeatBeltAttribute& getS_PerTimeWithoutSeatBeltAttribute() {
        return delegate_->getS_PerTimeWithoutSeatBeltAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_TimeDoorUnlocked.
     */
    virtual S_TimeDoorUnlockedAttribute& getS_TimeDoorUnlockedAttribute() {
        return delegate_->getS_TimeDoorUnlockedAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_ClutchBrakingAtHighSpeed.
     */
    virtual S_ClutchBrakingAtHighSpeedAttribute& getS_ClutchBrakingAtHighSpeedAttribute() {
        return delegate_->getS_ClutchBrakingAtHighSpeedAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_SafetyWarning.
     */
    virtual S_SafetyWarningAttribute& getS_SafetyWarningAttribute() {
        return delegate_->getS_SafetyWarningAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute safetyInstRating.
     */
    virtual SafetyInstRatingAttribute& getSafetyInstRatingAttribute() {
        return delegate_->getSafetyInstRatingAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_TripResetStatus.
     */
    virtual S_TripResetStatusAttribute& getS_TripResetStatusAttribute() {
        return delegate_->getS_TripResetStatusAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_DistUnit.
     */
    virtual S_DistUnitAttribute& getS_DistUnitAttribute() {
        return delegate_->getS_DistUnitAttribute();
    }
    /**
     * description: Attribuite for providing information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute s_FuelUnit.
     */
    virtual S_FuelUnitAttribute& getS_FuelUnitAttribute() {
        return delegate_->getS_FuelUnitAttribute();
    }

    /**
     * Returns the wrapper class that provides access to the broadcast requestStatusSignal.
     */
    virtual RequestStatusSignalEvent& getRequestStatusSignalEvent() {
        return delegate_->getRequestStatusSignalEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast blueScreenDataUpdate.
     */
    virtual BlueScreenDataUpdateEvent& getBlueScreenDataUpdateEvent() {
        return delegate_->getBlueScreenDataUpdateEvent();
    }
    /**
     * Returns the wrapper class that provides access to the broadcast rpmEnableStatusUpdate.
     */
    virtual RpmEnableStatusUpdateEvent& getRpmEnableStatusUpdateEvent() {
        return delegate_->getRpmEnableStatusUpdateEvent();
    }
    /**
     * description: Signal for sending trip type and reset status information to HMI
     */
    /**
     * Returns the wrapper class that provides access to the broadcast tripResetStatus.
     */
    virtual TripResetStatusEvent& getTripResetStatusEvent() {
        return delegate_->getTripResetStatusEvent();
    }

    /**
     * description: Method for Engineering Menu service to perform  	factory reset operation of
     *   drive pro data
     * Calls performDPFactoryReset with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void performDPFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls performDPFactoryReset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> performDPFactoryResetAsync(PerformDPFactoryResetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to reset trip specific  data
     * Calls resetTrip with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void resetTrip(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripTyp, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls resetTrip with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> resetTripAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, ResetTripAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to update the configuration file from the USB
     * Calls updateConfigFile with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateConfigFile(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateConfigFile with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateConfigFileAsync(UpdateConfigFileAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to update the configuration file from the USB
     * Calls updateDpDynamicLib with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateDpDynamicLib(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateDpDynamicLib with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateDpDynamicLibAsync(UpdateDpDynamicLibAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to record trip specific logging
     * Calls setTripLogging with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setTripLogging(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripTyp, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setTripLogging with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setTripLoggingAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, SetTripLoggingAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to read Drive Pro Log level
     * Calls getTripLogging with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getTripLogging(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getTripLogging with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTripLoggingAsync(GetTripLoggingAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to extract the Drive Pro Logs
     * Calls extractDPLogs with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void extractDPLogs(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls extractDPLogs with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> extractDPLogsAsync(ExtractDPLogsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to set Drive Pro Log level
     * Calls setDpLogLevel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setDpLogLevel(const uint32_t &_logLevel, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, uint32_t &_logLvl, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setDpLogLevel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setDpLogLevelAsync(const uint32_t &_logLevel, SetDpLogLevelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to read Drive Pro Log level
     * Calls getDpLogLevel with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDpLogLevel(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, uint32_t &_logLevel, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDpLogLevel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDpLogLevelAsync(GetDpLogLevelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to set Drive Pro Logging Type
     * Calls setDpLoggingType with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setDpLoggingType(const ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingTyp, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setDpLoggingType with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setDpLoggingTypeAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingType, SetDpLoggingTypeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to get Drive Pro Logging Type
     * Calls getDpLoggingType with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDpLoggingType(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingType, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDpLoggingType with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDpLoggingTypeAsync(GetDpLoggingTypeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to subscribe signals for HMI Blue Screen
     * Calls subscribeSignals with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void subscribeSignals(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_sigList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls subscribeSignals with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> subscribeSignalsAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, SubscribeSignalsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to unsubscribe signals for HMI Blue Screen
     * Calls unSubscribeSignals with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void unSubscribeSignals(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_sigList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls unSubscribeSignals with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> unSubscribeSignalsAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, UnSubscribeSignalsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSignaListValue with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSignaListValue(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSignaListValue with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSignaListValueAsync(GetSignaListValueAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getScalingFactor with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getScalingFactor(CommonAPI::CallStatus &_internalCallStatus, double &_scalingFactor, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getScalingFactor with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getScalingFactorAsync(GetScalingFactorAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method to get the Max Rating
     * Calls getMaxRating with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMaxRating(CommonAPI::CallStatus &_internalCallStatus, uint32_t &_maxRating, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMaxRating with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMaxRatingAsync(GetMaxRatingAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<drivepropresProxyBase> delegate_;
};

typedef drivepropresProxy<> drivepropresProxyDefault;

namespace drivepropresExtensions {
    /**
     * description: Attribute that specifies the logging type(Internal/USB Logging)
     */
    template <template <typename > class _ExtensionType>
    class LogTypeAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::LogTypeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::LogTypeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LogTypeAttributeExtension() {}
    #endif
    
        LogTypeAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getLogTypeAttribute()) {
        }
    
        inline extension_type& getLogTypeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribute to enable/disable the resetAll option on HMI
     */
    template <template <typename > class _ExtensionType>
    class ResetAllOptionEnabledAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::ResetAllOptionEnabledAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::ResetAllOptionEnabledAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ResetAllOptionEnabledAttributeExtension() {}
    #endif
    
        ResetAllOptionEnabledAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getResetAllOptionEnabledAttribute()) {
        }
    
        inline extension_type& getResetAllOptionEnabledAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class S_DpVersionInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_DpVersionInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_DpVersionInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_DpVersionInfoAttributeExtension() {}
    #endif
    
        S_DpVersionInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_DpVersionInfoAttribute()) {
        }
    
        inline extension_type& getS_DpVersionInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing the efficiency information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_EfficiencyInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_EfficiencyInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_EfficiencyInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_EfficiencyInfoAttributeExtension() {}
    #endif
    
        S_EfficiencyInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_EfficiencyInfoAttribute()) {
        }
    
        inline extension_type& getS_EfficiencyInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing the Driving information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_DrivingInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_DrivingInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_DrivingInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_DrivingInfoAttributeExtension() {}
    #endif
    
        S_DrivingInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_DrivingInfoAttribute()) {
        }
    
        inline extension_type& getS_DrivingInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing the safety information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_SafetyInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_SafetyInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_SafetyInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_SafetyInfoAttributeExtension() {}
    #endif
    
        S_SafetyInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_SafetyInfoAttribute()) {
        }
    
        inline extension_type& getS_SafetyInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing user profile information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_UserInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_UserInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_UserInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_UserInfoAttributeExtension() {}
    #endif
    
        S_UserInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_UserInfoAttribute()) {
        }
    
        inline extension_type& getS_UserInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing the EngineRPM information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_EngineRPmInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_EngineRPmInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_EngineRPmInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_EngineRPmInfoAttributeExtension() {}
    #endif
    
        S_EngineRPmInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_EngineRPmInfoAttribute()) {
        }
    
        inline extension_type& getS_EngineRPmInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AcOnOffDrivingTimeInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AcOnOffDrivingTimeInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AcOnOffDrivingTimeInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AcOnOffDrivingTimeInfoAttributeExtension() {}
    #endif
    
        S_AcOnOffDrivingTimeInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AcOnOffDrivingTimeInfoAttribute()) {
        }
    
        inline extension_type& getS_AcOnOffDrivingTimeInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_ClutchAccPedalUsageInfoAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_ClutchAccPedalUsageInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_ClutchAccPedalUsageInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_ClutchAccPedalUsageInfoAttributeExtension() {}
    #endif
    
        S_ClutchAccPedalUsageInfoAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_ClutchAccPedalUsageInfoAttribute()) {
        }
    
        inline extension_type& getS_ClutchAccPedalUsageInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_BrakingInstRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_BrakingInstRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_BrakingInstRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_BrakingInstRatingAttributeExtension() {}
    #endif
    
        S_BrakingInstRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_BrakingInstRatingAttribute()) {
        }
    
        inline extension_type& getS_BrakingInstRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class BrakingCumulativeRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::BrakingCumulativeRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::BrakingCumulativeRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BrakingCumulativeRatingAttributeExtension() {}
    #endif
    
        BrakingCumulativeRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getBrakingCumulativeRatingAttribute()) {
        }
    
        inline extension_type& getBrakingCumulativeRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_BreakingCountPerReqKMAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_BreakingCountPerReqKMAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_BreakingCountPerReqKMAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_BreakingCountPerReqKMAttributeExtension() {}
    #endif
    
        S_BreakingCountPerReqKMAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_BreakingCountPerReqKMAttribute()) {
        }
    
        inline extension_type& getS_BreakingCountPerReqKMAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AccInstRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AccInstRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AccInstRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AccInstRatingAttributeExtension() {}
    #endif
    
        S_AccInstRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AccInstRatingAttribute()) {
        }
    
        inline extension_type& getS_AccInstRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AccCumulativeRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AccCumulativeRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AccCumulativeRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AccCumulativeRatingAttributeExtension() {}
    #endif
    
        S_AccCumulativeRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AccCumulativeRatingAttribute()) {
        }
    
        inline extension_type& getS_AccCumulativeRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AccPedalPosAnalyticsAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AccPedalPosAnalyticsAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AccPedalPosAnalyticsAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AccPedalPosAnalyticsAttributeExtension() {}
    #endif
    
        S_AccPedalPosAnalyticsAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AccPedalPosAnalyticsAttribute()) {
        }
    
        inline extension_type& getS_AccPedalPosAnalyticsAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AvgAccPedalPosAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AvgAccPedalPosAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AvgAccPedalPosAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AvgAccPedalPosAttributeExtension() {}
    #endif
    
        S_AvgAccPedalPosAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AvgAccPedalPosAttribute()) {
        }
    
        inline extension_type& getS_AvgAccPedalPosAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AccHarshCountAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AccHarshCountAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AccHarshCountAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AccHarshCountAttributeExtension() {}
    #endif
    
        S_AccHarshCountAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AccHarshCountAttribute()) {
        }
    
        inline extension_type& getS_AccHarshCountAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class EtxmnVariantAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::EtxmnVariantAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::EtxmnVariantAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EtxmnVariantAttributeExtension() {}
    #endif
    
        EtxmnVariantAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getEtxmnVariantAttribute()) {
        }
    
        inline extension_type& getEtxmnVariantAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class GSInstRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::GSInstRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::GSInstRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        GSInstRatingAttributeExtension() {}
    #endif
    
        GSInstRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getGSInstRatingAttribute()) {
        }
    
        inline extension_type& getGSInstRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_GSCumRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_GSCumRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_GSCumRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_GSCumRatingAttributeExtension() {}
    #endif
    
        S_GSCumRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_GSCumRatingAttribute()) {
        }
    
        inline extension_type& getS_GSCumRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_DriveKmTimeVsGearNumberRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_DriveKmTimeVsGearNumberRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_DriveKmTimeVsGearNumberRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_DriveKmTimeVsGearNumberRatingAttributeExtension() {}
    #endif
    
        S_DriveKmTimeVsGearNumberRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_DriveKmTimeVsGearNumberRatingAttribute()) {
        }
    
        inline extension_type& getS_DriveKmTimeVsGearNumberRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_DriveKmTimeInIncorrectGearAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_DriveKmTimeInIncorrectGearAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_DriveKmTimeInIncorrectGearAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_DriveKmTimeInIncorrectGearAttributeExtension() {}
    #endif
    
        S_DriveKmTimeInIncorrectGearAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_DriveKmTimeInIncorrectGearAttribute()) {
        }
    
        inline extension_type& getS_DriveKmTimeInIncorrectGearAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_NumberGearShiftsPerRequiredkmsAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_NumberGearShiftsPerRequiredkmsAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_NumberGearShiftsPerRequiredkmsAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_NumberGearShiftsPerRequiredkmsAttributeExtension() {}
    #endif
    
        S_NumberGearShiftsPerRequiredkmsAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_NumberGearShiftsPerRequiredkmsAttribute()) {
        }
    
        inline extension_type& getS_NumberGearShiftsPerRequiredkmsAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_TopSpeedAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_TopSpeedAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_TopSpeedAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_TopSpeedAttributeExtension() {}
    #endif
    
        S_TopSpeedAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_TopSpeedAttribute()) {
        }
    
        inline extension_type& getS_TopSpeedAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class DriveInstRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::DriveInstRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::DriveInstRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DriveInstRatingAttributeExtension() {}
    #endif
    
        DriveInstRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getDriveInstRatingAttribute()) {
        }
    
        inline extension_type& getDriveInstRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_DriveCumuRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_DriveCumuRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_DriveCumuRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_DriveCumuRatingAttributeExtension() {}
    #endif
    
        S_DriveCumuRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_DriveCumuRatingAttribute()) {
        }
    
        inline extension_type& getS_DriveCumuRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_TimeinDifferentSpeedBandsAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_TimeinDifferentSpeedBandsAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_TimeinDifferentSpeedBandsAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_TimeinDifferentSpeedBandsAttributeExtension() {}
    #endif
    
        S_TimeinDifferentSpeedBandsAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_TimeinDifferentSpeedBandsAttribute()) {
        }
    
        inline extension_type& getS_TimeinDifferentSpeedBandsAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_TripDistanceAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_TripDistanceAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_TripDistanceAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_TripDistanceAttributeExtension() {}
    #endif
    
        S_TripDistanceAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_TripDistanceAttribute()) {
        }
    
        inline extension_type& getS_TripDistanceAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_TripDurationAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_TripDurationAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_TripDurationAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_TripDurationAttributeExtension() {}
    #endif
    
        S_TripDurationAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_TripDurationAttribute()) {
        }
    
        inline extension_type& getS_TripDurationAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AverageSpeedAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AverageSpeedAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AverageSpeedAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AverageSpeedAttributeExtension() {}
    #endif
    
        S_AverageSpeedAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AverageSpeedAttribute()) {
        }
    
        inline extension_type& getS_AverageSpeedAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_AverageFuelEconomyAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_AverageFuelEconomyAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_AverageFuelEconomyAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_AverageFuelEconomyAttributeExtension() {}
    #endif
    
        S_AverageFuelEconomyAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_AverageFuelEconomyAttribute()) {
        }
    
        inline extension_type& getS_AverageFuelEconomyAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class OverallScoreInstRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::OverallScoreInstRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::OverallScoreInstRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        OverallScoreInstRatingAttributeExtension() {}
    #endif
    
        OverallScoreInstRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getOverallScoreInstRatingAttribute()) {
        }
    
        inline extension_type& getOverallScoreInstRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_SeatBeltPerTimeAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_SeatBeltPerTimeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_SeatBeltPerTimeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_SeatBeltPerTimeAttributeExtension() {}
    #endif
    
        S_SeatBeltPerTimeAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_SeatBeltPerTimeAttribute()) {
        }
    
        inline extension_type& getS_SeatBeltPerTimeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_PerTimeWithoutSeatBeltAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_PerTimeWithoutSeatBeltAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_PerTimeWithoutSeatBeltAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_PerTimeWithoutSeatBeltAttributeExtension() {}
    #endif
    
        S_PerTimeWithoutSeatBeltAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_PerTimeWithoutSeatBeltAttribute()) {
        }
    
        inline extension_type& getS_PerTimeWithoutSeatBeltAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_TimeDoorUnlockedAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_TimeDoorUnlockedAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_TimeDoorUnlockedAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_TimeDoorUnlockedAttributeExtension() {}
    #endif
    
        S_TimeDoorUnlockedAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_TimeDoorUnlockedAttribute()) {
        }
    
        inline extension_type& getS_TimeDoorUnlockedAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_ClutchBrakingAtHighSpeedAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_ClutchBrakingAtHighSpeedAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_ClutchBrakingAtHighSpeedAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_ClutchBrakingAtHighSpeedAttributeExtension() {}
    #endif
    
        S_ClutchBrakingAtHighSpeedAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_ClutchBrakingAtHighSpeedAttribute()) {
        }
    
        inline extension_type& getS_ClutchBrakingAtHighSpeedAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_SafetyWarningAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_SafetyWarningAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_SafetyWarningAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_SafetyWarningAttributeExtension() {}
    #endif
    
        S_SafetyWarningAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_SafetyWarningAttribute()) {
        }
    
        inline extension_type& getS_SafetyWarningAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class SafetyInstRatingAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::SafetyInstRatingAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::SafetyInstRatingAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SafetyInstRatingAttributeExtension() {}
    #endif
    
        SafetyInstRatingAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getSafetyInstRatingAttribute()) {
        }
    
        inline extension_type& getSafetyInstRatingAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_TripResetStatusAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_TripResetStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_TripResetStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_TripResetStatusAttributeExtension() {}
    #endif
    
        S_TripResetStatusAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_TripResetStatusAttribute()) {
        }
    
        inline extension_type& getS_TripResetStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_DistUnitAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_DistUnitAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_DistUnitAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_DistUnitAttributeExtension() {}
    #endif
    
        S_DistUnitAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_DistUnitAttribute()) {
        }
    
        inline extension_type& getS_DistUnitAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attribuite for providing information to HMI
     */
    template <template <typename > class _ExtensionType>
    class S_FuelUnitAttributeExtension {
     public:
        typedef _ExtensionType<drivepropresProxyBase::S_FuelUnitAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<drivepropresProxyBase::S_FuelUnitAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        S_FuelUnitAttributeExtension() {}
    #endif
    
        S_FuelUnitAttributeExtension(drivepropresProxyBase& proxy): attributeExtension_(proxy.getS_FuelUnitAttribute()) {
        }
    
        inline extension_type& getS_FuelUnitAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace drivepropresExtensions

//
// drivepropresProxy Implementation
//
template <typename ... _AttributeExtensions>
drivepropresProxy<_AttributeExtensions...>::drivepropresProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<drivepropresProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<drivepropresProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
drivepropresProxy<_AttributeExtensions...>::~drivepropresProxy() {
}

/**
 * description: Method for Engineering Menu service to perform  	factory reset operation of
 *   drive pro data
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::performDPFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info) {
    delegate_->performDPFactoryReset(_internalCallStatus, _retStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::performDPFactoryResetAsync(PerformDPFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->performDPFactoryResetAsync(_callback, _info);
}
/**
 * description: Method to reset trip specific  data
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::resetTrip(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripTyp, const CommonAPI::CallInfo *_info) {
    if (!_tripType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->resetTrip(_tripType, _internalCallStatus, _retStatus, _tripTyp, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::resetTripAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, ResetTripAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_tripType.validate()) {
        ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus retStatus = ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus::SUCCESS;
        ::v0::com::harman::drivepro::driveProTypeCollection::eTripType tripTyp = ::v0::com::harman::drivepro::driveProTypeCollection::eTripType::TRIP_A;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, retStatus, tripTyp);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->resetTripAsync(_tripType, _callback, _info);
}
/**
 * description: Method to update the configuration file from the USB
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::updateConfigFile(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info) {
    delegate_->updateConfigFile(_internalCallStatus, _retStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::updateConfigFileAsync(UpdateConfigFileAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateConfigFileAsync(_callback, _info);
}
/**
 * description: Method to update the configuration file from the USB
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::updateDpDynamicLib(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info) {
    delegate_->updateDpDynamicLib(_internalCallStatus, _retStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::updateDpDynamicLibAsync(UpdateDpDynamicLibAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateDpDynamicLibAsync(_callback, _info);
}
/**
 * description: Method to record trip specific logging
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::setTripLogging(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripTyp, const CommonAPI::CallInfo *_info) {
    if (!_tripType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setTripLogging(_tripType, _internalCallStatus, _retStatus, _tripTyp, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::setTripLoggingAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, SetTripLoggingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_tripType.validate()) {
        ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus retStatus = ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus::SUCCESS;
        ::v0::com::harman::drivepro::driveProTypeCollection::eTripType tripTyp = ::v0::com::harman::drivepro::driveProTypeCollection::eTripType::TRIP_A;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, retStatus, tripTyp);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setTripLoggingAsync(_tripType, _callback, _info);
}
/**
 * description: Method to read Drive Pro Log level
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::getTripLogging(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eTripType &_tripType, const CommonAPI::CallInfo *_info) {
    delegate_->getTripLogging(_internalCallStatus, _retStatus, _tripType, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::getTripLoggingAsync(GetTripLoggingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getTripLoggingAsync(_callback, _info);
}
/**
 * description: Method to extract the Drive Pro Logs
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::extractDPLogs(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info) {
    delegate_->extractDPLogs(_internalCallStatus, _retStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::extractDPLogsAsync(ExtractDPLogsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->extractDPLogsAsync(_callback, _info);
}
/**
 * description: Method to set Drive Pro Log level
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::setDpLogLevel(const uint32_t &_logLevel, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, uint32_t &_logLvl, const CommonAPI::CallInfo *_info) {
    delegate_->setDpLogLevel(_logLevel, _internalCallStatus, _retStatus, _logLvl, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::setDpLogLevelAsync(const uint32_t &_logLevel, SetDpLogLevelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setDpLogLevelAsync(_logLevel, _callback, _info);
}
/**
 * description: Method to read Drive Pro Log level
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::getDpLogLevel(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, uint32_t &_logLevel, const CommonAPI::CallInfo *_info) {
    delegate_->getDpLogLevel(_internalCallStatus, _retStatus, _logLevel, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::getDpLogLevelAsync(GetDpLogLevelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDpLogLevelAsync(_callback, _info);
}
/**
 * description: Method to set Drive Pro Logging Type
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::setDpLoggingType(const ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingType, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingTyp, const CommonAPI::CallInfo *_info) {
    if (!_loggingType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setDpLoggingType(_loggingType, _internalCallStatus, _retStatus, _loggingTyp, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::setDpLoggingTypeAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingType, SetDpLoggingTypeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_loggingType.validate()) {
        ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus retStatus = ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus::SUCCESS;
        ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType loggingTyp = ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType::LOGGING_INTERNAL;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, retStatus, loggingTyp);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setDpLoggingTypeAsync(_loggingType, _callback, _info);
}
/**
 * description: Method to get Drive Pro Logging Type
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::getDpLoggingType(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eLoggingType &_loggingType, const CommonAPI::CallInfo *_info) {
    delegate_->getDpLoggingType(_internalCallStatus, _retStatus, _loggingType, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::getDpLoggingTypeAsync(GetDpLoggingTypeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDpLoggingTypeAsync(_callback, _info);
}
/**
 * description: Method to subscribe signals for HMI Blue Screen
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::subscribeSignals(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_sigList, const CommonAPI::CallInfo *_info) {
    delegate_->subscribeSignals(_signalList, _internalCallStatus, _retStatus, _sigList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::subscribeSignalsAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, SubscribeSignalsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->subscribeSignalsAsync(_signalList, _callback, _info);
}
/**
 * description: Method to unsubscribe signals for HMI Blue Screen
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::unSubscribeSignals(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_sigList, const CommonAPI::CallInfo *_info) {
    delegate_->unSubscribeSignals(_signalList, _internalCallStatus, _retStatus, _sigList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::unSubscribeSignalsAsync(const ::v0::com::harman::drivepro::driveProTypeCollection::signalArray &_signalList, UnSubscribeSignalsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->unSubscribeSignalsAsync(_signalList, _callback, _info);
}
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::getSignaListValue(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info) {
    delegate_->getSignaListValue(_internalCallStatus, _retStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::getSignaListValueAsync(GetSignaListValueAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSignaListValueAsync(_callback, _info);
}
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::getScalingFactor(CommonAPI::CallStatus &_internalCallStatus, double &_scalingFactor, const CommonAPI::CallInfo *_info) {
    delegate_->getScalingFactor(_internalCallStatus, _scalingFactor, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::getScalingFactorAsync(GetScalingFactorAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getScalingFactorAsync(_callback, _info);
}
/**
 * description: Method to get the Max Rating
 */
template <typename ... _AttributeExtensions>
void drivepropresProxy<_AttributeExtensions...>::getMaxRating(CommonAPI::CallStatus &_internalCallStatus, uint32_t &_maxRating, ::v0::com::harman::drivepro::driveProTypeCollection::eReturnStatus &_retStatus, const CommonAPI::CallInfo *_info) {
    delegate_->getMaxRating(_internalCallStatus, _maxRating, _retStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> drivepropresProxy<_AttributeExtensions...>::getMaxRatingAsync(GetMaxRatingAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getMaxRatingAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &drivepropresProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool drivepropresProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool drivepropresProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& drivepropresProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& drivepropresProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace drivepro
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v0::com::harman::drivepro::drivepropresProxy,
    _AttributeExtension> {
    typedef typename ::v0::com::harman::drivepro::drivepropresProxy<
            ::v0::com::harman::drivepro::drivepropresExtensions::LogTypeAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::ResetAllOptionEnabledAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_DpVersionInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_EfficiencyInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_DrivingInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_SafetyInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_UserInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_EngineRPmInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AcOnOffDrivingTimeInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_ClutchAccPedalUsageInfoAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_BrakingInstRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::BrakingCumulativeRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_BreakingCountPerReqKMAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AccInstRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AccCumulativeRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AccPedalPosAnalyticsAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AvgAccPedalPosAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AccHarshCountAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::EtxmnVariantAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::GSInstRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_GSCumRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_DriveKmTimeVsGearNumberRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_DriveKmTimeInIncorrectGearAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_NumberGearShiftsPerRequiredkmsAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_TopSpeedAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::DriveInstRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_DriveCumuRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_TimeinDifferentSpeedBandsAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_TripDistanceAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_TripDurationAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AverageSpeedAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_AverageFuelEconomyAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::OverallScoreInstRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_SeatBeltPerTimeAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_PerTimeWithoutSeatBeltAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_TimeDoorUnlockedAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_ClutchBrakingAtHighSpeedAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_SafetyWarningAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::SafetyInstRatingAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_TripResetStatusAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_DistUnitAttributeExtension<_AttributeExtension>, 
            ::v0::com::harman::drivepro::drivepropresExtensions::S_FuelUnitAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_DRIVEPRO_drivepropres_PROXY_HPP_
