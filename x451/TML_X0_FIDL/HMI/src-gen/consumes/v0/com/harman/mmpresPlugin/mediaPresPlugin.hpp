/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_MMPRESPLUGIN_MEDIA_PRES_PLUGIN_HPP_
#define V0_COM_HARMAN_MMPRESPLUGIN_MEDIA_PRES_PLUGIN_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <unordered_map>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace mmpresPlugin {

class mediaPresPlugin {
public:
    virtual ~mediaPresPlugin() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct eCallResult : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            CALLRESULT_OK = 0,
            CALLRESULT_CANCELLED_USER_REQUEST = 1,
            CALLRESULT_BAD_PARAMETER = 2,
            CALLRESULT_FAILED_MEDIUM_REMOVED = 3,
            CALLRESULT_FAILED_INTERNALERROR = 4,
            CALLRESULT_FAILED_NORES = 5
        };
        
        eCallResult() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::CALLRESULT_OK)) {}
        eCallResult(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::CALLRESULT_OK):
                case static_cast<int32_t>(Literal::CALLRESULT_CANCELLED_USER_REQUEST):
                case static_cast<int32_t>(Literal::CALLRESULT_BAD_PARAMETER):
                case static_cast<int32_t>(Literal::CALLRESULT_FAILED_MEDIUM_REMOVED):
                case static_cast<int32_t>(Literal::CALLRESULT_FAILED_INTERNALERROR):
                case static_cast<int32_t>(Literal::CALLRESULT_FAILED_NORES):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eCallResult &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eCallResult &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eCallResult &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eCallResult &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eCallResult &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eCallResult &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eUsbDeviceError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            USB_DEVICE_NO_ERROR = 0,
            USB_DEVICE_UNSUPPORTED = 1,
            USB_DEVICE_HUB_UNSUPPORTED = 2,
            USB_DEVICE_NO_RESPONSE = 3,
            MEDIAERROR_UNKNOWN = 4
        };
        
        eUsbDeviceError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::USB_DEVICE_NO_ERROR)) {}
        eUsbDeviceError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::USB_DEVICE_NO_ERROR):
                case static_cast<int32_t>(Literal::USB_DEVICE_UNSUPPORTED):
                case static_cast<int32_t>(Literal::USB_DEVICE_HUB_UNSUPPORTED):
                case static_cast<int32_t>(Literal::USB_DEVICE_NO_RESPONSE):
                case static_cast<int32_t>(Literal::MEDIAERROR_UNKNOWN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eUsbDeviceError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eUsbDeviceError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eUsbDeviceError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eUsbDeviceError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eUsbDeviceError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eUsbDeviceError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eUsbPlaybackMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            USB_PLAYBACK_FOLDER_MODE = 0,
            USB_PLAYBACK_TRACK_MODE = 1
        };
        
        eUsbPlaybackMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::USB_PLAYBACK_FOLDER_MODE)) {}
        eUsbPlaybackMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::USB_PLAYBACK_FOLDER_MODE):
                case static_cast<int32_t>(Literal::USB_PLAYBACK_TRACK_MODE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eUsbPlaybackMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eUsbPlaybackMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eUsbPlaybackMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eUsbPlaybackMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eUsbPlaybackMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eUsbPlaybackMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eAvailabilityStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DEFAULT = 0,
            NOT_AVAILABLE = 1,
            AVAILABLE = 2
        };
        
        eAvailabilityStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DEFAULT)) {}
        eAvailabilityStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DEFAULT):
                case static_cast<int32_t>(Literal::NOT_AVAILABLE):
                case static_cast<int32_t>(Literal::AVAILABLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eAvailabilityStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eAvailabilityStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eAvailabilityStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eAvailabilityStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eAvailabilityStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eAvailabilityStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eMediaError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MEDIAERROR_NO_ERROR = 0,
            MEDIAERROR_INVALIDPARAMATERS = 1,
            MEDIAERROR_WRONGSTATE = 2,
            MEDIAERROR_FSUNSUPPORTED = 3,
            MEDIAERROR_FILES_SKIPPED = 4,
            MEDIAERROR_BUSY = 5,
            MEDIAERROR_NO_MEMORY = 6,
            MEDIAERROR_CORRUPTED = 7,
            MEDIAERROR_BADPLAYLIST = 8,
            MEDIAERROR_BACKEND_UNREACHABLE = 9,
            MEDIAERROR_DRM = 10,
            MEDIAERROR_COMMUNICATION = 11,
            MEDIAERROR_FILEUNAVAILABLE = 12,
            MEDIAERROR_FILENOTEXIST = 13,
            MEDIAERROR_FILECORRUPT = 14,
            MEDIAERROR_NO_PERMISSION = 15,
            MEDIAERROR_READ_ERROR = 16,
            MEDIAERROR_MOUNT_ERROR = 17,
            MEDIAERROR_UMOUNT_ERROR = 18,
            MEDIAERROR_MEDIUM_REMOVED = 19,
            MEDIAERROR_MECHANICAL_ERROR = 20,
            MEDIAERROR_PARTITION_ERROR = 21,
            MEDIAERROR_FILESYSTEM_FORMAT_ERROR = 22,
            MEDIAERROR_FILESYSTEM_FORMAT_UNSUPPORTED = 23,
            MEDIAERROR_AUDIOLANGUAGE_INVALID = 24,
            MEDIAERROR_SUBTITLE_INVALID = 25,
            MEDIAERROR_SUBTITLE_UNAVAILABLE = 26,
            MEDIAERROR_VIDEO_UNAVAILABLE = 27,
            MEDIAERROR_UNSUPPORTED = 28,
            MEDIAERROR_UNKNOWN = 29,
            MEDIAERROR_FOLDERNOTEXIST = 30,
            MEDIAERROR_AUDIOCORRUPT = 31,
            MEDIAERROR_VIDEOCORRUPT = 32
        };
        
        eMediaError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MEDIAERROR_NO_ERROR)) {}
        eMediaError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MEDIAERROR_NO_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_INVALIDPARAMATERS):
                case static_cast<int32_t>(Literal::MEDIAERROR_WRONGSTATE):
                case static_cast<int32_t>(Literal::MEDIAERROR_FSUNSUPPORTED):
                case static_cast<int32_t>(Literal::MEDIAERROR_FILES_SKIPPED):
                case static_cast<int32_t>(Literal::MEDIAERROR_BUSY):
                case static_cast<int32_t>(Literal::MEDIAERROR_NO_MEMORY):
                case static_cast<int32_t>(Literal::MEDIAERROR_CORRUPTED):
                case static_cast<int32_t>(Literal::MEDIAERROR_BADPLAYLIST):
                case static_cast<int32_t>(Literal::MEDIAERROR_BACKEND_UNREACHABLE):
                case static_cast<int32_t>(Literal::MEDIAERROR_DRM):
                case static_cast<int32_t>(Literal::MEDIAERROR_COMMUNICATION):
                case static_cast<int32_t>(Literal::MEDIAERROR_FILEUNAVAILABLE):
                case static_cast<int32_t>(Literal::MEDIAERROR_FILENOTEXIST):
                case static_cast<int32_t>(Literal::MEDIAERROR_FILECORRUPT):
                case static_cast<int32_t>(Literal::MEDIAERROR_NO_PERMISSION):
                case static_cast<int32_t>(Literal::MEDIAERROR_READ_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_MOUNT_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_UMOUNT_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_MEDIUM_REMOVED):
                case static_cast<int32_t>(Literal::MEDIAERROR_MECHANICAL_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_PARTITION_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_FILESYSTEM_FORMAT_ERROR):
                case static_cast<int32_t>(Literal::MEDIAERROR_FILESYSTEM_FORMAT_UNSUPPORTED):
                case static_cast<int32_t>(Literal::MEDIAERROR_AUDIOLANGUAGE_INVALID):
                case static_cast<int32_t>(Literal::MEDIAERROR_SUBTITLE_INVALID):
                case static_cast<int32_t>(Literal::MEDIAERROR_SUBTITLE_UNAVAILABLE):
                case static_cast<int32_t>(Literal::MEDIAERROR_VIDEO_UNAVAILABLE):
                case static_cast<int32_t>(Literal::MEDIAERROR_UNSUPPORTED):
                case static_cast<int32_t>(Literal::MEDIAERROR_UNKNOWN):
                case static_cast<int32_t>(Literal::MEDIAERROR_FOLDERNOTEXIST):
                case static_cast<int32_t>(Literal::MEDIAERROR_AUDIOCORRUPT):
                case static_cast<int32_t>(Literal::MEDIAERROR_VIDEOCORRUPT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eMediaError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eMediaError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eMediaError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eMediaError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eMediaError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eMediaError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eButtonStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            BUTTONSTATUS_UNKNOWN = 0,
            BUTTONSTATUS_PRESS = 1,
            BUTTONSTATUS_LONG_PRESS = 2,
            BUTTONSTATUS_RELEASE = 3,
            BUTTONSTATUS_LONG_RELEASE = 4
        };
        
        eButtonStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::BUTTONSTATUS_UNKNOWN)) {}
        eButtonStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::BUTTONSTATUS_UNKNOWN):
                case static_cast<int32_t>(Literal::BUTTONSTATUS_PRESS):
                case static_cast<int32_t>(Literal::BUTTONSTATUS_LONG_PRESS):
                case static_cast<int32_t>(Literal::BUTTONSTATUS_RELEASE):
                case static_cast<int32_t>(Literal::BUTTONSTATUS_LONG_RELEASE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eButtonStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eButtonStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eButtonStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eButtonStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eButtonStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eButtonStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eVideoSurfaceDisplayStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            VIDEOSURFACE_HIDE = 0,
            VIDEOSURFACE_SHOW = 1
        };
        
        eVideoSurfaceDisplayStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::VIDEOSURFACE_HIDE)) {}
        eVideoSurfaceDisplayStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::VIDEOSURFACE_HIDE):
                case static_cast<int32_t>(Literal::VIDEOSURFACE_SHOW):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eVideoSurfaceDisplayStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eVideoSurfaceDisplayStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eVideoSurfaceDisplayStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eVideoSurfaceDisplayStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eVideoSurfaceDisplayStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eVideoSurfaceDisplayStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::unordered_map<uint8_t, ::v0::com::harman::mmpresPlugin::mediaPresPlugin::eMediaError> MediaErrorMap;
    /**
     * description: Indicates the device contents
     */
    struct sItemsInfo : CommonAPI::Struct<int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t, int32_t> {
    	
    	sItemsInfo() {
    	}
    	sItemsInfo(const int32_t &_TotalAudioItems, const int32_t &_TotalVideoItems, const int32_t &_TotalImageItems, const int32_t &_TotalPlaylistItems, const int32_t &_TotalPodcastItems, const int32_t &_TotalITunesRadioItems, const int32_t &_TotalAudiobookItems, const int32_t &_TotalFolderItems)
    	{
            std::get<0>(values_) = _TotalAudioItems;
            std::get<1>(values_) = _TotalVideoItems;
            std::get<2>(values_) = _TotalImageItems;
            std::get<3>(values_) = _TotalPlaylistItems;
            std::get<4>(values_) = _TotalPodcastItems;
            std::get<5>(values_) = _TotalITunesRadioItems;
            std::get<6>(values_) = _TotalAudiobookItems;
            std::get<7>(values_) = _TotalFolderItems;
    	}
    	inline const int32_t &getTotalAudioItems() const { return std::get<0>(values_); }
    	inline void setTotalAudioItems(const int32_t &_value) { std::get<0>(values_) = _value; }
    	inline const int32_t &getTotalVideoItems() const { return std::get<1>(values_); }
    	inline void setTotalVideoItems(const int32_t &_value) { std::get<1>(values_) = _value; }
    	inline const int32_t &getTotalImageItems() const { return std::get<2>(values_); }
    	inline void setTotalImageItems(const int32_t &_value) { std::get<2>(values_) = _value; }
    	inline const int32_t &getTotalPlaylistItems() const { return std::get<3>(values_); }
    	inline void setTotalPlaylistItems(const int32_t &_value) { std::get<3>(values_) = _value; }
    	inline const int32_t &getTotalPodcastItems() const { return std::get<4>(values_); }
    	inline void setTotalPodcastItems(const int32_t &_value) { std::get<4>(values_) = _value; }
    	inline const int32_t &getTotalITunesRadioItems() const { return std::get<5>(values_); }
    	inline void setTotalITunesRadioItems(const int32_t &_value) { std::get<5>(values_) = _value; }
    	inline const int32_t &getTotalAudiobookItems() const { return std::get<6>(values_); }
    	inline void setTotalAudiobookItems(const int32_t &_value) { std::get<6>(values_) = _value; }
    	inline const int32_t &getTotalFolderItems() const { return std::get<7>(values_); }
    	inline void setTotalFolderItems(const int32_t &_value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const sItemsInfo& _other) const {
                return (getTotalAudioItems() == _other.getTotalAudioItems() && getTotalVideoItems() == _other.getTotalVideoItems() && getTotalImageItems() == _other.getTotalImageItems() && getTotalPlaylistItems() == _other.getTotalPlaylistItems() && getTotalPodcastItems() == _other.getTotalPodcastItems() && getTotalITunesRadioItems() == _other.getTotalITunesRadioItems() && getTotalAudiobookItems() == _other.getTotalAudiobookItems() && getTotalFolderItems() == _other.getTotalFolderItems());
        }
    	inline bool operator!=(const sItemsInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sVideoResolution : CommonAPI::Struct<std::string, std::string> {
    	
    	sVideoResolution() {
    	}
    	sVideoResolution(const std::string &_videoWidth, const std::string &_videoHeight)
    	{
    		std::get<0>(values_) = _videoWidth;
    		std::get<1>(values_) = _videoHeight;
    	}
    	inline const std::string &getVideoWidth() const { return std::get<0>(values_); }
    	inline void setVideoWidth(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getVideoHeight() const { return std::get<1>(values_); }
    	inline void setVideoHeight(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sVideoResolution& _other) const {
                return (getVideoWidth() == _other.getVideoWidth() && getVideoHeight() == _other.getVideoHeight());
        }
    	inline bool operator!=(const sVideoResolution &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sVideoParameters : CommonAPI::Struct<std::string, sVideoResolution, std::string, std::string, std::string> {
    	
    	sVideoParameters() {
    	}
    	sVideoParameters(const std::string &_videoCodec, const sVideoResolution &_videoResolution, const std::string &_videoFrameRate, const std::string &_audioCodec, const std::string &_audioSamplingRate)
    	{
    		std::get<0>(values_) = _videoCodec;
    		std::get<1>(values_) = _videoResolution;
    		std::get<2>(values_) = _videoFrameRate;
    		std::get<3>(values_) = _audioCodec;
    		std::get<4>(values_) = _audioSamplingRate;
    	}
    	inline const std::string &getVideoCodec() const { return std::get<0>(values_); }
    	inline void setVideoCodec(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const sVideoResolution &getVideoResolution() const { return std::get<1>(values_); }
    	inline void setVideoResolution(const sVideoResolution &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getVideoFrameRate() const { return std::get<2>(values_); }
    	inline void setVideoFrameRate(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getAudioCodec() const { return std::get<3>(values_); }
    	inline void setAudioCodec(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline const std::string &getAudioSamplingRate() const { return std::get<4>(values_); }
    	inline void setAudioSamplingRate(const std::string &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const sVideoParameters& _other) const {
                return (getVideoCodec() == _other.getVideoCodec() && getVideoResolution() == _other.getVideoResolution() && getVideoFrameRate() == _other.getVideoFrameRate() && getAudioCodec() == _other.getAudioCodec() && getAudioSamplingRate() == _other.getAudioSamplingRate());
        }
    	inline bool operator!=(const sVideoParameters &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sTEFilesPath : CommonAPI::Struct<std::string, std::string, std::string, std::string, std::string> {
    	
    	sTEFilesPath() {
    	}
    	sTEFilesPath(const std::string &_playlistTEFilePath, const std::string &_mediaTEFilePath, const std::string &_audiobookTEFilePath, const std::string &_podcastTEFilePath, const std::string &_folderTEFilePath)
    	{
    		std::get<0>(values_) = _playlistTEFilePath;
    		std::get<1>(values_) = _mediaTEFilePath;
    		std::get<2>(values_) = _audiobookTEFilePath;
    		std::get<3>(values_) = _podcastTEFilePath;
    		std::get<4>(values_) = _folderTEFilePath;
    	}
    	inline const std::string &getPlaylistTEFilePath() const { return std::get<0>(values_); }
    	inline void setPlaylistTEFilePath(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getMediaTEFilePath() const { return std::get<1>(values_); }
    	inline void setMediaTEFilePath(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getAudiobookTEFilePath() const { return std::get<2>(values_); }
    	inline void setAudiobookTEFilePath(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getPodcastTEFilePath() const { return std::get<3>(values_); }
    	inline void setPodcastTEFilePath(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline const std::string &getFolderTEFilePath() const { return std::get<4>(values_); }
    	inline void setFolderTEFilePath(const std::string &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const sTEFilesPath& _other) const {
                return (getPlaylistTEFilePath() == _other.getPlaylistTEFilePath() && getMediaTEFilePath() == _other.getMediaTEFilePath() && getAudiobookTEFilePath() == _other.getAudiobookTEFilePath() && getPodcastTEFilePath() == _other.getPodcastTEFilePath() && getFolderTEFilePath() == _other.getFolderTEFilePath());
        }
    	inline bool operator!=(const sTEFilesPath &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* mediaPresPlugin::getInterface() {
    return ("com.harman.mmpresPlugin.mediaPresPlugin");
}

CommonAPI::Version mediaPresPlugin::getInterfaceVersion() {
    return CommonAPI::Version(0, 1);
}

/**
 * description: Indicates the device contents
 */

} // namespace mmpresPlugin
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_MMPRESPLUGIN_MEDIA_PRES_PLUGIN_HPP_
