/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_CARPLAYPRES_TATA_CAR_PLAY_PRES_PLUGIN_HPP_
#define V0_COM_HARMAN_CARPLAYPRES_TATA_CAR_PLAY_PRES_PLUGIN_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace carplaypres {

class TataCarPlayPresPlugin {
public:
    virtual ~TataCarPlayPresPlugin() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct OwnerType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            None = 0,
            iDevice = 1,
            HeadUnit = 2
        };
        
        OwnerType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::None)) {}
        OwnerType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::None):
                case static_cast<int32_t>(Literal::iDevice):
                case static_cast<int32_t>(Literal::HeadUnit):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const OwnerType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const OwnerType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const OwnerType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const OwnerType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const OwnerType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const OwnerType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SpeechType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            None = 0,
            Speaking = 1
        };
        
        SpeechType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::None)) {}
        SpeechType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::None):
                case static_cast<int32_t>(Literal::Speaking):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SpeechType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SpeechType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SpeechType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SpeechType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SpeechType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SpeechType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct sCarplayModeOwner : CommonAPI::Struct<OwnerType, OwnerType, OwnerType, OwnerType, OwnerType, SpeechType> {
    	
    	sCarplayModeOwner() {
    	}
    	sCarplayModeOwner(const OwnerType &_MainaudioOwner, const OwnerType &_ScreenOwner, const OwnerType &_PhoneOwner, const OwnerType &_NavigationOwner, const OwnerType &_SpeechOwner, const SpeechType &_CurrentSpeechMode)
    	{
    		std::get<0>(values_) = _MainaudioOwner;
    		std::get<1>(values_) = _ScreenOwner;
    		std::get<2>(values_) = _PhoneOwner;
    		std::get<3>(values_) = _NavigationOwner;
    		std::get<4>(values_) = _SpeechOwner;
    		std::get<5>(values_) = _CurrentSpeechMode;
    	}
    	inline const OwnerType &getMainaudioOwner() const { return std::get<0>(values_); }
    	inline void setMainaudioOwner(const OwnerType &_value) { std::get<0>(values_) = _value; }
    	inline const OwnerType &getScreenOwner() const { return std::get<1>(values_); }
    	inline void setScreenOwner(const OwnerType &_value) { std::get<1>(values_) = _value; }
    	inline const OwnerType &getPhoneOwner() const { return std::get<2>(values_); }
    	inline void setPhoneOwner(const OwnerType &_value) { std::get<2>(values_) = _value; }
    	inline const OwnerType &getNavigationOwner() const { return std::get<3>(values_); }
    	inline void setNavigationOwner(const OwnerType &_value) { std::get<3>(values_) = _value; }
    	inline const OwnerType &getSpeechOwner() const { return std::get<4>(values_); }
    	inline void setSpeechOwner(const OwnerType &_value) { std::get<4>(values_) = _value; }
    	inline const SpeechType &getCurrentSpeechMode() const { return std::get<5>(values_); }
    	inline void setCurrentSpeechMode(const SpeechType &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const sCarplayModeOwner& _other) const {
                return (getMainaudioOwner() == _other.getMainaudioOwner() && getScreenOwner() == _other.getScreenOwner() && getPhoneOwner() == _other.getPhoneOwner() && getNavigationOwner() == _other.getNavigationOwner() && getSpeechOwner() == _other.getSpeechOwner() && getCurrentSpeechMode() == _other.getCurrentSpeechMode());
        }
    	inline bool operator!=(const sCarplayModeOwner &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sPluginNowPlayingInfo : CommonAPI::Struct<std::string, std::string> {
    	
    	sPluginNowPlayingInfo() {
    	}
    	sPluginNowPlayingInfo(const std::string &_title, const std::string &_artist)
    	{
    		std::get<0>(values_) = _title;
    		std::get<1>(values_) = _artist;
    	}
    	inline const std::string &getTitle() const { return std::get<0>(values_); }
    	inline void setTitle(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getArtist() const { return std::get<1>(values_); }
    	inline void setArtist(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sPluginNowPlayingInfo& _other) const {
                return (getTitle() == _other.getTitle() && getArtist() == _other.getArtist());
        }
    	inline bool operator!=(const sPluginNowPlayingInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* TataCarPlayPresPlugin::getInterface() {
    return ("com.harman.carplaypres.TataCarPlayPresPlugin");
}

CommonAPI::Version TataCarPlayPresPlugin::getInterfaceVersion() {
    return CommonAPI::Version(0, 2);
}

/**
 * description: This enum is used to check current mode owner.
 */
/**
 * description: This enum is used to check current mode owner.
 */

} // namespace carplaypres
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


// Compatibility
namespace v0_2 = v0;

#endif // V0_COM_HARMAN_CARPLAYPRES_TATA_CAR_PLAY_PRES_PLUGIN_HPP_
