/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Required types for Version Manager interface.
 * author: Gaurav Garg
 */
#ifndef V0_COM_HARMAN_DCIF_versionmanagertypes_tata_HPP_
#define V0_COM_HARMAN_DCIF_versionmanagertypes_tata_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace dcif {

struct versionmanagertypes_tata {
    
    struct InformationStatus_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            STATUS_INFO_AVAILABLE = 0,
            STATUS_INFO_NOT_AVAILABLE = 1,
            STATUS_ERROR = 2
        };
        
        InformationStatus_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::STATUS_INFO_AVAILABLE)) {}
        InformationStatus_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::STATUS_INFO_AVAILABLE):
                case static_cast<int32_t>(Literal::STATUS_INFO_NOT_AVAILABLE):
                case static_cast<int32_t>(Literal::STATUS_ERROR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const InformationStatus_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const InformationStatus_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const InformationStatus_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const InformationStatus_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const InformationStatus_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const InformationStatus_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Information about version of a single component/module
     */
    struct versionInfo_t : CommonAPI::Struct<std::string, std::string, std::string, InformationStatus_e> {
    	
    	versionInfo_t() {
    	}
    	versionInfo_t(const std::string &_s_versionName, const std::string &_s_versionData, const std::string &_s_versionReleasedDate, const InformationStatus_e &_e_versionStatus)
    	{
    		std::get<0>(values_) = _s_versionName;
    		std::get<1>(values_) = _s_versionData;
    		std::get<2>(values_) = _s_versionReleasedDate;
    		std::get<3>(values_) = _e_versionStatus;
    	}
    	/**
    	 * description: Name of the component/module for which VersionInfo is provided
    	 */
    	inline const std::string &getS_versionName() const { return std::get<0>(values_); }
    	inline void setS_versionName(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The actual version information of the component/module in the string format    
    	 *           Valid only when version status is "VERSION_STATUS_INFO_AVAILABLE"
    	 */
    	inline const std::string &getS_versionData() const { return std::get<1>(values_); }
    	inline void setS_versionData(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Released Date of the component/module for which VersionInfo is provided
    	 */
    	inline const std::string &getS_versionReleasedDate() const { return std::get<2>(values_); }
    	inline void setS_versionReleasedDate(const std::string &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Information about the status of the version information
    	 */
    	inline const InformationStatus_e &getE_versionStatus() const { return std::get<3>(values_); }
    	inline void setE_versionStatus(const InformationStatus_e &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const versionInfo_t& _other) const {
                return (getS_versionName() == _other.getS_versionName() && getS_versionData() == _other.getS_versionData() && getS_versionReleasedDate() == _other.getS_versionReleasedDate() && getE_versionStatus() == _other.getE_versionStatus());
        }
    	inline bool operator!=(const versionInfo_t &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct VersionName_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MAIN = 0,
            SOC = 1,
            IOC_APP = 2,
            BUTTON_PANEL = 3,
            DISPLAY = 4,
            IOC_BOLO = 5
        };
        
        VersionName_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MAIN)) {}
        VersionName_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MAIN):
                case static_cast<int32_t>(Literal::SOC):
                case static_cast<int32_t>(Literal::IOC_APP):
                case static_cast<int32_t>(Literal::BUTTON_PANEL):
                case static_cast<int32_t>(Literal::DISPLAY):
                case static_cast<int32_t>(Literal::IOC_BOLO):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const VersionName_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const VersionName_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const VersionName_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const VersionName_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const VersionName_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const VersionName_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct _16RPartName_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ECU_APP_SW_NUMBER = 0,
            ECU_ASSEMBLY_NUMBER = 1,
            SPARE_PART_NUMBER = 2,
            ECU_SW_PART_NUMBER = 3,
            ECU_HW_PART_NUMBER = 4,
            PLATFORM_VARIANT = 5,
            VEHICLE_ID_NUMBER = 6,
            VEHICLE_CFG_INFO_NUMBER = 7,
            BUTTON_PANEL_16R_NUMBER_SPARE_PART = 8,
            BUTTON_PANEL_16R_NUMBER_ECU_HW = 9,
            DISPLAY_16R_NUMBER_SPARE_PART = 10,
            DISPLAY_16R_NUMBER_ECU_HW = 11,
            DISPLAY_SOFTWARE_VERSION = 12,
            DISPLAY_HARDWARE_VERSION = 13,
            BUTTON_PANEL_SW_VERSION_NUMBER = 14,
            BUTTON_PANEL_HW_VERSION_NUMBER = 15,
            ECU_PARAMETRIZATION_SW_NUMBER = 16,
            PARAMETERIZATION_PART_NUMBER = 17,
            SOFTWARE_PART_NUMBER = 18,
            SILVERBOX_HARDWARE_PART_NUMBER = 19,
            CONTAINER_PART_NUMBER = 20,
            IOC_APP_SW_VERSION = 21,
            IOC_BOLO_SW_NUMBER = 22,
            UID_NUMBER = 23
        };
        
        _16RPartName_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ECU_APP_SW_NUMBER)) {}
        _16RPartName_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ECU_APP_SW_NUMBER):
                case static_cast<int32_t>(Literal::ECU_ASSEMBLY_NUMBER):
                case static_cast<int32_t>(Literal::SPARE_PART_NUMBER):
                case static_cast<int32_t>(Literal::ECU_SW_PART_NUMBER):
                case static_cast<int32_t>(Literal::ECU_HW_PART_NUMBER):
                case static_cast<int32_t>(Literal::PLATFORM_VARIANT):
                case static_cast<int32_t>(Literal::VEHICLE_ID_NUMBER):
                case static_cast<int32_t>(Literal::VEHICLE_CFG_INFO_NUMBER):
                case static_cast<int32_t>(Literal::BUTTON_PANEL_16R_NUMBER_SPARE_PART):
                case static_cast<int32_t>(Literal::BUTTON_PANEL_16R_NUMBER_ECU_HW):
                case static_cast<int32_t>(Literal::DISPLAY_16R_NUMBER_SPARE_PART):
                case static_cast<int32_t>(Literal::DISPLAY_16R_NUMBER_ECU_HW):
                case static_cast<int32_t>(Literal::DISPLAY_SOFTWARE_VERSION):
                case static_cast<int32_t>(Literal::DISPLAY_HARDWARE_VERSION):
                case static_cast<int32_t>(Literal::BUTTON_PANEL_SW_VERSION_NUMBER):
                case static_cast<int32_t>(Literal::BUTTON_PANEL_HW_VERSION_NUMBER):
                case static_cast<int32_t>(Literal::ECU_PARAMETRIZATION_SW_NUMBER):
                case static_cast<int32_t>(Literal::PARAMETERIZATION_PART_NUMBER):
                case static_cast<int32_t>(Literal::SOFTWARE_PART_NUMBER):
                case static_cast<int32_t>(Literal::SILVERBOX_HARDWARE_PART_NUMBER):
                case static_cast<int32_t>(Literal::CONTAINER_PART_NUMBER):
                case static_cast<int32_t>(Literal::IOC_APP_SW_VERSION):
                case static_cast<int32_t>(Literal::IOC_BOLO_SW_NUMBER):
                case static_cast<int32_t>(Literal::UID_NUMBER):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const _16RPartName_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const _16RPartName_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const _16RPartName_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const _16RPartName_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const _16RPartName_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const _16RPartName_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Information about 16RPart number of a single component/part
     */
    struct _16RPartDetails_t : CommonAPI::Struct<std::string, std::string, InformationStatus_e> {
    	
    	_16RPartDetails_t() {
    	}
    	_16RPartDetails_t(const std::string &_s_16RPartName, const std::string &_s_16RPartData, const InformationStatus_e &_e_PartStatus)
    	{
    		std::get<0>(values_) = _s_16RPartName;
    		std::get<1>(values_) = _s_16RPartData;
    		std::get<2>(values_) = _e_PartStatus;
    	}
    	/**
    	 * description: Name of the component/module for which PartInfo is provided
    	 */
    	inline const std::string &getS_16RPartName() const { return std::get<0>(values_); }
    	inline void setS_16RPartName(const std::string &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: The actual part information of the component/part in the string format         
    	 *      Valid only when component status is "VERSION_STATUS_INFO_AVAILABLE"
    	 */
    	inline const std::string &getS_16RPartData() const { return std::get<1>(values_); }
    	inline void setS_16RPartData(const std::string &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Information about the status of the component information
    	 */
    	inline const InformationStatus_e &getE_PartStatus() const { return std::get<2>(values_); }
    	inline void setE_PartStatus(const InformationStatus_e &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const _16RPartDetails_t& _other) const {
                return (getS_16RPartName() == _other.getS_16RPartName() && getS_16RPartData() == _other.getS_16RPartData() && getE_PartStatus() == _other.getE_PartStatus());
        }
    	inline bool operator!=(const _16RPartDetails_t &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct VersionMismatchDetails_e : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NO_VERSION_MISMATCH = 0,
            DISPLAY_VERSION_MISMATCH = 1,
            BUTTON_PANEL_VERSION_MISMATCH = 2,
            BP_DM_VERSION_MISMATCH = 3
        };
        
        VersionMismatchDetails_e() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NO_VERSION_MISMATCH)) {}
        VersionMismatchDetails_e(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NO_VERSION_MISMATCH):
                case static_cast<int32_t>(Literal::DISPLAY_VERSION_MISMATCH):
                case static_cast<int32_t>(Literal::BUTTON_PANEL_VERSION_MISMATCH):
                case static_cast<int32_t>(Literal::BP_DM_VERSION_MISMATCH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const VersionMismatchDetails_e &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const VersionMismatchDetails_e &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const VersionMismatchDetails_e &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const VersionMismatchDetails_e &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const VersionMismatchDetails_e &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const VersionMismatchDetails_e &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: list of all the known version informations
     */
    typedef std::vector<versionmanagertypes_tata::versionInfo_t> a_VersionInfoList;
    /**
     * description: list of all the known 16RPart information
     */
    typedef std::vector<versionmanagertypes_tata::_16RPartDetails_t> a_16RInfoList;



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.dcif.versionmanagertypes_tata";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

}; // struct versionmanagertypes_tata

} // namespace dcif
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for InformationStatus_e
    template<>
    struct hash<::v0::com::harman::dcif::versionmanagertypes_tata::InformationStatus_e> {
        inline size_t operator()(const ::v0::com::harman::dcif::versionmanagertypes_tata::InformationStatus_e& informationStatus_e) const {
            return static_cast<int32_t>(informationStatus_e);
        }
    };
    //Hash for VersionName_e
    template<>
    struct hash<::v0::com::harman::dcif::versionmanagertypes_tata::VersionName_e> {
        inline size_t operator()(const ::v0::com::harman::dcif::versionmanagertypes_tata::VersionName_e& versionName_e) const {
            return static_cast<int32_t>(versionName_e);
        }
    };
    //Hash for _16RPartName_e
    template<>
    struct hash<::v0::com::harman::dcif::versionmanagertypes_tata::_16RPartName_e> {
        inline size_t operator()(const ::v0::com::harman::dcif::versionmanagertypes_tata::_16RPartName_e& _16RPartName_e) const {
            return static_cast<int32_t>(_16RPartName_e);
        }
    };
    //Hash for VersionMismatchDetails_e
    template<>
    struct hash<::v0::com::harman::dcif::versionmanagertypes_tata::VersionMismatchDetails_e> {
        inline size_t operator()(const ::v0::com::harman::dcif::versionmanagertypes_tata::VersionMismatchDetails_e& versionMismatchDetails_e) const {
            return static_cast<int32_t>(versionMismatchDetails_e);
        }
    };
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_DCIF_versionmanagertypes_tata_HPP_
