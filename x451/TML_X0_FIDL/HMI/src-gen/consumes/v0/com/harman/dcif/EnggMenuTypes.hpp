/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V0_COM_HARMAN_DCIF_Engg_Menu_Types_HPP_
#define V0_COM_HARMAN_DCIF_Engg_Menu_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v0 {
namespace com {
namespace harman {
namespace dcif {

struct EnggMenuTypes {
    
    struct retStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SUCCESS = 0,
            FAILURE = -1
        };
        
        retStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SUCCESS)) {}
        retStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::FAILURE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const retStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const retStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const retStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const retStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const retStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const retStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct logType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID_LOGS = -1,
            DBUS_LOGS = 0,
            DLT_LOGS = 1,
            CPU_MEASUREMENT_LOGS = 2,
            RAM_MEASUREMENT_LOGS = 3,
            MAX_DBUG_LOG_TYPE = 5
        };
        
        logType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID_LOGS)) {}
        logType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID_LOGS):
                case static_cast<int32_t>(Literal::DBUS_LOGS):
                case static_cast<int32_t>(Literal::DLT_LOGS):
                case static_cast<int32_t>(Literal::CPU_MEASUREMENT_LOGS):
                case static_cast<int32_t>(Literal::RAM_MEASUREMENT_LOGS):
                case static_cast<int32_t>(Literal::MAX_DBUG_LOG_TYPE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const logType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const logType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const logType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const logType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const logType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const logType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ipType_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            IP_INVALID = -1,
            IP_STATIC = 1,
            IP_DYNAMIC = 2
        };
        
        ipType_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::IP_INVALID)) {}
        ipType_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::IP_INVALID):
                case static_cast<int32_t>(Literal::IP_STATIC):
                case static_cast<int32_t>(Literal::IP_DYNAMIC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ipType_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ipType_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ipType_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ipType_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ipType_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ipType_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct modeType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            DEVICE_MODE = 0,
            HOST_MODE = 1
        };
        
        modeType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::DEVICE_MODE)) {}
        modeType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::DEVICE_MODE):
                case static_cast<int32_t>(Literal::HOST_MODE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const modeType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const modeType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const modeType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const modeType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const modeType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const modeType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct deviceModeStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            FAILURE = -1,
            SUCCESS = 0,
            FILE_NOT_FOUND = 1
        };
        
        deviceModeStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::FAILURE)) {}
        deviceModeStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::FAILURE):
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::FILE_NOT_FOUND):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const deviceModeStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const deviceModeStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const deviceModeStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const deviceModeStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const deviceModeStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const deviceModeStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct extractLogsError_enum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            SUCCESS = 0,
            USB_NOT_CONNECTED = 1,
            LOGGING_NOT_ENABLED = 2,
            USB_DEVICE_FULL = 3
        };
        
        extractLogsError_enum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::SUCCESS)) {}
        extractLogsError_enum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::SUCCESS):
                case static_cast<int32_t>(Literal::USB_NOT_CONNECTED):
                case static_cast<int32_t>(Literal::LOGGING_NOT_ENABLED):
                case static_cast<int32_t>(Literal::USB_DEVICE_FULL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const extractLogsError_enum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const extractLogsError_enum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const extractLogsError_enum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const extractLogsError_enum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const extractLogsError_enum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const extractLogsError_enum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct loggingStatus : CommonAPI::Struct<bool, bool, bool, bool> {
    	
    	loggingStatus() {
    		std::get<0>(values_) = false;
    		std::get<1>(values_) = false;
    		std::get<2>(values_) = false;
    		std::get<3>(values_) = false;
    	}
    	loggingStatus(const bool &_dbus_logs_status, const bool &_dlt_logs_status, const bool &_cpu_measurement_logs_status, const bool &_ram_measurement_logs_status)
    	{
    		std::get<0>(values_) = _dbus_logs_status;
    		std::get<1>(values_) = _dlt_logs_status;
    		std::get<2>(values_) = _cpu_measurement_logs_status;
    		std::get<3>(values_) = _ram_measurement_logs_status;
    	}
    	inline const bool &getDbus_logs_status() const { return std::get<0>(values_); }
    	inline void setDbus_logs_status(const bool _value) { std::get<0>(values_) = _value; }
    	inline const bool &getDlt_logs_status() const { return std::get<1>(values_); }
    	inline void setDlt_logs_status(const bool _value) { std::get<1>(values_) = _value; }
    	inline const bool &getCpu_measurement_logs_status() const { return std::get<2>(values_); }
    	inline void setCpu_measurement_logs_status(const bool _value) { std::get<2>(values_) = _value; }
    	inline const bool &getRam_measurement_logs_status() const { return std::get<3>(values_); }
    	inline void setRam_measurement_logs_status(const bool _value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const loggingStatus& _other) const {
                return (getDbus_logs_status() == _other.getDbus_logs_status() && getDlt_logs_status() == _other.getDlt_logs_status() && getCpu_measurement_logs_status() == _other.getCpu_measurement_logs_status() && getRam_measurement_logs_status() == _other.getRam_measurement_logs_status());
        }
    	inline bool operator!=(const loggingStatus &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: tunerInfo 	 sourceType : Type of tuner source AM/FM 	 stationName : Name of
     *   frequency station 	 frequency : station frequency 	 multipath : multipathValue
     *   	 signalStrength : signal strength
     */
    struct tunerInfo : CommonAPI::Struct<std::string, std::string, uint32_t, uint8_t, int16_t> {
    	
    	tunerInfo() {
    	}
    	tunerInfo(const std::string &_sourceType, const std::string &_stationName, const uint32_t &_frequency, const uint8_t &_multipath, const int16_t &_signalStrength)
    	{
    		std::get<0>(values_) = _sourceType;
    		std::get<1>(values_) = _stationName;
    		std::get<2>(values_) = _frequency;
    		std::get<3>(values_) = _multipath;
    		std::get<4>(values_) = _signalStrength;
    	}
    	inline const std::string &getSourceType() const { return std::get<0>(values_); }
    	inline void setSourceType(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getStationName() const { return std::get<1>(values_); }
    	inline void setStationName(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const uint32_t &getFrequency() const { return std::get<2>(values_); }
    	inline void setFrequency(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline const uint8_t &getMultipath() const { return std::get<3>(values_); }
    	inline void setMultipath(const uint8_t &_value) { std::get<3>(values_) = _value; }
    	inline const int16_t &getSignalStrength() const { return std::get<4>(values_); }
    	inline void setSignalStrength(const int16_t &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const tunerInfo& _other) const {
                return (getSourceType() == _other.getSourceType() && getStationName() == _other.getStationName() && getFrequency() == _other.getFrequency() && getMultipath() == _other.getMultipath() && getSignalStrength() == _other.getSignalStrength());
        }
    	inline bool operator!=(const tunerInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: mediaInfo 	 mediaType : USB/iPod/BT Audio/Aux 	 trackName : Current playing
     *   song name 	 bitRate:  bitRate value 	 samplingRate : samplingRate value
     */
    struct mediaInfo : CommonAPI::Struct<std::string, std::string, std::string, std::string> {
    	
    	mediaInfo() {
    	}
    	mediaInfo(const std::string &_mediaType, const std::string &_trackName, const std::string &_bitRate, const std::string &_samplingRate)
    	{
    		std::get<0>(values_) = _mediaType;
    		std::get<1>(values_) = _trackName;
    		std::get<2>(values_) = _bitRate;
    		std::get<3>(values_) = _samplingRate;
    	}
    	inline const std::string &getMediaType() const { return std::get<0>(values_); }
    	inline void setMediaType(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getTrackName() const { return std::get<1>(values_); }
    	inline void setTrackName(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getBitRate() const { return std::get<2>(values_); }
    	inline void setBitRate(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getSamplingRate() const { return std::get<3>(values_); }
    	inline void setSamplingRate(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const mediaInfo& _other) const {
                return (getMediaType() == _other.getMediaType() && getTrackName() == _other.getTrackName() && getBitRate() == _other.getBitRate() && getSamplingRate() == _other.getSamplingRate());
        }
    	inline bool operator!=(const mediaInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.dcif.EnggMenuTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(0, 1);
}

}; // struct EnggMenuTypes

} // namespace dcif
} // namespace harman
} // namespace com
} // namespace v0

namespace CommonAPI {
}


namespace std {
    //Hash for retStatus
    template<>
    struct hash<::v0::com::harman::dcif::EnggMenuTypes::retStatus> {
        inline size_t operator()(const ::v0::com::harman::dcif::EnggMenuTypes::retStatus& retStatus) const {
            return static_cast<int32_t>(retStatus);
        }
    };
    //Hash for logType
    template<>
    struct hash<::v0::com::harman::dcif::EnggMenuTypes::logType> {
        inline size_t operator()(const ::v0::com::harman::dcif::EnggMenuTypes::logType& logType) const {
            return static_cast<int32_t>(logType);
        }
    };
    //Hash for ipType_enum
    template<>
    struct hash<::v0::com::harman::dcif::EnggMenuTypes::ipType_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::EnggMenuTypes::ipType_enum& ipType_enum) const {
            return static_cast<int32_t>(ipType_enum);
        }
    };
    //Hash for modeType
    template<>
    struct hash<::v0::com::harman::dcif::EnggMenuTypes::modeType> {
        inline size_t operator()(const ::v0::com::harman::dcif::EnggMenuTypes::modeType& modeType) const {
            return static_cast<int32_t>(modeType);
        }
    };
    //Hash for deviceModeStatus
    template<>
    struct hash<::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus> {
        inline size_t operator()(const ::v0::com::harman::dcif::EnggMenuTypes::deviceModeStatus& deviceModeStatus) const {
            return static_cast<int32_t>(deviceModeStatus);
        }
    };
    //Hash for extractLogsError_enum
    template<>
    struct hash<::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum> {
        inline size_t operator()(const ::v0::com::harman::dcif::EnggMenuTypes::extractLogsError_enum& extractLogsError_enum) const {
            return static_cast<int32_t>(extractLogsError_enum);
        }
    };
}


// Compatibility
namespace v0_1 = v0;

#endif // V0_COM_HARMAN_DCIF_Engg_Menu_Types_HPP_
