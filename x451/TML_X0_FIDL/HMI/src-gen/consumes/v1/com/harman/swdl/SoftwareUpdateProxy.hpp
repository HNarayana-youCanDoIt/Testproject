/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Provides interface to control the Software Update flow and to access the states
 *   and progress during the update process
 * author: Bharath Upadhya
 */
#ifndef V1_COM_HARMAN_SWDL_Software_Update_PROXY_HPP_
#define V1_COM_HARMAN_SWDL_Software_Update_PROXY_HPP_

#include <v1/com/harman/swdl/SoftwareUpdateProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace swdl {

template <typename ... _AttributeExtensions>
class SoftwareUpdateProxy
    : virtual public SoftwareUpdate, 
      virtual public SoftwareUpdateProxyBase,
      virtual public _AttributeExtensions... {
public:
    SoftwareUpdateProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~SoftwareUpdateProxy();

    typedef SoftwareUpdate InterfaceType;


    /**
     * description: list of software packages which are ready for download from the external
     *   location (e.g. MSD or OTA)
     */
    /**
     * Returns the wrapper class that provides access to the attribute softwareAvailableForDownloadAttr.
     */
    virtual SoftwareAvailableForDownloadAttrAttribute& getSoftwareAvailableForDownloadAttrAttribute() {
        return delegate_->getSoftwareAvailableForDownloadAttrAttribute();
    }
    /**
     * description: list of packages ready of installation                        incase system is
     *   configured to allowed to cache the package before instllation , then list is
     *   llimited to                         single package is downloaded from external
     *   location to target cache area.                        incase system is
     *   configured to allow instllation of package directly from original external
     *   location (e.g. MSD) ,                         this it list of packages in
     *   external location compatible with the system.
     */
    /**
     * Returns the wrapper class that provides access to the attribute softwareAvailableForInstallAttr.
     */
    virtual SoftwareAvailableForInstallAttrAttribute& getSoftwareAvailableForInstallAttrAttribute() {
        return delegate_->getSoftwareAvailableForInstallAttrAttribute();
    }
    /**
     * description: Software package installation progress information (overall progress and part
     *   wise progress along with its name).
     */
    /**
     * Returns the wrapper class that provides access to the attribute installProgress.
     */
    virtual InstallProgressAttribute& getInstallProgressAttribute() {
        return delegate_->getInstallProgressAttribute();
    }
    /**
     * description: Software package download progress information.
     */
    /**
     * Returns the wrapper class that provides access to the attribute downloadProgress.
     */
    virtual DownloadProgressAttribute& getDownloadProgressAttribute() {
        return delegate_->getDownloadProgressAttribute();
    }
    /**
     * description: activation status of previously installed software.
     */
    /**
     * Returns the wrapper class that provides access to the attribute activationResult.
     */
    virtual ActivationResultAttribute& getActivationResultAttribute() {
        return delegate_->getActivationResultAttribute();
    }
    /**
     * description: Last update package searched time.
     */
    /**
     * Returns the wrapper class that provides access to the attribute lastUpdateSearchTime.
     */
    virtual LastUpdateSearchTimeAttribute& getLastUpdateSearchTimeAttribute() {
        return delegate_->getLastUpdateSearchTimeAttribute();
    }
    /**
     * description: Last package install time.
     */
    /**
     * Returns the wrapper class that provides access to the attribute lastUpdateInstallTime.
     */
    virtual LastUpdateInstallTimeAttribute& getLastUpdateInstallTimeAttribute() {
        return delegate_->getLastUpdateInstallTimeAttribute();
    }
    /**
     * description: Current state of the software update state machine
     */
    /**
     * Returns the wrapper class that provides access to the attribute status.
     */
    virtual StatusAttribute& getStatusAttribute() {
        return delegate_->getStatusAttribute();
    }
    /**
     * description: setting option to enable automatice download of the SW package from external
     *   source (OTA or MSD etc).
     */
    /**
     * Returns the wrapper class that provides access to the attribute autoDownload.
     */
    virtual AutoDownloadAttribute& getAutoDownloadAttribute() {
        return delegate_->getAutoDownloadAttribute();
    }
    /**
     * description: setting option which sets maximum package size limit for auto download (if
     *   enabled)                       value zero represents setting is not enabled
     *   and allows download packages with any limit.
     */
    /**
     * Returns the wrapper class that provides access to the attribute autoDownloadSizeLimit.
     */
    virtual AutoDownloadSizeLimitAttribute& getAutoDownloadSizeLimitAttribute() {
        return delegate_->getAutoDownloadSizeLimitAttribute();
    }
    /**
     * description: setting option to enable automatic installation of the SW package which is
     *   ready for installaltion                         (either already downloaded to
     *   target cache memory or ready from installation directly from external location
     *   e.g. MSD)
     */
    /**
     * Returns the wrapper class that provides access to the attribute autoInstall.
     */
    virtual AutoInstallAttribute& getAutoInstallAttribute() {
        return delegate_->getAutoInstallAttribute();
    }
    /**
     * description: setting option which enables automatic search for SW update package from
     *   external location once communnication is established with                     
     *      system (e.g. MSD device connected to the system)
     */
    /**
     * Returns the wrapper class that provides access to the attribute autoSearch.
     */
    virtual AutoSearchAttribute& getAutoSearchAttribute() {
        return delegate_->getAutoSearchAttribute();
    }
    /**
     * description: polling time interval (in seconds) to be used for searching the updates
     *   availability on the remote server
     */
    /**
     * Returns the wrapper class that provides access to the attribute autoSearchInterval.
     */
    virtual AutoSearchIntervalAttribute& getAutoSearchIntervalAttribute() {
        return delegate_->getAutoSearchIntervalAttribute();
    }
    /**
     * description: if enabled , setting allows force installation of software package with any
     *   version.                        if not , service restricts installation of SW
     *   package with older or same version compare to version active in the system
     */
    /**
     * Returns the wrapper class that provides access to the attribute allowVersionDowngrade.
     */
    virtual AllowVersionDowngradeAttribute& getAllowVersionDowngradeAttribute() {
        return delegate_->getAllowVersionDowngradeAttribute();
    }

    /**
     * description: Broadcast signals when new SoftwareUpdate image available for download (E.g.,
     *   From OTA server or Mass Storage device).                        Depreciated
     *   for future use; Instead use "attribute tPackageList
     *   softwareAvailableForDownload"
     */
    /**
     * Returns the wrapper class that provides access to the broadcast SoftwareAvailableForDownload.
     */
    virtual SoftwareAvailableForDownloadEvent& getSoftwareAvailableForDownloadEvent() {
        return delegate_->getSoftwareAvailableForDownloadEvent();
    }
    /**
     * description: Broadcast signal to notify if a update package is ready for installation       
     *                    (e.g. Already downloaded from OTA server or mass storage
     *   device or ready for installation direclty from Mass Storage Device)           
     *               Depreciated for future use; Instead use "attribute tPackageList
     *   softwareAvailableForInstall"
     */
    /**
     * Returns the wrapper class that provides access to the broadcast SoftwareAvailableForInstall.
     */
    virtual SoftwareAvailableForInstallEvent& getSoftwareAvailableForInstallEvent() {
        return delegate_->getSoftwareAvailableForInstallEvent();
    }
    /**
     * description: Broadcast signals for indication of current state of the update flow along with
     *   notification of process flow
     */
    /**
     * Returns the wrapper class that provides access to the broadcast SoftwareUpdateStatus.
     */
    virtual SoftwareUpdateStatusEvent& getSoftwareUpdateStatusEvent() {
        return delegate_->getSoftwareUpdateStatusEvent();
    }

    /**
     * description: Trigger to search for any software updates available for download and install
     *   from the available sources.                        e.g check for updates from
     *   OTA server or update packages within connected mass storage devices etc
     * Calls CheckForUpdates with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void CheckForUpdates(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls CheckForUpdates with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> CheckForUpdatesAsync(CheckForUpdatesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Trigger to search for specific update package via its name and matching hash in
     *   a source (e.g. Mass Storage Device)                          Parameters:
     * Calls CheckPackageForUpdate with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void CheckPackageForUpdate(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls CheckPackageForUpdate with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> CheckPackageForUpdateAsync(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CheckPackageForUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Trigger to perform a possible download action on newly available software.
     * Calls RequestDownload with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestDownload(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestDownload with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestDownloadAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, RequestDownloadAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Trigger to perform a possible installation action on newly available software  
     *                         (Note : Package might be already downloaded from
     *   external sources to the internal device cache or ready for installation from
     *   external source)
     * Calls RequestInstall with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestInstall(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestInstall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestInstallAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, RequestInstallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method interface to request installation of the specific package located at a
     *   path specified via argument
     * Calls RequestDownloadPackage with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestDownloadPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestDownloadPackage with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestDownloadPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, RequestDownloadPackageAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Method interface to request installation of the specific package located at a
     *   path specified via argument
     * Calls RequestInstallPackage with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestInstallPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestInstallPackage with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestInstallPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, RequestInstallPackageAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To cancel the download which is already started.         Deprecated for future
     *   use , Instead use RequestDownload(CANCEL_DOWNLOAD)
     * Calls CancelDownload with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void CancelDownload(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls CancelDownload with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> CancelDownloadAsync(CancelDownloadAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To cancel the installation which is already in progress.         Deprecated for
     *   future use , Instead use RequestInstall(CANCEL_INSTALLATION)
     * Calls CancelInstall with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void CancelInstall(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls CancelInstall with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> CancelInstallAsync(CancelInstallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To enable or disable automatic download of the package from external source
     *   (e.g. OTA server or Mass storage device) in to the device cached.
     * Calls SetAutomaticDownload with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetAutomaticDownload(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetAutomaticDownload with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetAutomaticDownloadAsync(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, SetAutomaticDownloadAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To get the current enable/disable status for automatic download.
     * Calls GetAutomaticDownloadStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetAutomaticDownloadStatus(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_enableAutoDownload, uint32_t &_autoDownloadLimit, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetAutomaticDownloadStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetAutomaticDownloadStatusAsync(GetAutomaticDownloadStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Request for activation of recently installed software ;                        
     *   Installation complete is notified via states INSTALLATION_COMPLETE or
     *   READY_FOR_ACTIVATION                        Post this API trigger , system
     *   will be restarted to new lifecycle to effect the new software
     * Calls ActivateSoftware with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void ActivateSoftware(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls ActivateSoftware with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> ActivateSoftwareAsync(ActivateSoftwareAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To completely disable the software update feature. When the update is disbaled,
     *                           software update process will neither check for any
     *   updates on its own not process any APIs to serach for updates.
     * Calls DisableSoftwareUpdate with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void DisableSoftwareUpdate(const bool &_disable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls DisableSoftwareUpdate with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> DisableSoftwareUpdateAsync(const bool &_disable, DisableSoftwareUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: retrieve if software update service is currently enabled or disabled
     * Calls GetDisableSoftwareUpdate with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void GetDisableSoftwareUpdate(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_disable, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls GetDisableSoftwareUpdate with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> GetDisableSoftwareUpdateAsync(GetDisableSoftwareUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To abort any on going search for updates.
     * Calls AbortSearch with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void AbortSearch(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls AbortSearch with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> AbortSearchAsync(AbortSearchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: To enable / disable automatic installation of the available/downloaded package
     *   without the confirmation from the client .
     * Calls SetAutomaticInstallation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void SetAutomaticInstallation(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls SetAutomaticInstallation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> SetAutomaticInstallationAsync(const bool &_enable, SetAutomaticInstallationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: method trigger to reset the Software update states back to idle along with
     *   resetting the settings back to default.                        Clears any
     *   internal cache/status informations. If service is already in installation
     *   stage , request will not be processed
     * Calls RequestFactoryReset with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void RequestFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls RequestFactoryReset with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> RequestFactoryResetAsync(RequestFactoryResetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<SoftwareUpdateProxyBase> delegate_;
};

typedef SoftwareUpdateProxy<> SoftwareUpdateProxyDefault;

namespace SoftwareUpdateExtensions {
    /**
     * description: list of software packages which are ready for download from the external
     *   location (e.g. MSD or OTA)
     */
    template <template <typename > class _ExtensionType>
    class SoftwareAvailableForDownloadAttrAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::SoftwareAvailableForDownloadAttrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::SoftwareAvailableForDownloadAttrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SoftwareAvailableForDownloadAttrAttributeExtension() {}
    #endif
    
        SoftwareAvailableForDownloadAttrAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getSoftwareAvailableForDownloadAttrAttribute()) {
        }
    
        inline extension_type& getSoftwareAvailableForDownloadAttrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: list of packages ready of installation                        incase system is
     *   configured to allowed to cache the package before instllation , then list is
     *   llimited to                         single package is downloaded from external
     *   location to target cache area.                        incase system is
     *   configured to allow instllation of package directly from original external
     *   location (e.g. MSD) ,                         this it list of packages in
     *   external location compatible with the system.
     */
    template <template <typename > class _ExtensionType>
    class SoftwareAvailableForInstallAttrAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::SoftwareAvailableForInstallAttrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::SoftwareAvailableForInstallAttrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SoftwareAvailableForInstallAttrAttributeExtension() {}
    #endif
    
        SoftwareAvailableForInstallAttrAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getSoftwareAvailableForInstallAttrAttribute()) {
        }
    
        inline extension_type& getSoftwareAvailableForInstallAttrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Software package installation progress information (overall progress and part
     *   wise progress along with its name).
     */
    template <template <typename > class _ExtensionType>
    class InstallProgressAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::InstallProgressAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::InstallProgressAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        InstallProgressAttributeExtension() {}
    #endif
    
        InstallProgressAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getInstallProgressAttribute()) {
        }
    
        inline extension_type& getInstallProgressAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Software package download progress information.
     */
    template <template <typename > class _ExtensionType>
    class DownloadProgressAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::DownloadProgressAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::DownloadProgressAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DownloadProgressAttributeExtension() {}
    #endif
    
        DownloadProgressAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getDownloadProgressAttribute()) {
        }
    
        inline extension_type& getDownloadProgressAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: activation status of previously installed software.
     */
    template <template <typename > class _ExtensionType>
    class ActivationResultAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::ActivationResultAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::ActivationResultAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ActivationResultAttributeExtension() {}
    #endif
    
        ActivationResultAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getActivationResultAttribute()) {
        }
    
        inline extension_type& getActivationResultAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Last update package searched time.
     */
    template <template <typename > class _ExtensionType>
    class LastUpdateSearchTimeAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::LastUpdateSearchTimeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::LastUpdateSearchTimeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LastUpdateSearchTimeAttributeExtension() {}
    #endif
    
        LastUpdateSearchTimeAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getLastUpdateSearchTimeAttribute()) {
        }
    
        inline extension_type& getLastUpdateSearchTimeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Last package install time.
     */
    template <template <typename > class _ExtensionType>
    class LastUpdateInstallTimeAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::LastUpdateInstallTimeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::LastUpdateInstallTimeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        LastUpdateInstallTimeAttributeExtension() {}
    #endif
    
        LastUpdateInstallTimeAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getLastUpdateInstallTimeAttribute()) {
        }
    
        inline extension_type& getLastUpdateInstallTimeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Current state of the software update state machine
     */
    template <template <typename > class _ExtensionType>
    class StatusAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::StatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::StatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        StatusAttributeExtension() {}
    #endif
    
        StatusAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getStatusAttribute()) {
        }
    
        inline extension_type& getStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: setting option to enable automatice download of the SW package from external
     *   source (OTA or MSD etc).
     */
    template <template <typename > class _ExtensionType>
    class AutoDownloadAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::AutoDownloadAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::AutoDownloadAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AutoDownloadAttributeExtension() {}
    #endif
    
        AutoDownloadAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getAutoDownloadAttribute()) {
        }
    
        inline extension_type& getAutoDownloadAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: setting option which sets maximum package size limit for auto download (if
     *   enabled)                       value zero represents setting is not enabled
     *   and allows download packages with any limit.
     */
    template <template <typename > class _ExtensionType>
    class AutoDownloadSizeLimitAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::AutoDownloadSizeLimitAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::AutoDownloadSizeLimitAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AutoDownloadSizeLimitAttributeExtension() {}
    #endif
    
        AutoDownloadSizeLimitAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getAutoDownloadSizeLimitAttribute()) {
        }
    
        inline extension_type& getAutoDownloadSizeLimitAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: setting option to enable automatic installation of the SW package which is
     *   ready for installaltion                         (either already downloaded to
     *   target cache memory or ready from installation directly from external location
     *   e.g. MSD)
     */
    template <template <typename > class _ExtensionType>
    class AutoInstallAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::AutoInstallAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::AutoInstallAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AutoInstallAttributeExtension() {}
    #endif
    
        AutoInstallAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getAutoInstallAttribute()) {
        }
    
        inline extension_type& getAutoInstallAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: setting option which enables automatic search for SW update package from
     *   external location once communnication is established with                     
     *      system (e.g. MSD device connected to the system)
     */
    template <template <typename > class _ExtensionType>
    class AutoSearchAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::AutoSearchAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::AutoSearchAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AutoSearchAttributeExtension() {}
    #endif
    
        AutoSearchAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getAutoSearchAttribute()) {
        }
    
        inline extension_type& getAutoSearchAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: polling time interval (in seconds) to be used for searching the updates
     *   availability on the remote server
     */
    template <template <typename > class _ExtensionType>
    class AutoSearchIntervalAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::AutoSearchIntervalAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::AutoSearchIntervalAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AutoSearchIntervalAttributeExtension() {}
    #endif
    
        AutoSearchIntervalAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getAutoSearchIntervalAttribute()) {
        }
    
        inline extension_type& getAutoSearchIntervalAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: if enabled , setting allows force installation of software package with any
     *   version.                        if not , service restricts installation of SW
     *   package with older or same version compare to version active in the system
     */
    template <template <typename > class _ExtensionType>
    class AllowVersionDowngradeAttributeExtension {
     public:
        typedef _ExtensionType<SoftwareUpdateProxyBase::AllowVersionDowngradeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<SoftwareUpdateProxyBase::AllowVersionDowngradeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        AllowVersionDowngradeAttributeExtension() {}
    #endif
    
        AllowVersionDowngradeAttributeExtension(SoftwareUpdateProxyBase& proxy): attributeExtension_(proxy.getAllowVersionDowngradeAttribute()) {
        }
    
        inline extension_type& getAllowVersionDowngradeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace SoftwareUpdateExtensions

//
// SoftwareUpdateProxy Implementation
//
template <typename ... _AttributeExtensions>
SoftwareUpdateProxy<_AttributeExtensions...>::SoftwareUpdateProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<SoftwareUpdateProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<SoftwareUpdateProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
SoftwareUpdateProxy<_AttributeExtensions...>::~SoftwareUpdateProxy() {
}

/**
 * description: Trigger to search for any software updates available for download and install
 *   from the available sources.                        e.g check for updates from
 *   OTA server or update packages within connected mass storage devices etc
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::CheckForUpdates(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info) {
    delegate_->CheckForUpdates(_internalCallStatus, _error, _checkResult, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::CheckForUpdatesAsync(CheckForUpdatesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->CheckForUpdatesAsync(_callback, _info);
}
/**
 * description: Trigger to search for specific update package via its name and matching hash in
 *   a source (e.g. Mass Storage Device)                          Parameters:
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::CheckPackageForUpdate(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info) {
    if (!_source.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->CheckPackageForUpdate(_packageName, _hash, _source, _internalCallStatus, _error, _checkResult, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::CheckPackageForUpdateAsync(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CheckPackageForUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_source.validate()) {
        ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult error;
        ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult checkResult = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error, checkResult);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->CheckPackageForUpdateAsync(_packageName, _hash, _source, _callback, _info);
}
/**
 * description: Trigger to perform a possible download action on newly available software.
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::RequestDownload(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    if (!_requestDownload.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->RequestDownload(_requestDownload, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::RequestDownloadAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, RequestDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_requestDownload.validate()) {
        ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->RequestDownloadAsync(_requestDownload, _callback, _info);
}
/**
 * description: Trigger to perform a possible installation action on newly available software  
 *                         (Note : Package might be already downloaded from
 *   external sources to the internal device cache or ready for installation from
 *   external source)
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::RequestInstall(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    if (!_installPackage.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->RequestInstall(_installPackage, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::RequestInstallAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, RequestInstallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_installPackage.validate()) {
        ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult error;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, error);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->RequestInstallAsync(_installPackage, _callback, _info);
}
/**
 * description: Method interface to request installation of the specific package located at a
 *   path specified via argument
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::RequestDownloadPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->RequestDownloadPackage(_downloadPackage, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::RequestDownloadPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, RequestDownloadPackageAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->RequestDownloadPackageAsync(_downloadPackage, _callback, _info);
}
/**
 * description: Method interface to request installation of the specific package located at a
 *   path specified via argument
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::RequestInstallPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->RequestInstallPackage(_installPackage, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::RequestInstallPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, RequestInstallPackageAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->RequestInstallPackageAsync(_installPackage, _callback, _info);
}
/**
 * description: To cancel the download which is already started.         Deprecated for future
 *   use , Instead use RequestDownload(CANCEL_DOWNLOAD)
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::CancelDownload(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->CancelDownload(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::CancelDownloadAsync(CancelDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->CancelDownloadAsync(_callback, _info);
}
/**
 * description: To cancel the installation which is already in progress.         Deprecated for
 *   future use , Instead use RequestInstall(CANCEL_INSTALLATION)
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::CancelInstall(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->CancelInstall(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::CancelInstallAsync(CancelInstallAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->CancelInstallAsync(_callback, _info);
}
/**
 * description: To enable or disable automatic download of the package from external source
 *   (e.g. OTA server or Mass storage device) in to the device cached.
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::SetAutomaticDownload(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetAutomaticDownload(_enableAutoDownload, _autoDownloadLimit, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::SetAutomaticDownloadAsync(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, SetAutomaticDownloadAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetAutomaticDownloadAsync(_enableAutoDownload, _autoDownloadLimit, _callback, _info);
}
/**
 * description: To get the current enable/disable status for automatic download.
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::GetAutomaticDownloadStatus(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_enableAutoDownload, uint32_t &_autoDownloadLimit, const CommonAPI::CallInfo *_info) {
    delegate_->GetAutomaticDownloadStatus(_internalCallStatus, _error, _enableAutoDownload, _autoDownloadLimit, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::GetAutomaticDownloadStatusAsync(GetAutomaticDownloadStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->GetAutomaticDownloadStatusAsync(_callback, _info);
}
/**
 * description: Request for activation of recently installed software ;                        
 *   Installation complete is notified via states INSTALLATION_COMPLETE or
 *   READY_FOR_ACTIVATION                        Post this API trigger , system
 *   will be restarted to new lifecycle to effect the new software
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::ActivateSoftware(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->ActivateSoftware(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::ActivateSoftwareAsync(ActivateSoftwareAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->ActivateSoftwareAsync(_callback, _info);
}
/**
 * description: To completely disable the software update feature. When the update is disbaled,
 *                           software update process will neither check for any
 *   updates on its own not process any APIs to serach for updates.
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::DisableSoftwareUpdate(const bool &_disable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->DisableSoftwareUpdate(_disable, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::DisableSoftwareUpdateAsync(const bool &_disable, DisableSoftwareUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->DisableSoftwareUpdateAsync(_disable, _callback, _info);
}
/**
 * description: retrieve if software update service is currently enabled or disabled
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::GetDisableSoftwareUpdate(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_disable, const CommonAPI::CallInfo *_info) {
    delegate_->GetDisableSoftwareUpdate(_internalCallStatus, _error, _disable, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::GetDisableSoftwareUpdateAsync(GetDisableSoftwareUpdateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->GetDisableSoftwareUpdateAsync(_callback, _info);
}
/**
 * description: To abort any on going search for updates.
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::AbortSearch(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->AbortSearch(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::AbortSearchAsync(AbortSearchAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->AbortSearchAsync(_callback, _info);
}
/**
 * description: To enable / disable automatic installation of the available/downloaded package
 *   without the confirmation from the client .
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::SetAutomaticInstallation(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->SetAutomaticInstallation(_enable, _internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::SetAutomaticInstallationAsync(const bool &_enable, SetAutomaticInstallationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->SetAutomaticInstallationAsync(_enable, _callback, _info);
}
/**
 * description: method trigger to reset the Software update states back to idle along with
 *   resetting the settings back to default.                        Clears any
 *   internal cache/status informations. If service is already in installation
 *   stage , request will not be processed
 */
template <typename ... _AttributeExtensions>
void SoftwareUpdateProxy<_AttributeExtensions...>::RequestFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info) {
    delegate_->RequestFactoryReset(_internalCallStatus, _error, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> SoftwareUpdateProxy<_AttributeExtensions...>::RequestFactoryResetAsync(RequestFactoryResetAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->RequestFactoryResetAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &SoftwareUpdateProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool SoftwareUpdateProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool SoftwareUpdateProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& SoftwareUpdateProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& SoftwareUpdateProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace swdl
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::swdl::SoftwareUpdateProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::swdl::SoftwareUpdateProxy<
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::SoftwareAvailableForDownloadAttrAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::SoftwareAvailableForInstallAttrAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::InstallProgressAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::DownloadProgressAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::ActivationResultAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::LastUpdateSearchTimeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::LastUpdateInstallTimeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::StatusAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::AutoDownloadAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::AutoDownloadSizeLimitAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::AutoInstallAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::AutoSearchAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::AutoSearchIntervalAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::swdl::SoftwareUpdateExtensions::AllowVersionDowngradeAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_2 = v1;

#endif // V1_COM_HARMAN_SWDL_Software_Update_PROXY_HPP_
