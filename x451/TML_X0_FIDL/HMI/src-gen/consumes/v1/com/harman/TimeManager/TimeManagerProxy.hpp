/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_TIMEMANAGER_Time_Manager_PROXY_HPP_
#define V1_COM_HARMAN_TIMEMANAGER_Time_Manager_PROXY_HPP_

#include <v1/com/harman/TimeManager/TimeManagerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace TimeManager {

template <typename ... _AttributeExtensions>
class TimeManagerProxy
    : virtual public TimeManager, 
      virtual public TimeManagerProxyBase,
      virtual public _AttributeExtensions... {
public:
    TimeManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~TimeManagerProxy();

    typedef TimeManager InterfaceType;


    /**
     * description: tzOffset   	    		This attribute is used to set and get the time zone offset.  
     *    		symbol = should be one of the value from the enum 		hours = should be the
     *   hrs valued 		min = should be the minutes value
     * author: Bhushan J
     */
    /**
     * Returns the wrapper class that provides access to the attribute tzOffset.
     */
    virtual TzOffsetAttribute& getTzOffsetAttribute() {
        return delegate_->getTzOffsetAttribute();
    }
    /**
     * description: systemTimeWithTz  	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 12Hr or 24Hr format.
     * author: Bhushan J
     */
    /**
     * Returns the wrapper class that provides access to the attribute systemTimeWithTz.
     */
    virtual SystemTimeWithTzAttribute& getSystemTimeWithTzAttribute() {
        return delegate_->getSystemTimeWithTzAttribute();
    }
    /**
     * description: systemTimeWithTz12Hr 	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 12hr format.
     * author: Tarun Thomas
     */
    /**
     * Returns the wrapper class that provides access to the attribute systemTimeWithTz12Hr.
     */
    virtual SystemTimeWithTz12HrAttribute& getSystemTimeWithTz12HrAttribute() {
        return delegate_->getSystemTimeWithTz12HrAttribute();
    }
    /**
     * description: systemTimeWithTz24Hr	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 24hr format.
     * author: Tarun Thomas
     */
    /**
     * Returns the wrapper class that provides access to the attribute systemTimeWithTz24Hr.
     */
    virtual SystemTimeWithTz24HrAttribute& getSystemTimeWithTz24HrAttribute() {
        return delegate_->getSystemTimeWithTz24HrAttribute();
    }
    /**
     * description: systemTimeUTC   	    		This attribute will be updated every 1 min with the
     *   system time update. This will reflect the UTC system time.
     * author: Bhushan J
     */
    /**
     * Returns the wrapper class that provides access to the attribute systemTimeUTC.
     */
    virtual SystemTimeUTCAttribute& getSystemTimeUTCAttribute() {
        return delegate_->getSystemTimeUTCAttribute();
    }
    /**
     * description: This attribute will be updated every 1 min with                             the
     *   system time in UTC. Time here is in 12hr format.
     * author: Tarun Thomas
     */
    /**
     * Returns the wrapper class that provides access to the attribute utcTime12Hr.
     */
    virtual UtcTime12HrAttribute& getUtcTime12HrAttribute() {
        return delegate_->getUtcTime12HrAttribute();
    }
    /**
     * description: This attribute will be updated every 1 min with                             the
     *   system time in UTC. Time here is in 24hr format.
     * author: Tarun Thomas
     */
    /**
     * Returns the wrapper class that provides access to the attribute utcTime24Hr.
     */
    virtual UtcTime24HrAttribute& getUtcTime24HrAttribute() {
        return delegate_->getUtcTime24HrAttribute();
    }
    /**
     * description: This attribute is used to know the current active                            
     *   time format. timeFormat will be updated on every                            
     *   change of time format using setTimeFormat() API.
     * author: Tarun Thomas
     */
    /**
     * Returns the wrapper class that provides access to the attribute timeFormat.
     */
    virtual TimeFormatAttribute& getTimeFormatAttribute() {
        return delegate_->getTimeFormatAttribute();
    }


    /**
     * description: disableTimeSource 		This method is used to let TM know about which source to
     *   disable.    		input: sourceName - valid configured source name. The
     *   configuration of TM should be refered for this.    		output: status - true if
     *   the source is disabled. false if source disabling falied.
     * author: Bhushan J
     * Calls disableTimeSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void disableTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls disableTimeSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> disableTimeSourceAsync(const std::string &_sourceName, DisableTimeSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getEnabledSources  		Get the list of enabled sources    		output:
     *   sourceNameList - Gets the list of the sourceNames which are currently enabled
     * author: Bhushan J
     * Calls getEnabledSources with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getEnabledSources(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_sourceNameList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getEnabledSources with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getEnabledSourcesAsync(GetEnabledSourcesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: selectTimeSource	 		Enable the time source    		input: sourceName - valid
     *   configured source name. The configuration of TM should be refered for this.   
     *   		output: holdOffTime - -1 or value greater than 0. The value will be -1 in
     *   case the selected source is not operational.    		Else the configured holdOff
     *   time will be returned.     		This method is used to enable a specific
     *   timeSource. Here TimeManager will not disable the other sources.   
     *   		Accordingly the source will be enabled by TM for fetching and sending the
     *   data to Chrony.
     * author: Bhushan J
     * Calls selectTimeSource with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void selectTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, int16_t &_holdOffTime, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls selectTimeSource with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> selectTimeSourceAsync(const std::string &_sourceName, SelectTimeSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: changeTM_State  		Change state of TM    		input: newState - valid state from
     *   the described TM_States.    		output: currState - Current state of the TM. If
     *   the provided newState is invalid with respect to the    		state transition the
     *   privious state will be kept unchanged and the same will be retured.
     * author: Bhushan J
     * Calls changeTM_State with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void changeTM_State(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_currState, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls changeTM_State with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> changeTM_StateAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, ChangeTM_StateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: changeTM_OperationalMode 	 		Change the operation mode    		input: newMode -
     *   valid mode from the described TM_operationalMode.    		output: currMode -
     *   Current operational mode TM is working after the change is made.
     * author: Bhushan J
     * Calls changeTM_OperationalMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void changeTM_OperationalMode(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_currMode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls changeTM_OperationalMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> changeTM_OperationalModeAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, ChangeTM_OperationalModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: updateSourceTime_wellFormed	 		Update time from a time source    		input:
     *   newTime - new time value which is defined time data structure.     		sourceId:
     *   Source ID as configured in TM configuration     		output: status - true:
     *   update is succesful, false:failure in the update. For failure there can   
     *   		be two issues. Either sourceId is not valid or provided newTime is not valid.
     * author: Bhushan J
     * Calls updateSourceTime_wellFormed with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateSourceTime_wellFormed(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateSourceTime_wellFormed with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSourceTime_wellFormedAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, UpdateSourceTime_wellFormedAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: updateSourceTime_UTC 	 		Update time from a time source    		input: newUTCTime
     *   - new time value in UTC format, sourceId: Source ID as configured in TM
     *   configuration     		output: status - true: update is succesful, false:failure
     *   in the update. For failure there can    		be two issues. Either sourceId is
     *   not valid or provided newTime is not valid.
     * author: Bhushan J
     * Calls updateSourceTime_UTC with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void updateSourceTime_UTC(const uint64_t &_newUTCTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls updateSourceTime_UTC with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> updateSourceTime_UTCAsync(const uint64_t &_newUTCTime, const std::string &_sourceId, UpdateSourceTime_UTCAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Get current format of the time
     * author: Tarun Thomas
     * Calls getTimeFormat with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getTimeFormat with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTimeFormatAsync(GetTimeFormatAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Set current format for the time
     * author: Tarun Thomas
     * Calls setTimeFormat with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setTimeFormat(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setTimeFormat with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setTimeFormatAsync(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, SetTimeFormatAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<TimeManagerProxyBase> delegate_;
};

typedef TimeManagerProxy<> TimeManagerProxyDefault;

namespace TimeManagerExtensions {
    /**
     * description: tzOffset   	    		This attribute is used to set and get the time zone offset.  
     *    		symbol = should be one of the value from the enum 		hours = should be the
     *   hrs valued 		min = should be the minutes value
     * author: Bhushan J
     */
    template <template <typename > class _ExtensionType>
    class TzOffsetAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::TzOffsetAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::TzOffsetAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        TzOffsetAttributeExtension() {}
    #endif
    
        TzOffsetAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getTzOffsetAttribute()) {
        }
    
        inline extension_type& getTzOffsetAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: systemTimeWithTz  	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 12Hr or 24Hr format.
     * author: Bhushan J
     */
    template <template <typename > class _ExtensionType>
    class SystemTimeWithTzAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::SystemTimeWithTzAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::SystemTimeWithTzAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SystemTimeWithTzAttributeExtension() {}
    #endif
    
        SystemTimeWithTzAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getSystemTimeWithTzAttribute()) {
        }
    
        inline extension_type& getSystemTimeWithTzAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: systemTimeWithTz12Hr 	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 12hr format.
     * author: Tarun Thomas
     */
    template <template <typename > class _ExtensionType>
    class SystemTimeWithTz12HrAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::SystemTimeWithTz12HrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::SystemTimeWithTz12HrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SystemTimeWithTz12HrAttributeExtension() {}
    #endif
    
        SystemTimeWithTz12HrAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getSystemTimeWithTz12HrAttribute()) {
        }
    
        inline extension_type& getSystemTimeWithTz12HrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: systemTimeWithTz24Hr	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 24hr format.
     * author: Tarun Thomas
     */
    template <template <typename > class _ExtensionType>
    class SystemTimeWithTz24HrAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::SystemTimeWithTz24HrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::SystemTimeWithTz24HrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SystemTimeWithTz24HrAttributeExtension() {}
    #endif
    
        SystemTimeWithTz24HrAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getSystemTimeWithTz24HrAttribute()) {
        }
    
        inline extension_type& getSystemTimeWithTz24HrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: systemTimeUTC   	    		This attribute will be updated every 1 min with the
     *   system time update. This will reflect the UTC system time.
     * author: Bhushan J
     */
    template <template <typename > class _ExtensionType>
    class SystemTimeUTCAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::SystemTimeUTCAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::SystemTimeUTCAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SystemTimeUTCAttributeExtension() {}
    #endif
    
        SystemTimeUTCAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getSystemTimeUTCAttribute()) {
        }
    
        inline extension_type& getSystemTimeUTCAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute will be updated every 1 min with                             the
     *   system time in UTC. Time here is in 12hr format.
     * author: Tarun Thomas
     */
    template <template <typename > class _ExtensionType>
    class UtcTime12HrAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::UtcTime12HrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::UtcTime12HrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UtcTime12HrAttributeExtension() {}
    #endif
    
        UtcTime12HrAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getUtcTime12HrAttribute()) {
        }
    
        inline extension_type& getUtcTime12HrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute will be updated every 1 min with                             the
     *   system time in UTC. Time here is in 24hr format.
     * author: Tarun Thomas
     */
    template <template <typename > class _ExtensionType>
    class UtcTime24HrAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::UtcTime24HrAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::UtcTime24HrAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UtcTime24HrAttributeExtension() {}
    #endif
    
        UtcTime24HrAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getUtcTime24HrAttribute()) {
        }
    
        inline extension_type& getUtcTime24HrAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute is used to know the current active                            
     *   time format. timeFormat will be updated on every                            
     *   change of time format using setTimeFormat() API.
     * author: Tarun Thomas
     */
    template <template <typename > class _ExtensionType>
    class TimeFormatAttributeExtension {
     public:
        typedef _ExtensionType<TimeManagerProxyBase::TimeFormatAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<TimeManagerProxyBase::TimeFormatAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        TimeFormatAttributeExtension() {}
    #endif
    
        TimeFormatAttributeExtension(TimeManagerProxyBase& proxy): attributeExtension_(proxy.getTimeFormatAttribute()) {
        }
    
        inline extension_type& getTimeFormatAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace TimeManagerExtensions

//
// TimeManagerProxy Implementation
//
template <typename ... _AttributeExtensions>
TimeManagerProxy<_AttributeExtensions...>::TimeManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<TimeManagerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<TimeManagerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
TimeManagerProxy<_AttributeExtensions...>::~TimeManagerProxy() {
}

/**
 * description: disableTimeSource 		This method is used to let TM know about which source to
 *   disable.    		input: sourceName - valid configured source name. The
 *   configuration of TM should be refered for this.    		output: status - true if
 *   the source is disabled. false if source disabling falied.
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::disableTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
    delegate_->disableTimeSource(_sourceName, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::disableTimeSourceAsync(const std::string &_sourceName, DisableTimeSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->disableTimeSourceAsync(_sourceName, _callback, _info);
}
/**
 * description: getEnabledSources  		Get the list of enabled sources    		output:
 *   sourceNameList - Gets the list of the sourceNames which are currently enabled
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::getEnabledSources(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_sourceNameList, const CommonAPI::CallInfo *_info) {
    delegate_->getEnabledSources(_internalCallStatus, _sourceNameList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::getEnabledSourcesAsync(GetEnabledSourcesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getEnabledSourcesAsync(_callback, _info);
}
/**
 * description: selectTimeSource	 		Enable the time source    		input: sourceName - valid
 *   configured source name. The configuration of TM should be refered for this.   
 *   		output: holdOffTime - -1 or value greater than 0. The value will be -1 in
 *   case the selected source is not operational.    		Else the configured holdOff
 *   time will be returned.     		This method is used to enable a specific
 *   timeSource. Here TimeManager will not disable the other sources.   
 *   		Accordingly the source will be enabled by TM for fetching and sending the
 *   data to Chrony.
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::selectTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, int16_t &_holdOffTime, const CommonAPI::CallInfo *_info) {
    delegate_->selectTimeSource(_sourceName, _internalCallStatus, _holdOffTime, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::selectTimeSourceAsync(const std::string &_sourceName, SelectTimeSourceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->selectTimeSourceAsync(_sourceName, _callback, _info);
}
/**
 * description: changeTM_State  		Change state of TM    		input: newState - valid state from
 *   the described TM_States.    		output: currState - Current state of the TM. If
 *   the provided newState is invalid with respect to the    		state transition the
 *   privious state will be kept unchanged and the same will be retured.
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::changeTM_State(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_currState, const CommonAPI::CallInfo *_info) {
    if (!_newState.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->changeTM_State(_newState, _internalCallStatus, _currState, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::changeTM_StateAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, ChangeTM_StateAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_newState.validate()) {
        ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States currState = ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States::TMSTATE_IDLE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, currState);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->changeTM_StateAsync(_newState, _callback, _info);
}
/**
 * description: changeTM_OperationalMode 	 		Change the operation mode    		input: newMode -
 *   valid mode from the described TM_operationalMode.    		output: currMode -
 *   Current operational mode TM is working after the change is made.
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::changeTM_OperationalMode(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_currMode, const CommonAPI::CallInfo *_info) {
    if (!_newMode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->changeTM_OperationalMode(_newMode, _internalCallStatus, _currMode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::changeTM_OperationalModeAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, ChangeTM_OperationalModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_newMode.validate()) {
        ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode currMode = ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode::TM_OP_PRIORITY_SOURCE;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, currMode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->changeTM_OperationalModeAsync(_newMode, _callback, _info);
}
/**
 * description: updateSourceTime_wellFormed	 		Update time from a time source    		input:
 *   newTime - new time value which is defined time data structure.     		sourceId:
 *   Source ID as configured in TM configuration     		output: status - true:
 *   update is succesful, false:failure in the update. For failure there can   
 *   		be two issues. Either sourceId is not valid or provided newTime is not valid.
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::updateSourceTime_wellFormed(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
    delegate_->updateSourceTime_wellFormed(_newTime, _sourceId, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::updateSourceTime_wellFormedAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, UpdateSourceTime_wellFormedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateSourceTime_wellFormedAsync(_newTime, _sourceId, _callback, _info);
}
/**
 * description: updateSourceTime_UTC 	 		Update time from a time source    		input: newUTCTime
 *   - new time value in UTC format, sourceId: Source ID as configured in TM
 *   configuration     		output: status - true: update is succesful, false:failure
 *   in the update. For failure there can    		be two issues. Either sourceId is
 *   not valid or provided newTime is not valid.
 * author: Bhushan J
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::updateSourceTime_UTC(const uint64_t &_newUTCTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
    delegate_->updateSourceTime_UTC(_newUTCTime, _sourceId, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::updateSourceTime_UTCAsync(const uint64_t &_newUTCTime, const std::string &_sourceId, UpdateSourceTime_UTCAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->updateSourceTime_UTCAsync(_newUTCTime, _sourceId, _callback, _info);
}
/**
 * description: Get current format of the time
 * author: Tarun Thomas
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, const CommonAPI::CallInfo *_info) {
    delegate_->getTimeFormat(_internalCallStatus, _format, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::getTimeFormatAsync(GetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getTimeFormatAsync(_callback, _info);
}
/**
 * description: Set current format for the time
 * author: Tarun Thomas
 */
template <typename ... _AttributeExtensions>
void TimeManagerProxy<_AttributeExtensions...>::setTimeFormat(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info) {
    if (!_format.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setTimeFormat(_sourceName, _format, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> TimeManagerProxy<_AttributeExtensions...>::setTimeFormatAsync(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, SetTimeFormatAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_format.validate()) {
        bool status = false;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, status);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setTimeFormatAsync(_sourceName, _format, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &TimeManagerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool TimeManagerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool TimeManagerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& TimeManagerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& TimeManagerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace TimeManager
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::TimeManager::TimeManagerProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::TimeManager::TimeManagerProxy<
            ::v1::com::harman::TimeManager::TimeManagerExtensions::TzOffsetAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::SystemTimeWithTzAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::SystemTimeWithTz12HrAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::SystemTimeWithTz24HrAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::SystemTimeUTCAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::UtcTime12HrAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::UtcTime24HrAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::TimeManager::TimeManagerExtensions::TimeFormatAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_3 = v1;

#endif // V1_COM_HARMAN_TIMEMANAGER_Time_Manager_PROXY_HPP_
