/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_Types_HPP_
#define V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace layermanager {

struct LayerManagerTypes {
    
    struct tEventType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            EVENT_CREATED = 1,
            EVENT_DESTROYED = 2,
            EVENT_CONTENT_AVAILABLE = 4,
            EVENT_CONTENT_REMOVED = 8,
            EVENT_CONFIGURED = 16,
            EVENT_INPUTFOCUS_GAINED = 32,
            EVENT_INPUTFOCUS_LOST = 64
        };
        
        tEventType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::EVENT_CREATED)) {}
        tEventType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::EVENT_CREATED):
                case static_cast<int32_t>(Literal::EVENT_DESTROYED):
                case static_cast<int32_t>(Literal::EVENT_CONTENT_AVAILABLE):
                case static_cast<int32_t>(Literal::EVENT_CONTENT_REMOVED):
                case static_cast<int32_t>(Literal::EVENT_CONFIGURED):
                case static_cast<int32_t>(Literal::EVENT_INPUTFOCUS_GAINED):
                case static_cast<int32_t>(Literal::EVENT_INPUTFOCUS_LOST):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const tEventType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const tEventType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const tEventType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const tEventType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const tEventType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const tEventType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct tObjectType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            TYPE_DISPLAY = 1,
            TYPE_LAYER = 2,
            TYPE_SURFACE = 4
        };
        
        tObjectType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::TYPE_DISPLAY)) {}
        tObjectType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::TYPE_DISPLAY):
                case static_cast<int32_t>(Literal::TYPE_LAYER):
                case static_cast<int32_t>(Literal::TYPE_SURFACE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const tObjectType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const tObjectType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const tObjectType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const tObjectType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const tObjectType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const tObjectType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct tPropertyType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            PROPERTY_VISIBILITY = 1,
            PROPERTY_OPACITY = 2,
            PROPERTY_ORIENTATION = 4,
            PROPERTY_SRCRECT = 8,
            PROPERTY_DESTRECT = 16,
            PROPERTY_POSITION = 32,
            PROPERTY_SIZE = 64,
            PROPERTY_PIXELFORMAT = 128
        };
        
        tPropertyType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::PROPERTY_VISIBILITY)) {}
        tPropertyType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::PROPERTY_VISIBILITY):
                case static_cast<int32_t>(Literal::PROPERTY_OPACITY):
                case static_cast<int32_t>(Literal::PROPERTY_ORIENTATION):
                case static_cast<int32_t>(Literal::PROPERTY_SRCRECT):
                case static_cast<int32_t>(Literal::PROPERTY_DESTRECT):
                case static_cast<int32_t>(Literal::PROPERTY_POSITION):
                case static_cast<int32_t>(Literal::PROPERTY_SIZE):
                case static_cast<int32_t>(Literal::PROPERTY_PIXELFORMAT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const tPropertyType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const tPropertyType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const tPropertyType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const tPropertyType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const tPropertyType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const tPropertyType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct tPosition : CommonAPI::Struct<uint32_t, uint32_t> {
    	
    	tPosition() {
    	}
    	tPosition(const uint32_t &_x, const uint32_t &_y)
    	{
    		std::get<0>(values_) = _x;
    		std::get<1>(values_) = _y;
    	}
    	inline const uint32_t &getX() const { return std::get<0>(values_); }
    	inline void setX(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getY() const { return std::get<1>(values_); }
    	inline void setY(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const tPosition& _other) const {
                return (getX() == _other.getX() && getY() == _other.getY());
        }
    	inline bool operator!=(const tPosition &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct tRectangle : CommonAPI::Struct<uint32_t, uint32_t, uint32_t, uint32_t> {
    	
    	tRectangle() {
    	}
    	tRectangle(const uint32_t &_x, const uint32_t &_y, const uint32_t &_width, const uint32_t &_height)
    	{
    		std::get<0>(values_) = _x;
    		std::get<1>(values_) = _y;
    		std::get<2>(values_) = _width;
    		std::get<3>(values_) = _height;
    	}
    	inline const uint32_t &getX() const { return std::get<0>(values_); }
    	inline void setX(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getY() const { return std::get<1>(values_); }
    	inline void setY(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline const uint32_t &getWidth() const { return std::get<2>(values_); }
    	inline void setWidth(const uint32_t &_value) { std::get<2>(values_) = _value; }
    	inline const uint32_t &getHeight() const { return std::get<3>(values_); }
    	inline void setHeight(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const tRectangle& _other) const {
                return (getX() == _other.getX() && getY() == _other.getY() && getWidth() == _other.getWidth() && getHeight() == _other.getHeight());
        }
    	inline bool operator!=(const tRectangle &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef CommonAPI::Variant<bool, float, tPosition, tRectangle>  tPropertyData;
    struct tProperty : CommonAPI::Struct<tObjectType, tPropertyType, tPropertyData> {
    	
    	tProperty() {
    	}
    	tProperty(const tObjectType &_objectType, const tPropertyType &_propertyType, const tPropertyData &_data)
    	{
    		std::get<0>(values_) = _objectType;
    		std::get<1>(values_) = _propertyType;
    		std::get<2>(values_) = _data;
    	}
    	inline const tObjectType &getObjectType() const { return std::get<0>(values_); }
    	inline void setObjectType(const tObjectType &_value) { std::get<0>(values_) = _value; }
    	inline const tPropertyType &getPropertyType() const { return std::get<1>(values_); }
    	inline void setPropertyType(const tPropertyType &_value) { std::get<1>(values_) = _value; }
    	inline const tPropertyData &getData() const { return std::get<2>(values_); }
    	inline void setData(const tPropertyData &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const tProperty& _other) const {
                return (getObjectType() == _other.getObjectType() && getPropertyType() == _other.getPropertyType() && getData() == _other.getData());
        }
    	inline bool operator!=(const tProperty &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct tResult : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RESULT_OK = 0,
            RESULT_NOTALLOWED = 1,
            RESULT_NOSUCHOBJECT = 2
        };
        
        tResult() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RESULT_OK)) {}
        tResult(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RESULT_OK):
                case static_cast<int32_t>(Literal::RESULT_NOTALLOWED):
                case static_cast<int32_t>(Literal::RESULT_NOSUCHOBJECT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const tResult &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const tResult &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const tResult &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const tResult &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const tResult &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const tResult &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.layermanager.LayerManagerTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct LayerManagerTypes

} // namespace layermanager
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for tEventType
    template<>
    struct hash<::v1::com::harman::layermanager::LayerManagerTypes::tEventType> {
        inline size_t operator()(const ::v1::com::harman::layermanager::LayerManagerTypes::tEventType& tEventType) const {
            return static_cast<int32_t>(tEventType);
        }
    };
    //Hash for tObjectType
    template<>
    struct hash<::v1::com::harman::layermanager::LayerManagerTypes::tObjectType> {
        inline size_t operator()(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType& tObjectType) const {
            return static_cast<int32_t>(tObjectType);
        }
    };
    //Hash for tPropertyType
    template<>
    struct hash<::v1::com::harman::layermanager::LayerManagerTypes::tPropertyType> {
        inline size_t operator()(const ::v1::com::harman::layermanager::LayerManagerTypes::tPropertyType& tPropertyType) const {
            return static_cast<int32_t>(tPropertyType);
        }
    };
    //Hash for tResult
    template<>
    struct hash<::v1::com::harman::layermanager::LayerManagerTypes::tResult> {
        inline size_t operator()(const ::v1::com::harman::layermanager::LayerManagerTypes::tResult& tResult) const {
            return static_cast<int32_t>(tResult);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_Types_HPP_
