/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_PROXY_HPP_
#define V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_PROXY_HPP_

#include <v1/com/harman/layermanager/LayerManagerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace layermanager {

template <typename ... _AttributeExtensions>
class LayerManagerProxy
    : virtual public LayerManager, 
      virtual public LayerManagerProxyBase,
      virtual public _AttributeExtensions... {
public:
    LayerManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~LayerManagerProxy();

    typedef LayerManager InterfaceType;



    /**
     * description: Shall be triggered for registered clients based on the events of the registered
     *   layers/surfaces. 	 		returns:	  tEvent
     */
    /**
     * Returns the wrapper class that provides access to the broadcast eventUpdate.
     */
    virtual EventUpdateSelectiveEvent& getEventUpdateSelectiveEvent() {
        return delegate_->getEventUpdateSelectiveEvent();
    }
    /**
     * description: Shall be triggered for registered clients based on the change in properties of
     *   the registered layers/surfaces. 	 		returns:	  tEvent
     */
    /**
     * Returns the wrapper class that provides access to the broadcast propertyUpdate.
     */
    virtual PropertyUpdateSelectiveEvent& getPropertyUpdateSelectiveEvent() {
        return delegate_->getPropertyUpdateSelectiveEvent();
    }

    /**
     * description: This is different from the Common API broadcast/attribute subscription. Client
     *   can subscribe to events like creation,destruction etc for a particular
     *   surface/layer/display. 					  The API will always be successfull, and will
     *   cause conditional broadcasts to be triggered to the registering clients.   
     *   					  Before calling this function ensure that you have subscribed to the
     *   propertyUpdate broadcast.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: name: 		  The string name for the desired object. The string name can be
     *   checked in LayerManager.conf
     * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
     * param: eventFilter:	  Bitmask combination of events interested in (Look at tEventType)
     *                      returns:	  nothing
     * Calls subscribeEvents with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void subscribeEvents(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, const uint64_t &_eventFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * Calls setProperty with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setProperty(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setProperty with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPropertyAsync(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, SetPropertyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This is different from the Common API broadcast/attribute subscription. Client
     *   can subscribe to events like creation,visibility change, resize etc for a
     *   particular surface/layer. 					  The API will always be successfull, and will
     *   cause conditional broadcasts to be triggered to the registering clients.   
     *   					  Before calling this function ensure that you have subscribed to the
     *   propertyUpdate broadcast.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: id: 			  The string identifier for the desired object. The string identifier
     *   can be checked in LayerManager.conf
     * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
     * param: propFilter:	  Bitmask combination of properties interested in (Look at
     *   tPropertyType)                    returns:	  nothing
     * Calls subscribeProps with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void subscribeProps(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_id, const uint64_t &_propFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: Removes all event / property subscription for a client.             returns:	 
     *   Nothing..
     * Calls unsubscribeAll with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void unsubscribeAll(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls unsubscribeAll with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> unsubscribeAllAsync(UnsubscribeAllAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Initiate a capture operation for the display,layer or surface. Will only return
     *   once the operation finished successfully/failed. 		Add periodic.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: name: 		  The string name for the desired object. The string identifier can be
     *   checked in LayerManager.conf                    returns:	  path: 		  If
     *   successfull, returns the path to the PNG file.           returns:    
     *   result:		  Status of operation.
     * Calls screenshot with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void screenshot(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls screenshot with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> screenshotAsync(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, ScreenshotAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API will set the visibility of a layer to true, if no higher priority
     *   layers are not currently visible.   				      There are no implicit z order /
     *   alpha changes.  				      Any layers at the same priority level will be hidden
     *   implicitly.  					  For more specific use cases, use the command API.
     * param: :layerID	Layer ID matching in layermanager.conf	       	 		returns:	  result :
     *   Check enumeration for more details.
     * Calls showLayerSafe with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void showLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls showLayerSafe with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> showLayerSafeAsync(const std::string &_layerID, ShowLayerSafeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API will set the visibility of a layer to false. If any previous layer can
     *   be shown on screen, it is made visible.
     * param: :layerID	Layer ID matching in layermanager.conf 			returns:	  result : Check
     *   enumeration for more details.
     * Calls hideLayerSafe with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hideLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hideLayerSafe with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hideLayerSafeAsync(const std::string &_layerID, HideLayerSafeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API will set the visibility of a surface to true. The surface can be
     *   hidden again if desired through the hideSurface interface.
     * param: surfaceID: surface ID matching in layermanager.conf
     * param: bestGuessAttach: If set to true, this parameter causes the layer manager to
     *   find an appropriate "visible" layer to attach this surface to. (before being
     *   shown).  							The bestGuessSurface must be defined in the "supportedlayers"
     *   attribute in the layermanager config. The attach will always be done to the
     *   first visible layer found in the 							 "supportedlayers" list. If no visible
     *   Layer is found to which the surface can be attached, then the API will fail. 
     *   	       	 		returns:	  result : Check enumeration for more details.
     * Calls showSurface with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void showSurface(const std::string &_surfaceID, const bool &_bestGuessAttach, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls showSurface with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> showSurfaceAsync(const std::string &_surfaceID, const bool &_bestGuessAttach, ShowSurfaceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API will set the visibility of a surface to false.
     * param: surfaceID: surface ID matching in layermanager.conf 			returns:	  result :
     *   Check enumeration for more details.
     * Calls hideSurface with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void hideSurface(const std::string &_surfaceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls hideSurface with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> hideSurfaceAsync(const std::string &_surfaceID, HideSurfaceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Can be used to run any arbitrary command sequence. Command Sequences can be
     *   defined in LayerManagerCommands.ini file
     * param: :command	Cammand Sequence defined in LayerManagerCommands.ini 	       	
     *   		returns:	  result : Check enumeration for more details.
     * Calls runCommand with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void runCommand(const std::string &_command, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls runCommand with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> runCommandAsync(const std::string &_command, RunCommandAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<LayerManagerProxyBase> delegate_;
};

typedef LayerManagerProxy<> LayerManagerProxyDefault;


//
// LayerManagerProxy Implementation
//
template <typename ... _AttributeExtensions>
LayerManagerProxy<_AttributeExtensions...>::LayerManagerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<LayerManagerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<LayerManagerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
LayerManagerProxy<_AttributeExtensions...>::~LayerManagerProxy() {
}

/**
 * description: This is different from the Common API broadcast/attribute subscription. Client
 *   can subscribe to events like creation,destruction etc for a particular
 *   surface/layer/display. 					  The API will always be successfull, and will
 *   cause conditional broadcasts to be triggered to the registering clients.   
 *   					  Before calling this function ensure that you have subscribed to the
 *   propertyUpdate broadcast.
 * param: type: 		  The passed identifier is a surface/layer/display
 * param: name: 		  The string name for the desired object. The string name can be
 *   checked in LayerManager.conf
 * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
 * param: eventFilter:	  Bitmask combination of events interested in (Look at tEventType)
 *                      returns:	  nothing
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::subscribeEvents(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, const uint64_t &_eventFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->subscribeEvents(_type, _name, _eventFilter, _isSubscribe, _internalCallStatus);
}
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::setProperty(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->setProperty(_property, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::setPropertyAsync(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, SetPropertyAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPropertyAsync(_property, _callback, _info);
}
/**
 * description: This is different from the Common API broadcast/attribute subscription. Client
 *   can subscribe to events like creation,visibility change, resize etc for a
 *   particular surface/layer. 					  The API will always be successfull, and will
 *   cause conditional broadcasts to be triggered to the registering clients.   
 *   					  Before calling this function ensure that you have subscribed to the
 *   propertyUpdate broadcast.
 * param: type: 		  The passed identifier is a surface/layer/display
 * param: id: 			  The string identifier for the desired object. The string identifier
 *   can be checked in LayerManager.conf
 * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
 * param: propFilter:	  Bitmask combination of properties interested in (Look at
 *   tPropertyType)                    returns:	  nothing
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::subscribeProps(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_id, const uint64_t &_propFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->subscribeProps(_type, _id, _propFilter, _isSubscribe, _internalCallStatus);
}
/**
 * description: Removes all event / property subscription for a client.             returns:	 
 *   Nothing..
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::unsubscribeAll(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->unsubscribeAll(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::unsubscribeAllAsync(UnsubscribeAllAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->unsubscribeAllAsync(_callback, _info);
}
/**
 * description: Initiate a capture operation for the display,layer or surface. Will only return
 *   once the operation finished successfully/failed. 		Add periodic.
 * param: type: 		  The passed identifier is a surface/layer/display
 * param: name: 		  The string name for the desired object. The string identifier can be
 *   checked in LayerManager.conf                    returns:	  path: 		  If
 *   successfull, returns the path to the PNG file.           returns:    
 *   result:		  Status of operation.
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::screenshot(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->screenshot(_type, _name, _internalCallStatus, _path, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::screenshotAsync(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, ScreenshotAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_type.validate()) {
        std::string path = "";
        ::v1::com::harman::layermanager::LayerManagerTypes::tResult result = ::v1::com::harman::layermanager::LayerManagerTypes::tResult::RESULT_OK;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, path, result);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->screenshotAsync(_type, _name, _callback, _info);
}
/**
 * description: This API will set the visibility of a layer to true, if no higher priority
 *   layers are not currently visible.   				      There are no implicit z order /
 *   alpha changes.  				      Any layers at the same priority level will be hidden
 *   implicitly.  					  For more specific use cases, use the command API.
 * param: :layerID	Layer ID matching in layermanager.conf	       	 		returns:	  result :
 *   Check enumeration for more details.
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::showLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->showLayerSafe(_layerID, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::showLayerSafeAsync(const std::string &_layerID, ShowLayerSafeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->showLayerSafeAsync(_layerID, _callback, _info);
}
/**
 * description: This API will set the visibility of a layer to false. If any previous layer can
 *   be shown on screen, it is made visible.
 * param: :layerID	Layer ID matching in layermanager.conf 			returns:	  result : Check
 *   enumeration for more details.
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::hideLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->hideLayerSafe(_layerID, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::hideLayerSafeAsync(const std::string &_layerID, HideLayerSafeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hideLayerSafeAsync(_layerID, _callback, _info);
}
/**
 * description: This API will set the visibility of a surface to true. The surface can be
 *   hidden again if desired through the hideSurface interface.
 * param: surfaceID: surface ID matching in layermanager.conf
 * param: bestGuessAttach: If set to true, this parameter causes the layer manager to
 *   find an appropriate "visible" layer to attach this surface to. (before being
 *   shown).  							The bestGuessSurface must be defined in the "supportedlayers"
 *   attribute in the layermanager config. The attach will always be done to the
 *   first visible layer found in the 							 "supportedlayers" list. If no visible
 *   Layer is found to which the surface can be attached, then the API will fail. 
 *   	       	 		returns:	  result : Check enumeration for more details.
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::showSurface(const std::string &_surfaceID, const bool &_bestGuessAttach, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->showSurface(_surfaceID, _bestGuessAttach, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::showSurfaceAsync(const std::string &_surfaceID, const bool &_bestGuessAttach, ShowSurfaceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->showSurfaceAsync(_surfaceID, _bestGuessAttach, _callback, _info);
}
/**
 * description: This API will set the visibility of a surface to false.
 * param: surfaceID: surface ID matching in layermanager.conf 			returns:	  result :
 *   Check enumeration for more details.
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::hideSurface(const std::string &_surfaceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->hideSurface(_surfaceID, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::hideSurfaceAsync(const std::string &_surfaceID, HideSurfaceAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->hideSurfaceAsync(_surfaceID, _callback, _info);
}
/**
 * description: Can be used to run any arbitrary command sequence. Command Sequences can be
 *   defined in LayerManagerCommands.ini file
 * param: :command	Cammand Sequence defined in LayerManagerCommands.ini 	       	
 *   		returns:	  result : Check enumeration for more details.
 */
template <typename ... _AttributeExtensions>
void LayerManagerProxy<_AttributeExtensions...>::runCommand(const std::string &_command, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info) {
    delegate_->runCommand(_command, _internalCallStatus, _result, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> LayerManagerProxy<_AttributeExtensions...>::runCommandAsync(const std::string &_command, RunCommandAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->runCommandAsync(_command, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &LayerManagerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool LayerManagerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool LayerManagerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& LayerManagerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& LayerManagerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace layermanager
} // namespace harman
} // namespace com
} // namespace v1



// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_PROXY_HPP_
