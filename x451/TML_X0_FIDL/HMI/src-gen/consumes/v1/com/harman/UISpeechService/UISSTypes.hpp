/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_UISPEECHSERVICE_UISS_Types_HPP_
#define V1_COM_HARMAN_UISPEECHSERVICE_UISS_Types_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace UISpeechService {

struct UISSTypes {
    
    struct eReturnCode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_OK = 0,
            E_UNKNOWN = 1,
            E_UNSUPPORTED_DOMAIN = 2,
            E_AUDIO_MANAGER_ERROR = 3,
            E_INVALID_PARAMS = 4,
            E_TTS_ENGINE_ERROR = 5,
            E_TTS_NOT_READY = 6,
            E_TTS_LANGUAGE_LOADING = 7,
            E_TTS_LANGUAGE_NOT_SUPPORTED = 8
        };
        
        eReturnCode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_OK)) {}
        eReturnCode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_OK):
                case static_cast<int32_t>(Literal::E_UNKNOWN):
                case static_cast<int32_t>(Literal::E_UNSUPPORTED_DOMAIN):
                case static_cast<int32_t>(Literal::E_AUDIO_MANAGER_ERROR):
                case static_cast<int32_t>(Literal::E_INVALID_PARAMS):
                case static_cast<int32_t>(Literal::E_TTS_ENGINE_ERROR):
                case static_cast<int32_t>(Literal::E_TTS_NOT_READY):
                case static_cast<int32_t>(Literal::E_TTS_LANGUAGE_LOADING):
                case static_cast<int32_t>(Literal::E_TTS_LANGUAGE_NOT_SUPPORTED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eReturnCode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eReturnCode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eReturnCode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eReturnCode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eReturnCode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eReturnCode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ePlayState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_NOTPLAYING = 0,
            E_PLAYSTART = 1,
            E_PLAYING = 2,
            E_PLAYEND = 3,
            E_ABORTED = 4,
            E_PLAYERROR = 5
        };
        
        ePlayState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_NOTPLAYING)) {}
        ePlayState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_NOTPLAYING):
                case static_cast<int32_t>(Literal::E_PLAYSTART):
                case static_cast<int32_t>(Literal::E_PLAYING):
                case static_cast<int32_t>(Literal::E_PLAYEND):
                case static_cast<int32_t>(Literal::E_ABORTED):
                case static_cast<int32_t>(Literal::E_PLAYERROR):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ePlayState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ePlayState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ePlayState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ePlayState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ePlayState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ePlayState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct eVRStateEnum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_StateInitBegin = 0,
            E_StateStandby = 1,
            E_StatePrompting = 2,
            E_VRStateListening = 3,
            E_VRStateAccepting = 4,
            E_VRStateProcessing = 5,
            E_VRStateRecoSuccess = 6,
            E_VRStateRecoFailed = 7,
            E_VRStateG2PBegin = 8,
            E_VRStateG2PEnd = 9,
            E_VRStateRecoSuccessBackground = 10,
            E_VRStateInitEnd = 11,
            E_VRStateSessioBegin = 12,
            E_VRStateSessioEnd = 13,
            E_VRStateLanguageLoadBegin = 14,
            E_VRStateLanguageLoadEnd = 15,
            E_VRStateLanguageWaitingBegin = 16,
            E_VRStateLanguageWaitingEnd = 17,
            E_VRStateTTSLanguageLoadBegin = 18,
            E_VRStateTTSLanguageLoadEnd = 19,
            E_VRStateTTSLanguageWaitingBegin = 20,
            E_VRStateTTSLanguageWaitingEnd = 21,
            E_VRStateNone = 22,
            E_VRStateInvalid = 23
        };
        
        eVRStateEnum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_StateInitBegin)) {}
        eVRStateEnum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_StateInitBegin):
                case static_cast<int32_t>(Literal::E_StateStandby):
                case static_cast<int32_t>(Literal::E_StatePrompting):
                case static_cast<int32_t>(Literal::E_VRStateListening):
                case static_cast<int32_t>(Literal::E_VRStateAccepting):
                case static_cast<int32_t>(Literal::E_VRStateProcessing):
                case static_cast<int32_t>(Literal::E_VRStateRecoSuccess):
                case static_cast<int32_t>(Literal::E_VRStateRecoFailed):
                case static_cast<int32_t>(Literal::E_VRStateG2PBegin):
                case static_cast<int32_t>(Literal::E_VRStateG2PEnd):
                case static_cast<int32_t>(Literal::E_VRStateRecoSuccessBackground):
                case static_cast<int32_t>(Literal::E_VRStateInitEnd):
                case static_cast<int32_t>(Literal::E_VRStateSessioBegin):
                case static_cast<int32_t>(Literal::E_VRStateSessioEnd):
                case static_cast<int32_t>(Literal::E_VRStateLanguageLoadBegin):
                case static_cast<int32_t>(Literal::E_VRStateLanguageLoadEnd):
                case static_cast<int32_t>(Literal::E_VRStateLanguageWaitingBegin):
                case static_cast<int32_t>(Literal::E_VRStateLanguageWaitingEnd):
                case static_cast<int32_t>(Literal::E_VRStateTTSLanguageLoadBegin):
                case static_cast<int32_t>(Literal::E_VRStateTTSLanguageLoadEnd):
                case static_cast<int32_t>(Literal::E_VRStateTTSLanguageWaitingBegin):
                case static_cast<int32_t>(Literal::E_VRStateTTSLanguageWaitingEnd):
                case static_cast<int32_t>(Literal::E_VRStateNone):
                case static_cast<int32_t>(Literal::E_VRStateInvalid):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eVRStateEnum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eVRStateEnum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eVRStateEnum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eVRStateEnum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eVRStateEnum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eVRStateEnum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Structure of playstate and domain
     */
    struct sTTSPlayState : CommonAPI::Struct<ePlayState, std::string> {
    	
    	sTTSPlayState() {
    	}
    	sTTSPlayState(const ePlayState &_playState, const std::string &_ttsDomain)
    	{
    		std::get<0>(values_) = _playState;
    		std::get<1>(values_) = _ttsDomain;
    	}
    	inline const ePlayState &getPlayState() const { return std::get<0>(values_); }
    	inline void setPlayState(const ePlayState &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getTtsDomain() const { return std::get<1>(values_); }
    	inline void setTtsDomain(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sTTSPlayState& _other) const {
                return (getPlayState() == _other.getPlayState() && getTtsDomain() == _other.getTtsDomain());
        }
    	inline bool operator!=(const sTTSPlayState &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Structure of ttsAvailable
     */
    struct sTTSAvailable : CommonAPI::Struct<bool, std::string> {
    	
    	sTTSAvailable() {
    		std::get<0>(values_) = false;
    	}
    	sTTSAvailable(const bool &_available, const std::string &_reason)
    	{
    		std::get<0>(values_) = _available;
    		std::get<1>(values_) = _reason;
    	}
    	inline const bool &getAvailable() const { return std::get<0>(values_); }
    	inline void setAvailable(const bool _value) { std::get<0>(values_) = _value; }
    	inline const std::string &getReason() const { return std::get<1>(values_); }
    	inline void setReason(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sTTSAvailable& _other) const {
                return (getAvailable() == _other.getAvailable() && getReason() == _other.getReason());
        }
    	inline bool operator!=(const sTTSAvailable &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sVoiceRecognition : CommonAPI::Struct<eVRStateEnum> {
    	
    	sVoiceRecognition() {
    	}
    	sVoiceRecognition(const eVRStateEnum &_vrState)
    	{
    		std::get<0>(values_) = _vrState;
    	}
    	inline const eVRStateEnum &getVrState() const { return std::get<0>(values_); }
    	inline void setVrState(const eVRStateEnum &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const sVoiceRecognition& _other) const {
                return (getVrState() == _other.getVrState());
        }
    	inline bool operator!=(const sVoiceRecognition &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct eVRDialogActive : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            E_VR_DIALOG_INACTIVE = 0,
            E_VR_DIALOG_ACTIVE = 1
        };
        
        eVRDialogActive() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::E_VR_DIALOG_INACTIVE)) {}
        eVRDialogActive(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::E_VR_DIALOG_INACTIVE):
                case static_cast<int32_t>(Literal::E_VR_DIALOG_ACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eVRDialogActive &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eVRDialogActive &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eVRDialogActive &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eVRDialogActive &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eVRDialogActive &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eVRDialogActive &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct sVRAvailable : CommonAPI::Struct<bool, std::string> {
    	
    	sVRAvailable() {
    		std::get<0>(values_) = false;
    	}
    	sVRAvailable(const bool &_availableState, const std::string &_reason)
    	{
    		std::get<0>(values_) = _availableState;
    		std::get<1>(values_) = _reason;
    	}
    	inline const bool &getAvailableState() const { return std::get<0>(values_); }
    	inline void setAvailableState(const bool _value) { std::get<0>(values_) = _value; }
    	inline const std::string &getReason() const { return std::get<1>(values_); }
    	inline void setReason(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const sVRAvailable& _other) const {
                return (getAvailableState() == _other.getAvailableState() && getReason() == _other.getReason());
        }
    	inline bool operator!=(const sVRAvailable &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.UISpeechService.UISSTypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(1, 0);
}

}; // struct UISSTypes

} // namespace UISpeechService
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
}


namespace std {
    //Hash for eReturnCode
    template<>
    struct hash<::v1::com::harman::UISpeechService::UISSTypes::eReturnCode> {
        inline size_t operator()(const ::v1::com::harman::UISpeechService::UISSTypes::eReturnCode& eReturnCode) const {
            return static_cast<int32_t>(eReturnCode);
        }
    };
    //Hash for ePlayState
    template<>
    struct hash<::v1::com::harman::UISpeechService::UISSTypes::ePlayState> {
        inline size_t operator()(const ::v1::com::harman::UISpeechService::UISSTypes::ePlayState& ePlayState) const {
            return static_cast<int32_t>(ePlayState);
        }
    };
    //Hash for eVRStateEnum
    template<>
    struct hash<::v1::com::harman::UISpeechService::UISSTypes::eVRStateEnum> {
        inline size_t operator()(const ::v1::com::harman::UISpeechService::UISSTypes::eVRStateEnum& eVRStateEnum) const {
            return static_cast<int32_t>(eVRStateEnum);
        }
    };
    //Hash for eVRDialogActive
    template<>
    struct hash<::v1::com::harman::UISpeechService::UISSTypes::eVRDialogActive> {
        inline size_t operator()(const ::v1::com::harman::UISpeechService::UISSTypes::eVRDialogActive& eVRDialogActive) const {
            return static_cast<int32_t>(eVRDialogActive);
        }
    };
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_UISPEECHSERVICE_UISS_Types_HPP_
