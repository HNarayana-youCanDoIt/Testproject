/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_TIMEMANAGER_Time_Manager_PROXY_BASE_HPP_
#define V1_COM_HARMAN_TIMEMANAGER_Time_Manager_PROXY_BASE_HPP_

#include <v1/com/harman/TimeManager/TimeManager.hpp>


#include <v0/com/harman/TimeManager/timeManagerServiceTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <cstdint>
#include <vector>

#include <CommonAPI/Attribute.hpp>
#include <CommonAPI/Proxy.hpp>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace TimeManager {

class TimeManagerProxyBase
    : virtual public CommonAPI::Proxy {
public:
    typedef CommonAPI::ObservableAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::timeZoneOffset> TzOffsetAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime> SystemTimeWithTzAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime> SystemTimeWithTz12HrAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime> SystemTimeWithTz24HrAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<uint64_t> SystemTimeUTCAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime> UtcTime12HrAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime> UtcTime24HrAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format> TimeFormatAttribute;

    typedef std::function<void(const CommonAPI::CallStatus&, const bool&)> DisableTimeSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const std::vector<std::string>&)> GetEnabledSourcesAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const int16_t&)> SelectTimeSourceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States&)> ChangeTM_StateAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode&)> ChangeTM_OperationalModeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const bool&)> UpdateSourceTime_wellFormedAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const bool&)> UpdateSourceTime_UTCAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format&)> GetTimeFormatAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const bool&)> SetTimeFormatAsyncCallback;

    /**
     * description: tzOffset   	    		This attribute is used to set and get the time zone offset.  
     *    		symbol = should be one of the value from the enum 		hours = should be the
     *   hrs valued 		min = should be the minutes value
     * author: Bhushan J
     */
    virtual TzOffsetAttribute& getTzOffsetAttribute() = 0;
    /**
     * description: systemTimeWithTz  	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 12Hr or 24Hr format.
     * author: Bhushan J
     */
    virtual SystemTimeWithTzAttribute& getSystemTimeWithTzAttribute() = 0;
    /**
     * description: systemTimeWithTz12Hr 	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 12hr format.
     * author: Tarun Thomas
     */
    virtual SystemTimeWithTz12HrAttribute& getSystemTimeWithTz12HrAttribute() = 0;
    /**
     * description: systemTimeWithTz24Hr	    		This attribute will be updated every 1 min with the
     *   system time. This time will be applied with the TZ offset if its available.   
     *   		Time here is in 24hr format.
     * author: Tarun Thomas
     */
    virtual SystemTimeWithTz24HrAttribute& getSystemTimeWithTz24HrAttribute() = 0;
    /**
     * description: systemTimeUTC   	    		This attribute will be updated every 1 min with the
     *   system time update. This will reflect the UTC system time.
     * author: Bhushan J
     */
    virtual SystemTimeUTCAttribute& getSystemTimeUTCAttribute() = 0;
    /**
     * description: This attribute will be updated every 1 min with                             the
     *   system time in UTC. Time here is in 12hr format.
     * author: Tarun Thomas
     */
    virtual UtcTime12HrAttribute& getUtcTime12HrAttribute() = 0;
    /**
     * description: This attribute will be updated every 1 min with                             the
     *   system time in UTC. Time here is in 24hr format.
     * author: Tarun Thomas
     */
    virtual UtcTime24HrAttribute& getUtcTime24HrAttribute() = 0;
    /**
     * description: This attribute is used to know the current active                            
     *   time format. timeFormat will be updated on every                            
     *   change of time format using setTimeFormat() API.
     * author: Tarun Thomas
     */
    virtual TimeFormatAttribute& getTimeFormatAttribute() = 0;


    /**
     * description: disableTimeSource 		This method is used to let TM know about which source to
     *   disable.    		input: sourceName - valid configured source name. The
     *   configuration of TM should be refered for this.    		output: status - true if
     *   the source is disabled. false if source disabling falied.
     * author: Bhushan J
     */
    virtual void disableTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> disableTimeSourceAsync(const std::string &_sourceName, DisableTimeSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: getEnabledSources  		Get the list of enabled sources    		output:
     *   sourceNameList - Gets the list of the sourceNames which are currently enabled
     * author: Bhushan J
     */
    virtual void getEnabledSources(CommonAPI::CallStatus &_internalCallStatus, std::vector<std::string> &_sourceNameList, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> getEnabledSourcesAsync(GetEnabledSourcesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: selectTimeSource	 		Enable the time source    		input: sourceName - valid
     *   configured source name. The configuration of TM should be refered for this.   
     *   		output: holdOffTime - -1 or value greater than 0. The value will be -1 in
     *   case the selected source is not operational.    		Else the configured holdOff
     *   time will be returned.     		This method is used to enable a specific
     *   timeSource. Here TimeManager will not disable the other sources.   
     *   		Accordingly the source will be enabled by TM for fetching and sending the
     *   data to Chrony.
     * author: Bhushan J
     */
    virtual void selectTimeSource(const std::string &_sourceName, CommonAPI::CallStatus &_internalCallStatus, int16_t &_holdOffTime, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> selectTimeSourceAsync(const std::string &_sourceName, SelectTimeSourceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: changeTM_State  		Change state of TM    		input: newState - valid state from
     *   the described TM_States.    		output: currState - Current state of the TM. If
     *   the provided newState is invalid with respect to the    		state transition the
     *   privious state will be kept unchanged and the same will be retured.
     * author: Bhushan J
     */
    virtual void changeTM_State(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_currState, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> changeTM_StateAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_States &_newState, ChangeTM_StateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: changeTM_OperationalMode 	 		Change the operation mode    		input: newMode -
     *   valid mode from the described TM_operationalMode.    		output: currMode -
     *   Current operational mode TM is working after the change is made.
     * author: Bhushan J
     */
    virtual void changeTM_OperationalMode(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_currMode, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> changeTM_OperationalModeAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_operationalMode &_newMode, ChangeTM_OperationalModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: updateSourceTime_wellFormed	 		Update time from a time source    		input:
     *   newTime - new time value which is defined time data structure.     		sourceId:
     *   Source ID as configured in TM configuration     		output: status - true:
     *   update is succesful, false:failure in the update. For failure there can   
     *   		be two issues. Either sourceId is not valid or provided newTime is not valid.
     * author: Bhushan J
     */
    virtual void updateSourceTime_wellFormed(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> updateSourceTime_wellFormedAsync(const ::v0::com::harman::TimeManager::timeManagerServiceTypes::systemTime &_newTime, const std::string &_sourceId, UpdateSourceTime_wellFormedAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: updateSourceTime_UTC 	 		Update time from a time source    		input: newUTCTime
     *   - new time value in UTC format, sourceId: Source ID as configured in TM
     *   configuration     		output: status - true: update is succesful, false:failure
     *   in the update. For failure there can    		be two issues. Either sourceId is
     *   not valid or provided newTime is not valid.
     * author: Bhushan J
     */
    virtual void updateSourceTime_UTC(const uint64_t &_newUTCTime, const std::string &_sourceId, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> updateSourceTime_UTCAsync(const uint64_t &_newUTCTime, const std::string &_sourceId, UpdateSourceTime_UTCAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Get current format of the time
     * author: Tarun Thomas
     */
    virtual void getTimeFormat(CommonAPI::CallStatus &_internalCallStatus, ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> getTimeFormatAsync(GetTimeFormatAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Set current format for the time
     * author: Tarun Thomas
     */
    virtual void setTimeFormat(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, CommonAPI::CallStatus &_internalCallStatus, bool &_status, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> setTimeFormatAsync(const std::string &_sourceName, const ::v0::com::harman::TimeManager::timeManagerServiceTypes::TM_Format &_format, SetTimeFormatAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
};

} // namespace TimeManager
} // namespace harman
} // namespace com
} // namespace v1


// Compatibility
namespace v1_3 = v1;

#endif // V1_COM_HARMAN_TIMEMANAGER_Time_Manager_PROXY_BASE_HPP_
