/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_PRES_User_Preference_Handler_PROXY_HPP_
#define V1_COM_HARMAN_PRES_User_Preference_Handler_PROXY_HPP_

#include <v1/com/harman/pres/UserPreferenceHandlerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace pres {

template <typename ... _AttributeExtensions>
class UserPreferenceHandlerProxy
    : virtual public UserPreferenceHandler, 
      virtual public UserPreferenceHandlerProxyBase,
      virtual public _AttributeExtensions... {
public:
    UserPreferenceHandlerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~UserPreferenceHandlerProxy();

    typedef UserPreferenceHandler InterfaceType;


    /**
     * description: This attribute holds user preference details for all device types 	
     *   		parameters are explained in devprestypes FIDL.
     */
    /**
     * Returns the wrapper class that provides access to the attribute userPrefByDevType.
     */
    virtual UserPrefByDevTypeAttribute& getUserPrefByDevTypeAttribute() {
        return delegate_->getUserPrefByDevTypeAttribute();
    }
    /**
     * description: This attribute holds user preference details ONLY for currently connected
     *   devices. 	 		parameters are explained in devprestypes FIDL.
     */
    /**
     * Returns the wrapper class that provides access to the attribute userPrefByDevName.
     */
    virtual UserPrefByDevNameAttribute& getUserPrefByDevNameAttribute() {
        return delegate_->getUserPrefByDevNameAttribute();
    }


    /**
     * description: This method to be called to set user preference by device type. 		As
     *   confirmation to this request, attribute "userPrefByDevType" gets updated. 	
     *   		parameters are explained in devprestypes FIDL.
     * Calls setUserPrefByDevType with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setUserPrefByDevType(const ::v1::com::harman::pres::devprestypes::eDeviceType &_devType, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setUserPrefByDevType with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setUserPrefByDevTypeAsync(const ::v1::com::harman::pres::devprestypes::eDeviceType &_devType, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, SetUserPrefByDevTypeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method to be called to set user preference by device name. 		As
     *   confirmation to this request, attribute "userPrefByDevName" gets updated. 	
     *   		parameters are explained in devprestypes FIDL.
     * Calls setUserPrefByDevName with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setUserPrefByDevName(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setUserPrefByDevName with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setUserPrefByDevNameAsync(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, SetUserPrefByDevNameAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method to be called to clear all user preferences  		including both by
     *   device name & by device type. 	 		parameters are explained in devprestypes
     *   FIDL.
     * Calls clearAllPreferences with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void clearAllPreferences(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eRequestStatus &_reqStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls clearAllPreferences with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> clearAllPreferencesAsync(ClearAllPreferencesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<UserPreferenceHandlerProxyBase> delegate_;
};

typedef UserPreferenceHandlerProxy<> UserPreferenceHandlerProxyDefault;

namespace UserPreferenceHandlerExtensions {
    /**
     * description: This attribute holds user preference details for all device types 	
     *   		parameters are explained in devprestypes FIDL.
     */
    template <template <typename > class _ExtensionType>
    class UserPrefByDevTypeAttributeExtension {
     public:
        typedef _ExtensionType<UserPreferenceHandlerProxyBase::UserPrefByDevTypeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<UserPreferenceHandlerProxyBase::UserPrefByDevTypeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UserPrefByDevTypeAttributeExtension() {}
    #endif
    
        UserPrefByDevTypeAttributeExtension(UserPreferenceHandlerProxyBase& proxy): attributeExtension_(proxy.getUserPrefByDevTypeAttribute()) {
        }
    
        inline extension_type& getUserPrefByDevTypeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute holds user preference details ONLY for currently connected
     *   devices. 	 		parameters are explained in devprestypes FIDL.
     */
    template <template <typename > class _ExtensionType>
    class UserPrefByDevNameAttributeExtension {
     public:
        typedef _ExtensionType<UserPreferenceHandlerProxyBase::UserPrefByDevNameAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<UserPreferenceHandlerProxyBase::UserPrefByDevNameAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        UserPrefByDevNameAttributeExtension() {}
    #endif
    
        UserPrefByDevNameAttributeExtension(UserPreferenceHandlerProxyBase& proxy): attributeExtension_(proxy.getUserPrefByDevNameAttribute()) {
        }
    
        inline extension_type& getUserPrefByDevNameAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace UserPreferenceHandlerExtensions

//
// UserPreferenceHandlerProxy Implementation
//
template <typename ... _AttributeExtensions>
UserPreferenceHandlerProxy<_AttributeExtensions...>::UserPreferenceHandlerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<UserPreferenceHandlerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<UserPreferenceHandlerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
UserPreferenceHandlerProxy<_AttributeExtensions...>::~UserPreferenceHandlerProxy() {
}

/**
 * description: This method to be called to set user preference by device type. 		As
 *   confirmation to this request, attribute "userPrefByDevType" gets updated. 	
 *   		parameters are explained in devprestypes FIDL.
 */
template <typename ... _AttributeExtensions>
void UserPreferenceHandlerProxy<_AttributeExtensions...>::setUserPrefByDevType(const ::v1::com::harman::pres::devprestypes::eDeviceType &_devType, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
    if (!_devType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_mode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setUserPrefByDevType(_devType, _mode, _internalCallStatus, _ackStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> UserPreferenceHandlerProxy<_AttributeExtensions...>::setUserPrefByDevTypeAsync(const ::v1::com::harman::pres::devprestypes::eDeviceType &_devType, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, SetUserPrefByDevTypeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_devType.validate()) {
        ::v1::com::harman::pres::devprestypes::eAcknowledgement ackStatus = ::v1::com::harman::pres::devprestypes::eAcknowledgement::VALID_INPUT;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ackStatus);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_mode.validate()) {
        ::v1::com::harman::pres::devprestypes::eAcknowledgement ackStatus = ::v1::com::harman::pres::devprestypes::eAcknowledgement::VALID_INPUT;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ackStatus);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setUserPrefByDevTypeAsync(_devType, _mode, _callback, _info);
}
/**
 * description: This method to be called to set user preference by device name. 		As
 *   confirmation to this request, attribute "userPrefByDevName" gets updated. 	
 *   		parameters are explained in devprestypes FIDL.
 */
template <typename ... _AttributeExtensions>
void UserPreferenceHandlerProxy<_AttributeExtensions...>::setUserPrefByDevName(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eAcknowledgement &_ackStatus, const CommonAPI::CallInfo *_info) {
    if (!_mode.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setUserPrefByDevName(_Id, _mode, _internalCallStatus, _ackStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> UserPreferenceHandlerProxy<_AttributeExtensions...>::setUserPrefByDevNameAsync(const uint8_t &_Id, const ::v1::com::harman::pres::devprestypes::eModeName &_mode, SetUserPrefByDevNameAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_mode.validate()) {
        ::v1::com::harman::pres::devprestypes::eAcknowledgement ackStatus = ::v1::com::harman::pres::devprestypes::eAcknowledgement::VALID_INPUT;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, ackStatus);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setUserPrefByDevNameAsync(_Id, _mode, _callback, _info);
}
/**
 * description: This method to be called to clear all user preferences  		including both by
 *   device name & by device type. 	 		parameters are explained in devprestypes
 *   FIDL.
 */
template <typename ... _AttributeExtensions>
void UserPreferenceHandlerProxy<_AttributeExtensions...>::clearAllPreferences(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::pres::devprestypes::eRequestStatus &_reqStatus, const CommonAPI::CallInfo *_info) {
    delegate_->clearAllPreferences(_internalCallStatus, _reqStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> UserPreferenceHandlerProxy<_AttributeExtensions...>::clearAllPreferencesAsync(ClearAllPreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->clearAllPreferencesAsync(_callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &UserPreferenceHandlerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool UserPreferenceHandlerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool UserPreferenceHandlerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& UserPreferenceHandlerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& UserPreferenceHandlerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace pres
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::pres::UserPreferenceHandlerProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::pres::UserPreferenceHandlerProxy<
            ::v1::com::harman::pres::UserPreferenceHandlerExtensions::UserPrefByDevTypeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::UserPreferenceHandlerExtensions::UserPrefByDevNameAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_PRES_User_Preference_Handler_PROXY_HPP_
