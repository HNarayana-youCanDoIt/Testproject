/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_PRES_aaprescontrols_PROXY_HPP_
#define V1_COM_HARMAN_PRES_aaprescontrols_PROXY_HPP_

#include <v1/com/harman/pres/aaprescontrolsProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace pres {

template <typename ... _AttributeExtensions>
class aaprescontrolsProxy
    : virtual public aaprescontrols, 
      virtual public aaprescontrolsProxyBase,
      virtual public _AttributeExtensions... {
public:
    aaprescontrolsProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~aaprescontrolsProxy();

    typedef aaprescontrols InterfaceType;


    /**
     * description: sessions attribute is responsible to maintain status of projection sessions
     */
    /**
     * Returns the wrapper class that provides access to the attribute session.
     */
    virtual SessionAttribute& getSessionAttribute() {
        return delegate_->getSessionAttribute();
    }
    /**
     * description: This attribute reflects the known wireless androidauto devices list update
     */
    /**
     * Returns the wrapper class that provides access to the attribute deviceInfo.
     */
    virtual DeviceInfoAttribute& getDeviceInfoAttribute() {
        return delegate_->getDeviceInfoAttribute();
    }
    /**
     * description: Data Structure to hold the device batteryLevel info, data members are as follows
     * param: batteryLevelPercentage The current battery percentage of the mobile device.
     * param: timeRemainingS An estimate of how long the battery will last, in seconds.
     * param: isBatteryCritical Whether the mobile device's battery is at a critical level,
     *   as determined by the mobile device.
     */
    /**
     * Returns the wrapper class that provides access to the attribute batteryInfo.
     */
    virtual BatteryInfoAttribute& getBatteryInfoAttribute() {
        return delegate_->getBatteryInfoAttribute();
    }
    /**
     * description: Attributes to hold the metadata,playback status,Navigation info.
     */
    /**
     * Returns the wrapper class that provides access to the attribute playbackStatus.
     */
    virtual PlaybackStatusAttribute& getPlaybackStatusAttribute() {
        return delegate_->getPlaybackStatusAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute songNode.
     */
    virtual SongNodeAttribute& getSongNodeAttribute() {
        return delegate_->getSongNodeAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute metadata.
     */
    virtual MetadataAttribute& getMetadataAttribute() {
        return delegate_->getMetadataAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute turnInfo.
     */
    virtual TurnInfoAttribute& getTurnInfoAttribute() {
        return delegate_->getTurnInfoAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute turnDistInfo.
     */
    virtual TurnDistInfoAttribute& getTurnDistInfoAttribute() {
        return delegate_->getTurnDistInfoAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute navFocusType.
     */
    virtual NavFocusTypeAttribute& getNavFocusTypeAttribute() {
        return delegate_->getNavFocusTypeAttribute();
    }
    /**
     * Returns the wrapper class that provides access to the attribute navStatusType.
     */
    virtual NavStatusTypeAttribute& getNavStatusTypeAttribute() {
        return delegate_->getNavStatusTypeAttribute();
    }


    /**
     * description: Message indicates that the AndroidAuto session is requested
     * Calls startProjection with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startProjection(const std::string &_appUrl, const ::v2::com::harman::pres::aaprestypes::sTransportInfo &_tranportInfo, const ::v2::com::harman::pres::aaprestypes::enTransportType &_type, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * Calls stopProjection with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void stopProjection(const std::string &_appUrl, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: This request method allows client to request for the Projection screen        
     *   	show : true - show 		false - hide , If false client can disregard layer and
     *   appUrl 	appUrl : URL identifier of the desired application to launch 	  Blank
     *   String: native screen will be launched 	  other apps: tbd
     * Calls requestProjection with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void requestProjection(const std::string &_appUrl, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: Method to request for the screen hide 	switchReason : reason for switching out
     *   of the android auto screen , refer enum values
     * Calls requestNative with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void requestNative(const ::v2::com::harman::pres::aaprestypes::eScreenSwitchReason &_switchReason, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: WIFI_AA Method to request connection to a wireless android device
     * Calls connect with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void connect(const std::string &_btAddr, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: WIFI_AA  Method allows client to request for disconnection of current active
     *   device
     * Calls disconnect with Fire&Forget semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void disconnect(CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: WIFI_AA  Method allows client to request for the deletion of the device from
     *   the wireless androidauto device list
     * Calls deleteDevice with Fire&Forget semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteDevice(const std::string &_btAddr, CommonAPI::CallStatus &_internalCallStatus);
    /**
     * description: WIFI_AA  This request method allows client to request for cancelling the
     *   ongoing connect process.
     * Calls cancelConnect with Fire&Forget semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelConnect(CommonAPI::CallStatus &_internalCallStatus);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<aaprescontrolsProxyBase> delegate_;
};

typedef aaprescontrolsProxy<> aaprescontrolsProxyDefault;

namespace aaprescontrolsExtensions {
    /**
     * description: sessions attribute is responsible to maintain status of projection sessions
     */
    template <template <typename > class _ExtensionType>
    class SessionAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::SessionAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::SessionAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SessionAttributeExtension() {}
    #endif
    
        SessionAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getSessionAttribute()) {
        }
    
        inline extension_type& getSessionAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: This attribute reflects the known wireless androidauto devices list update
     */
    template <template <typename > class _ExtensionType>
    class DeviceInfoAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::DeviceInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::DeviceInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DeviceInfoAttributeExtension() {}
    #endif
    
        DeviceInfoAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getDeviceInfoAttribute()) {
        }
    
        inline extension_type& getDeviceInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Data Structure to hold the device batteryLevel info, data members are as follows
     * param: batteryLevelPercentage The current battery percentage of the mobile device.
     * param: timeRemainingS An estimate of how long the battery will last, in seconds.
     * param: isBatteryCritical Whether the mobile device's battery is at a critical level,
     *   as determined by the mobile device.
     */
    template <template <typename > class _ExtensionType>
    class BatteryInfoAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::BatteryInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::BatteryInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        BatteryInfoAttributeExtension() {}
    #endif
    
        BatteryInfoAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getBatteryInfoAttribute()) {
        }
    
        inline extension_type& getBatteryInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Attributes to hold the metadata,playback status,Navigation info.
     */
    template <template <typename > class _ExtensionType>
    class PlaybackStatusAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::PlaybackStatusAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::PlaybackStatusAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        PlaybackStatusAttributeExtension() {}
    #endif
    
        PlaybackStatusAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getPlaybackStatusAttribute()) {
        }
    
        inline extension_type& getPlaybackStatusAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class SongNodeAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::SongNodeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::SongNodeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SongNodeAttributeExtension() {}
    #endif
    
        SongNodeAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getSongNodeAttribute()) {
        }
    
        inline extension_type& getSongNodeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class MetadataAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::MetadataAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::MetadataAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        MetadataAttributeExtension() {}
    #endif
    
        MetadataAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getMetadataAttribute()) {
        }
    
        inline extension_type& getMetadataAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class TurnInfoAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::TurnInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::TurnInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        TurnInfoAttributeExtension() {}
    #endif
    
        TurnInfoAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getTurnInfoAttribute()) {
        }
    
        inline extension_type& getTurnInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class TurnDistInfoAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::TurnDistInfoAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::TurnDistInfoAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        TurnDistInfoAttributeExtension() {}
    #endif
    
        TurnDistInfoAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getTurnDistInfoAttribute()) {
        }
    
        inline extension_type& getTurnDistInfoAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class NavFocusTypeAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::NavFocusTypeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::NavFocusTypeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        NavFocusTypeAttributeExtension() {}
    #endif
    
        NavFocusTypeAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getNavFocusTypeAttribute()) {
        }
    
        inline extension_type& getNavFocusTypeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    template <template <typename > class _ExtensionType>
    class NavStatusTypeAttributeExtension {
     public:
        typedef _ExtensionType<aaprescontrolsProxyBase::NavStatusTypeAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<aaprescontrolsProxyBase::NavStatusTypeAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        NavStatusTypeAttributeExtension() {}
    #endif
    
        NavStatusTypeAttributeExtension(aaprescontrolsProxyBase& proxy): attributeExtension_(proxy.getNavStatusTypeAttribute()) {
        }
    
        inline extension_type& getNavStatusTypeAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace aaprescontrolsExtensions

//
// aaprescontrolsProxy Implementation
//
template <typename ... _AttributeExtensions>
aaprescontrolsProxy<_AttributeExtensions...>::aaprescontrolsProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<aaprescontrolsProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<aaprescontrolsProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
aaprescontrolsProxy<_AttributeExtensions...>::~aaprescontrolsProxy() {
}

/**
 * description: Message indicates that the AndroidAuto session is requested
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::startProjection(const std::string &_appUrl, const ::v2::com::harman::pres::aaprestypes::sTransportInfo &_tranportInfo, const ::v2::com::harman::pres::aaprestypes::enTransportType &_type, CommonAPI::CallStatus &_internalCallStatus) {
    if (!_type.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->startProjection(_appUrl, _tranportInfo, _type, _internalCallStatus);
}
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::stopProjection(const std::string &_appUrl, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->stopProjection(_appUrl, _internalCallStatus);
}
/**
 * description: This request method allows client to request for the Projection screen        
 *   	show : true - show 		false - hide , If false client can disregard layer and
 *   appUrl 	appUrl : URL identifier of the desired application to launch 	  Blank
 *   String: native screen will be launched 	  other apps: tbd
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::requestProjection(const std::string &_appUrl, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->requestProjection(_appUrl, _internalCallStatus);
}
/**
 * description: Method to request for the screen hide 	switchReason : reason for switching out
 *   of the android auto screen , refer enum values
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::requestNative(const ::v2::com::harman::pres::aaprestypes::eScreenSwitchReason &_switchReason, CommonAPI::CallStatus &_internalCallStatus) {
    if (!_switchReason.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->requestNative(_switchReason, _internalCallStatus);
}
/**
 * description: WIFI_AA Method to request connection to a wireless android device
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::connect(const std::string &_btAddr, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->connect(_btAddr, _internalCallStatus);
}
/**
 * description: WIFI_AA  Method allows client to request for disconnection of current active
 *   device
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::disconnect(CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->disconnect(_internalCallStatus);
}
/**
 * description: WIFI_AA  Method allows client to request for the deletion of the device from
 *   the wireless androidauto device list
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::deleteDevice(const std::string &_btAddr, CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->deleteDevice(_btAddr, _internalCallStatus);
}
/**
 * description: WIFI_AA  This request method allows client to request for cancelling the
 *   ongoing connect process.
 */
template <typename ... _AttributeExtensions>
void aaprescontrolsProxy<_AttributeExtensions...>::cancelConnect(CommonAPI::CallStatus &_internalCallStatus) {
    delegate_->cancelConnect(_internalCallStatus);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &aaprescontrolsProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool aaprescontrolsProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool aaprescontrolsProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& aaprescontrolsProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& aaprescontrolsProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace pres
} // namespace harman
} // namespace com
} // namespace v1

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v1::com::harman::pres::aaprescontrolsProxy,
    _AttributeExtension> {
    typedef typename ::v1::com::harman::pres::aaprescontrolsProxy<
            ::v1::com::harman::pres::aaprescontrolsExtensions::SessionAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::DeviceInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::BatteryInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::PlaybackStatusAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::SongNodeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::MetadataAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::TurnInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::TurnDistInfoAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::NavFocusTypeAttributeExtension<_AttributeExtension>, 
            ::v1::com::harman::pres::aaprescontrolsExtensions::NavStatusTypeAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v1_1 = v1;

#endif // V1_COM_HARMAN_PRES_aaprescontrols_PROXY_HPP_
