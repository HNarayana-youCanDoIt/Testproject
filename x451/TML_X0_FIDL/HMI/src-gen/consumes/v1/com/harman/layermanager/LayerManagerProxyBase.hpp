/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_PROXY_BASE_HPP_
#define V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_PROXY_BASE_HPP_

#include <v1/com/harman/layermanager/LayerManager.hpp>


#include <v1/com/harman/layermanager/LayerManagerTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <cstdint>
#include <vector>

#include <CommonAPI/Event.hpp>
#include <CommonAPI/SelectiveEvent.hpp>
#include <CommonAPI/Proxy.hpp>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace layermanager {

class LayerManagerProxyBase
    : virtual public CommonAPI::Proxy {
public:
    typedef CommonAPI::SelectiveEvent<::v1::com::harman::layermanager::LayerManagerTypes::tEventType, uint32_t> EventUpdateSelectiveEvent;
    typedef CommonAPI::SelectiveEvent<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> PropertyUpdateSelectiveEvent;

    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> SetPropertyAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&)> UnsubscribeAllAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const std::string&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> ScreenshotAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> ShowLayerSafeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> HideLayerSafeAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> ShowSurfaceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> HideSurfaceAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::layermanager::LayerManagerTypes::tResult&)> RunCommandAsyncCallback;


    /**
     * description: Shall be triggered for registered clients based on the events of the registered
     *   layers/surfaces. 	 		returns:	  tEvent
     */
    virtual EventUpdateSelectiveEvent& getEventUpdateSelectiveEvent() = 0;
    /**
     * description: Shall be triggered for registered clients based on the change in properties of
     *   the registered layers/surfaces. 	 		returns:	  tEvent
     */
    virtual PropertyUpdateSelectiveEvent& getPropertyUpdateSelectiveEvent() = 0;

    /**
     * description: This is different from the Common API broadcast/attribute subscription. Client
     *   can subscribe to events like creation,destruction etc for a particular
     *   surface/layer/display. 					  The API will always be successfull, and will
     *   cause conditional broadcasts to be triggered to the registering clients.   
     *   					  Before calling this function ensure that you have subscribed to the
     *   propertyUpdate broadcast.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: name: 		  The string name for the desired object. The string name can be
     *   checked in LayerManager.conf
     * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
     * param: eventFilter:	  Bitmask combination of events interested in (Look at tEventType)
     *                      returns:	  nothing
     */
    /**
     * @invariant Fire And Forget
     */
    virtual void subscribeEvents(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, const uint64_t &_eventFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus) = 0;
    virtual void setProperty(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> setPropertyAsync(const std::vector<::v1::com::harman::layermanager::LayerManagerTypes::tProperty> &_property, SetPropertyAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This is different from the Common API broadcast/attribute subscription. Client
     *   can subscribe to events like creation,visibility change, resize etc for a
     *   particular surface/layer. 					  The API will always be successfull, and will
     *   cause conditional broadcasts to be triggered to the registering clients.   
     *   					  Before calling this function ensure that you have subscribed to the
     *   propertyUpdate broadcast.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: id: 			  The string identifier for the desired object. The string identifier
     *   can be checked in LayerManager.conf
     * param: isSubscribe:    Whether this is a subscription or an unsubscription request.
     * param: propFilter:	  Bitmask combination of properties interested in (Look at
     *   tPropertyType)                    returns:	  nothing
     */
    /**
     * @invariant Fire And Forget
     */
    virtual void subscribeProps(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_id, const uint64_t &_propFilter, const bool &_isSubscribe, CommonAPI::CallStatus &_internalCallStatus) = 0;
    /**
     * description: Removes all event / property subscription for a client.             returns:	 
     *   Nothing..
     */
    virtual void unsubscribeAll(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> unsubscribeAllAsync(UnsubscribeAllAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Initiate a capture operation for the display,layer or surface. Will only return
     *   once the operation finished successfully/failed. 		Add periodic.
     * param: type: 		  The passed identifier is a surface/layer/display
     * param: name: 		  The string name for the desired object. The string identifier can be
     *   checked in LayerManager.conf                    returns:	  path: 		  If
     *   successfull, returns the path to the PNG file.           returns:    
     *   result:		  Status of operation.
     */
    virtual void screenshot(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, CommonAPI::CallStatus &_internalCallStatus, std::string &_path, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> screenshotAsync(const ::v1::com::harman::layermanager::LayerManagerTypes::tObjectType &_type, const std::string &_name, ScreenshotAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This API will set the visibility of a layer to true, if no higher priority
     *   layers are not currently visible.   				      There are no implicit z order /
     *   alpha changes.  				      Any layers at the same priority level will be hidden
     *   implicitly.  					  For more specific use cases, use the command API.
     * param: :layerID	Layer ID matching in layermanager.conf	       	 		returns:	  result :
     *   Check enumeration for more details.
     */
    virtual void showLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> showLayerSafeAsync(const std::string &_layerID, ShowLayerSafeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This API will set the visibility of a layer to false. If any previous layer can
     *   be shown on screen, it is made visible.
     * param: :layerID	Layer ID matching in layermanager.conf 			returns:	  result : Check
     *   enumeration for more details.
     */
    virtual void hideLayerSafe(const std::string &_layerID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> hideLayerSafeAsync(const std::string &_layerID, HideLayerSafeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This API will set the visibility of a surface to true. The surface can be
     *   hidden again if desired through the hideSurface interface.
     * param: surfaceID: surface ID matching in layermanager.conf
     * param: bestGuessAttach: If set to true, this parameter causes the layer manager to
     *   find an appropriate "visible" layer to attach this surface to. (before being
     *   shown).  							The bestGuessSurface must be defined in the "supportedlayers"
     *   attribute in the layermanager config. The attach will always be done to the
     *   first visible layer found in the 							 "supportedlayers" list. If no visible
     *   Layer is found to which the surface can be attached, then the API will fail. 
     *   	       	 		returns:	  result : Check enumeration for more details.
     */
    virtual void showSurface(const std::string &_surfaceID, const bool &_bestGuessAttach, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> showSurfaceAsync(const std::string &_surfaceID, const bool &_bestGuessAttach, ShowSurfaceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: This API will set the visibility of a surface to false.
     * param: surfaceID: surface ID matching in layermanager.conf 			returns:	  result :
     *   Check enumeration for more details.
     */
    virtual void hideSurface(const std::string &_surfaceID, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> hideSurfaceAsync(const std::string &_surfaceID, HideSurfaceAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Can be used to run any arbitrary command sequence. Command Sequences can be
     *   defined in LayerManagerCommands.ini file
     * param: :command	Cammand Sequence defined in LayerManagerCommands.ini 	       	
     *   		returns:	  result : Check enumeration for more details.
     */
    virtual void runCommand(const std::string &_command, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::layermanager::LayerManagerTypes::tResult &_result, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> runCommandAsync(const std::string &_command, RunCommandAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
};

} // namespace layermanager
} // namespace harman
} // namespace com
} // namespace v1


// Compatibility
namespace v1_0 = v1;

#endif // V1_COM_HARMAN_LAYERMANAGER_Layer_Manager_PROXY_BASE_HPP_
