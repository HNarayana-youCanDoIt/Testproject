/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
/**
 * description: Provides interface to control the Software Update flow and to access the states
 *   and progress during the update process
 * author: Bharath Upadhya
 */
#ifndef V1_COM_HARMAN_SWDL_Software_Update_PROXY_BASE_HPP_
#define V1_COM_HARMAN_SWDL_Software_Update_PROXY_BASE_HPP_

#include <v1/com/harman/swdl/SoftwareUpdate.hpp>


#include <v1/com/harman/swdl/SoftwareUpdateTypes.hpp>

#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/ByteBuffer.hpp>
#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <cstdint>
#include <string>
#include <vector>

#include <CommonAPI/Attribute.hpp>
#include <CommonAPI/Event.hpp>
#include <CommonAPI/Proxy.hpp>
#include <functional>
#include <future>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v1 {
namespace com {
namespace harman {
namespace swdl {

class SoftwareUpdateProxyBase
    : virtual public CommonAPI::Proxy {
public:
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageList> SoftwareAvailableForDownloadAttrAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageList> SoftwareAvailableForInstallAttrAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tInstallProgress> InstallProgressAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tDownloadProgress> DownloadProgressAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tActivationResult> ActivationResultAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tTime> LastUpdateSearchTimeAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tTime> LastUpdateInstallTimeAttribute;
    typedef CommonAPI::ObservableReadonlyAttribute<::v1::com::harman::swdl::SoftwareUpdateTypes::tStatus> StatusAttribute;
    typedef CommonAPI::ObservableAttribute<bool> AutoDownloadAttribute;
    typedef CommonAPI::ObservableAttribute<bool> AutoDownloadSizeLimitAttribute;
    typedef CommonAPI::ObservableAttribute<bool> AutoInstallAttribute;
    typedef CommonAPI::ObservableAttribute<bool> AutoSearchAttribute;
    typedef CommonAPI::ObservableAttribute<uint32_t> AutoSearchIntervalAttribute;
    typedef CommonAPI::ObservableAttribute<bool> AllowVersionDowngradeAttribute;
    typedef CommonAPI::Event<
        ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails
    > SoftwareAvailableForDownloadEvent;
    typedef CommonAPI::Event<
        ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails
    > SoftwareAvailableForInstallEvent;
    typedef CommonAPI::Event<
        ::v1::com::harman::swdl::SoftwareUpdateTypes::tStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource
    > SoftwareUpdateStatusEvent;

    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult&)> CheckForUpdatesAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult&)> CheckPackageForUpdateAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> RequestDownloadAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> RequestInstallAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> RequestDownloadPackageAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> RequestInstallPackageAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> CancelDownloadAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> CancelInstallAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> SetAutomaticDownloadAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&, const bool&, const uint32_t&)> GetAutomaticDownloadStatusAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> ActivateSoftwareAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> DisableSoftwareUpdateAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&, const bool&)> GetDisableSoftwareUpdateAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> AbortSearchAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> SetAutomaticInstallationAsyncCallback;
    typedef std::function<void(const CommonAPI::CallStatus&, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult&)> RequestFactoryResetAsyncCallback;

    /**
     * description: list of software packages which are ready for download from the external
     *   location (e.g. MSD or OTA)
     */
    virtual SoftwareAvailableForDownloadAttrAttribute& getSoftwareAvailableForDownloadAttrAttribute() = 0;
    /**
     * description: list of packages ready of installation                        incase system is
     *   configured to allowed to cache the package before instllation , then list is
     *   llimited to                         single package is downloaded from external
     *   location to target cache area.                        incase system is
     *   configured to allow instllation of package directly from original external
     *   location (e.g. MSD) ,                         this it list of packages in
     *   external location compatible with the system.
     */
    virtual SoftwareAvailableForInstallAttrAttribute& getSoftwareAvailableForInstallAttrAttribute() = 0;
    /**
     * description: Software package installation progress information (overall progress and part
     *   wise progress along with its name).
     */
    virtual InstallProgressAttribute& getInstallProgressAttribute() = 0;
    /**
     * description: Software package download progress information.
     */
    virtual DownloadProgressAttribute& getDownloadProgressAttribute() = 0;
    /**
     * description: activation status of previously installed software.
     */
    virtual ActivationResultAttribute& getActivationResultAttribute() = 0;
    /**
     * description: Last update package searched time.
     */
    virtual LastUpdateSearchTimeAttribute& getLastUpdateSearchTimeAttribute() = 0;
    /**
     * description: Last package install time.
     */
    virtual LastUpdateInstallTimeAttribute& getLastUpdateInstallTimeAttribute() = 0;
    /**
     * description: Current state of the software update state machine
     */
    virtual StatusAttribute& getStatusAttribute() = 0;
    /**
     * description: setting option to enable automatice download of the SW package from external
     *   source (OTA or MSD etc).
     */
    virtual AutoDownloadAttribute& getAutoDownloadAttribute() = 0;
    /**
     * description: setting option which sets maximum package size limit for auto download (if
     *   enabled)                       value zero represents setting is not enabled
     *   and allows download packages with any limit.
     */
    virtual AutoDownloadSizeLimitAttribute& getAutoDownloadSizeLimitAttribute() = 0;
    /**
     * description: setting option to enable automatic installation of the SW package which is
     *   ready for installaltion                         (either already downloaded to
     *   target cache memory or ready from installation directly from external location
     *   e.g. MSD)
     */
    virtual AutoInstallAttribute& getAutoInstallAttribute() = 0;
    /**
     * description: setting option which enables automatic search for SW update package from
     *   external location once communnication is established with                     
     *      system (e.g. MSD device connected to the system)
     */
    virtual AutoSearchAttribute& getAutoSearchAttribute() = 0;
    /**
     * description: polling time interval (in seconds) to be used for searching the updates
     *   availability on the remote server
     */
    virtual AutoSearchIntervalAttribute& getAutoSearchIntervalAttribute() = 0;
    /**
     * description: if enabled , setting allows force installation of software package with any
     *   version.                        if not , service restricts installation of SW
     *   package with older or same version compare to version active in the system
     */
    virtual AllowVersionDowngradeAttribute& getAllowVersionDowngradeAttribute() = 0;

    /**
     * description: Broadcast signals when new SoftwareUpdate image available for download (E.g.,
     *   From OTA server or Mass Storage device).                        Depreciated
     *   for future use; Instead use "attribute tPackageList
     *   softwareAvailableForDownload"
     */
    virtual SoftwareAvailableForDownloadEvent& getSoftwareAvailableForDownloadEvent() = 0;
    /**
     * description: Broadcast signal to notify if a update package is ready for installation       
     *                    (e.g. Already downloaded from OTA server or mass storage
     *   device or ready for installation direclty from Mass Storage Device)           
     *               Depreciated for future use; Instead use "attribute tPackageList
     *   softwareAvailableForInstall"
     */
    virtual SoftwareAvailableForInstallEvent& getSoftwareAvailableForInstallEvent() = 0;
    /**
     * description: Broadcast signals for indication of current state of the update flow along with
     *   notification of process flow
     */
    virtual SoftwareUpdateStatusEvent& getSoftwareUpdateStatusEvent() = 0;

    /**
     * description: Trigger to search for any software updates available for download and install
     *   from the available sources.                        e.g check for updates from
     *   OTA server or update packages within connected mass storage devices etc
     */
    virtual void CheckForUpdates(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> CheckForUpdatesAsync(CheckForUpdatesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Trigger to search for specific update package via its name and matching hash in
     *   a source (e.g. Mass Storage Device)                          Parameters:
     */
    virtual void CheckPackageForUpdate(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, ::v1::com::harman::swdl::SoftwareUpdateTypes::tUpdateSearchResult &_checkResult, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> CheckPackageForUpdateAsync(const std::string &_packageName, const ::v1::com::harman::swdl::SoftwareUpdateTypes::tHashValue &_hash, const ::v1::com::harman::swdl::SoftwareUpdateTypes::eUpdateSource &_source, CheckPackageForUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Trigger to perform a possible download action on newly available software.
     */
    virtual void RequestDownload(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> RequestDownloadAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestDownload &_requestDownload, RequestDownloadAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Trigger to perform a possible installation action on newly available software  
     *                         (Note : Package might be already downloaded from
     *   external sources to the internal device cache or ready for installation from
     *   external source)
     */
    virtual void RequestInstall(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> RequestInstallAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::eRequestInstall &_installPackage, RequestInstallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Method interface to request installation of the specific package located at a
     *   path specified via argument
     */
    virtual void RequestDownloadPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> RequestDownloadPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_downloadPackage, RequestDownloadPackageAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Method interface to request installation of the specific package located at a
     *   path specified via argument
     */
    virtual void RequestInstallPackage(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> RequestInstallPackageAsync(const ::v1::com::harman::swdl::SoftwareUpdateTypes::tPackageDetails &_installPackage, RequestInstallPackageAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To cancel the download which is already started.         Deprecated for future
     *   use , Instead use RequestDownload(CANCEL_DOWNLOAD)
     */
    virtual void CancelDownload(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> CancelDownloadAsync(CancelDownloadAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To cancel the installation which is already in progress.         Deprecated for
     *   future use , Instead use RequestInstall(CANCEL_INSTALLATION)
     */
    virtual void CancelInstall(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> CancelInstallAsync(CancelInstallAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To enable or disable automatic download of the package from external source
     *   (e.g. OTA server or Mass storage device) in to the device cached.
     */
    virtual void SetAutomaticDownload(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> SetAutomaticDownloadAsync(const bool &_enableAutoDownload, const uint32_t &_autoDownloadLimit, SetAutomaticDownloadAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To get the current enable/disable status for automatic download.
     */
    virtual void GetAutomaticDownloadStatus(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_enableAutoDownload, uint32_t &_autoDownloadLimit, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> GetAutomaticDownloadStatusAsync(GetAutomaticDownloadStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: Request for activation of recently installed software ;                        
     *   Installation complete is notified via states INSTALLATION_COMPLETE or
     *   READY_FOR_ACTIVATION                        Post this API trigger , system
     *   will be restarted to new lifecycle to effect the new software
     */
    virtual void ActivateSoftware(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> ActivateSoftwareAsync(ActivateSoftwareAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To completely disable the software update feature. When the update is disbaled,
     *                           software update process will neither check for any
     *   updates on its own not process any APIs to serach for updates.
     */
    virtual void DisableSoftwareUpdate(const bool &_disable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> DisableSoftwareUpdateAsync(const bool &_disable, DisableSoftwareUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: retrieve if software update service is currently enabled or disabled
     */
    virtual void GetDisableSoftwareUpdate(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, bool &_disable, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> GetDisableSoftwareUpdateAsync(GetDisableSoftwareUpdateAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To abort any on going search for updates.
     */
    virtual void AbortSearch(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> AbortSearchAsync(AbortSearchAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: To enable / disable automatic installation of the available/downloaded package
     *   without the confirmation from the client .
     */
    virtual void SetAutomaticInstallation(const bool &_enable, CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> SetAutomaticInstallationAsync(const bool &_enable, SetAutomaticInstallationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
    /**
     * description: method trigger to reset the Software update states back to idle along with
     *   resetting the settings back to default.                        Clears any
     *   internal cache/status informations. If service is already in installation
     *   stage , request will not be processed
     */
    virtual void RequestFactoryReset(CommonAPI::CallStatus &_internalCallStatus, ::v1::com::harman::swdl::SoftwareUpdateTypes::eMethodResult &_error, const CommonAPI::CallInfo *_info = nullptr) = 0;
    virtual std::future<CommonAPI::CallStatus> RequestFactoryResetAsync(RequestFactoryResetAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr) = 0;
};

} // namespace swdl
} // namespace harman
} // namespace com
} // namespace v1


// Compatibility
namespace v1_2 = v1;

#endif // V1_COM_HARMAN_SWDL_Software_Update_PROXY_BASE_HPP_
