/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V2_COM_HARMAN_PRES_cpprestypes_HPP_
#define V2_COM_HARMAN_PRES_cpprestypes_HPP_



#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <cstdint>
#include <string>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v2 {
namespace com {
namespace harman {
namespace pres {

struct cpprestypes {
    
    struct eScreenSwitchReason : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            USER_SWITCH = 0,
            AUTO_TRANSIENT_SWITCH = 1,
            USER_TRANSIENT_SWITCH = 2
        };
        
        eScreenSwitchReason() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::USER_SWITCH)) {}
        eScreenSwitchReason(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::USER_SWITCH):
                case static_cast<int32_t>(Literal::AUTO_TRANSIENT_SWITCH):
                case static_cast<int32_t>(Literal::USER_TRANSIENT_SWITCH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const eScreenSwitchReason &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const eScreenSwitchReason &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const eScreenSwitchReason &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const eScreenSwitchReason &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const eScreenSwitchReason &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const eScreenSwitchReason &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct enRouteGuidanceState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NOTACTIVE = 0,
            ACTIVE_GUIDING = 1,
            ARRIVED = 2,
            LOADING = 3,
            LOCATING = 4,
            REROUTING = 5,
            PROCEEDTOROUTE = 6
        };
        
        enRouteGuidanceState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NOTACTIVE)) {}
        enRouteGuidanceState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NOTACTIVE):
                case static_cast<int32_t>(Literal::ACTIVE_GUIDING):
                case static_cast<int32_t>(Literal::ARRIVED):
                case static_cast<int32_t>(Literal::LOADING):
                case static_cast<int32_t>(Literal::LOCATING):
                case static_cast<int32_t>(Literal::REROUTING):
                case static_cast<int32_t>(Literal::PROCEEDTOROUTE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const enRouteGuidanceState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const enRouteGuidanceState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const enRouteGuidanceState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const enRouteGuidanceState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const enRouteGuidanceState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const enRouteGuidanceState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct enManeuverState : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            MANEUVER_CONTINUE = 0,
            MANEUVER_INITIAL = 1,
            MANEUVER_PREPARE = 2,
            MANEUVER_EXECUTE = 3
        };
        
        enManeuverState() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::MANEUVER_CONTINUE)) {}
        enManeuverState(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::MANEUVER_CONTINUE):
                case static_cast<int32_t>(Literal::MANEUVER_INITIAL):
                case static_cast<int32_t>(Literal::MANEUVER_PREPARE):
                case static_cast<int32_t>(Literal::MANEUVER_EXECUTE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const enManeuverState &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const enManeuverState &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const enManeuverState &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const enManeuverState &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const enManeuverState &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const enManeuverState &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct enDistanceRemainingUnits : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            KM = 0,
            MILES = 1,
            M = 2,
            YARDS = 3,
            FT = 4
        };
        
        enDistanceRemainingUnits() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::KM)) {}
        enDistanceRemainingUnits(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::KM):
                case static_cast<int32_t>(Literal::MILES):
                case static_cast<int32_t>(Literal::M):
                case static_cast<int32_t>(Literal::YARDS):
                case static_cast<int32_t>(Literal::FT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const enDistanceRemainingUnits &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const enDistanceRemainingUnits &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const enDistanceRemainingUnits &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const enDistanceRemainingUnits &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const enDistanceRemainingUnits &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const enDistanceRemainingUnits &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct enManeuverType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NO_TURN = 0,
            LEFT_TURN = 1,
            RIGHT_TURN = 2,
            STRAIGHT_AHEAD = 3,
            U_TURN = 4,
            FOLLOW_ROAD = 5,
            ENTER_ROUNDABOUT = 6,
            EXIT_ROUNDABOUT = 7,
            OFF_RAMP = 8,
            ON_RAMP = 9,
            ARRIVE_END_OF_NAVIGATION = 10,
            START_ROUTE = 11,
            ARRIVE_AT_DESTINATION = 12,
            KEEP_LEFT = 13,
            KEEP_RIGHT = 14,
            ENTER_FERRY = 15,
            EXIT_FERRY = 16,
            CHANGE_FERRY = 17,
            START_ROUTE_WITH_U_TURN = 18,
            U_TURN_AT_ROUNDABOUT = 19,
            LEFT_TURN_AT_END = 20,
            RIGHT_TURN_AT_END = 21,
            HIGHWAY_OFF_RAMP_LEFT = 22,
            HIGHWAY_OFF_RAMP_RIGHT = 23,
            ARRIVE_AT_DESTINATION_LEFT = 24,
            ARRIVE_AT_DESTINATION_RIGHT = 25,
            U_TURN_WHEN_POSSIBLE = 26,
            ARRIVE_END_OF_DIRECTIONS = 27,
            ROUNDABOUT_EXIT_1 = 28,
            ROUNDABOUT_EXIT_2 = 29,
            ROUNDABOUT_EXIT_3 = 30,
            ROUNDABOUT_EXIT_4 = 31,
            ROUNDABOUT_EXIT_5 = 32,
            ROUNDABOUT_EXIT_6 = 33,
            ROUNDABOUT_EXIT_7 = 34,
            ROUNDABOUT_EXIT_8 = 35,
            ROUNDABOUT_EXIT_9 = 36,
            ROUNDABOUT_EXIT_10 = 37,
            ROUNDABOUT_EXIT_11 = 38,
            ROUNDABOUT_EXIT_12 = 39,
            ROUNDABOUT_EXIT_13 = 40,
            ROUNDABOUT_EXIT_14 = 41,
            ROUNDABOUT_EXIT_15 = 42,
            ROUNDABOUT_EXIT_16 = 43,
            ROUNDABOUT_EXIT_17 = 44,
            ROUNDABOUT_EXIT_18 = 45,
            ROUNDABOUT_EXIT_19 = 46,
            SHARP_LEFT_TURN = 47,
            SHARP_RIGHT_TURN = 48,
            SLIGHT_LEFT_TURN = 49,
            SLIGHT_RIGHT_TURN = 50,
            CHANGE_HIGHWAY = 51,
            CHANGE_HIGHWAY_LEFT = 52,
            CHANGE_HIGHWAY_RIGHT = 53
        };
        
        enManeuverType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NO_TURN)) {}
        enManeuverType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NO_TURN):
                case static_cast<int32_t>(Literal::LEFT_TURN):
                case static_cast<int32_t>(Literal::RIGHT_TURN):
                case static_cast<int32_t>(Literal::STRAIGHT_AHEAD):
                case static_cast<int32_t>(Literal::U_TURN):
                case static_cast<int32_t>(Literal::FOLLOW_ROAD):
                case static_cast<int32_t>(Literal::ENTER_ROUNDABOUT):
                case static_cast<int32_t>(Literal::EXIT_ROUNDABOUT):
                case static_cast<int32_t>(Literal::OFF_RAMP):
                case static_cast<int32_t>(Literal::ON_RAMP):
                case static_cast<int32_t>(Literal::ARRIVE_END_OF_NAVIGATION):
                case static_cast<int32_t>(Literal::START_ROUTE):
                case static_cast<int32_t>(Literal::ARRIVE_AT_DESTINATION):
                case static_cast<int32_t>(Literal::KEEP_LEFT):
                case static_cast<int32_t>(Literal::KEEP_RIGHT):
                case static_cast<int32_t>(Literal::ENTER_FERRY):
                case static_cast<int32_t>(Literal::EXIT_FERRY):
                case static_cast<int32_t>(Literal::CHANGE_FERRY):
                case static_cast<int32_t>(Literal::START_ROUTE_WITH_U_TURN):
                case static_cast<int32_t>(Literal::U_TURN_AT_ROUNDABOUT):
                case static_cast<int32_t>(Literal::LEFT_TURN_AT_END):
                case static_cast<int32_t>(Literal::RIGHT_TURN_AT_END):
                case static_cast<int32_t>(Literal::HIGHWAY_OFF_RAMP_LEFT):
                case static_cast<int32_t>(Literal::HIGHWAY_OFF_RAMP_RIGHT):
                case static_cast<int32_t>(Literal::ARRIVE_AT_DESTINATION_LEFT):
                case static_cast<int32_t>(Literal::ARRIVE_AT_DESTINATION_RIGHT):
                case static_cast<int32_t>(Literal::U_TURN_WHEN_POSSIBLE):
                case static_cast<int32_t>(Literal::ARRIVE_END_OF_DIRECTIONS):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_1):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_2):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_3):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_4):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_5):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_6):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_7):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_8):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_9):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_10):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_11):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_12):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_13):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_14):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_15):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_16):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_17):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_18):
                case static_cast<int32_t>(Literal::ROUNDABOUT_EXIT_19):
                case static_cast<int32_t>(Literal::SHARP_LEFT_TURN):
                case static_cast<int32_t>(Literal::SHARP_RIGHT_TURN):
                case static_cast<int32_t>(Literal::SLIGHT_LEFT_TURN):
                case static_cast<int32_t>(Literal::SLIGHT_RIGHT_TURN):
                case static_cast<int32_t>(Literal::CHANGE_HIGHWAY):
                case static_cast<int32_t>(Literal::CHANGE_HIGHWAY_LEFT):
                case static_cast<int32_t>(Literal::CHANGE_HIGHWAY_RIGHT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const enManeuverType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const enManeuverType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const enManeuverType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const enManeuverType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const enManeuverType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const enManeuverType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct enDrivingSide : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            RIGHT_ANTI_CLOCKWISE = 0,
            LEFT_CLOCKWISE = 1
        };
        
        enDrivingSide() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::RIGHT_ANTI_CLOCKWISE)) {}
        enDrivingSide(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::RIGHT_ANTI_CLOCKWISE):
                case static_cast<int32_t>(Literal::LEFT_CLOCKWISE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const enDrivingSide &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const enDrivingSide &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const enDrivingSide &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const enDrivingSide &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const enDrivingSide &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const enDrivingSide &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct enJunctionType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NORMAL = 0,
            ROUNDABOUT = 1
        };
        
        enJunctionType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NORMAL)) {}
        enJunctionType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NORMAL):
                case static_cast<int32_t>(Literal::ROUNDABOUT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const enJunctionType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const enJunctionType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const enJunctionType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const enJunctionType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const enJunctionType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const enJunctionType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct sNaviRouteGuidanceUpdate : CommonAPI::Struct<std::vector<std::string>, enRouteGuidanceState, enManeuverState, std::string, std::string, uint64_t, uint64_t, uint32_t, std::string, enDistanceRemainingUnits, uint32_t, std::string, enDistanceRemainingUnits, std::vector<uint16_t>, uint16_t, uint8_t> {
    	
    	sNaviRouteGuidanceUpdate() {
    	}
    	sNaviRouteGuidanceUpdate(const std::vector<std::string> &_displayName, const enRouteGuidanceState &_guidanceState, const enManeuverState &_naviManeuverState, const std::string &_currentRoadName, const std::string &_destinationName, const uint64_t &_estimatedTimeOfArrival, const uint64_t &_timeRemainingToDestination, const uint32_t &_distanceRemaining, const std::string &_distanceRemainingDisplayString, const enDistanceRemainingUnits &_distanceRemainingDisplayUnits, const uint32_t &_distanceRemainingToNextManeuver, const std::string &_distanceRemainingToNextManeuverDisplayString, const enDistanceRemainingUnits &_distanceRemainingToNextManeuverDisplayUnits, const std::vector<uint16_t> &_routeGuidanceManeuverCurrentList, const uint16_t &_routeGuidanceManeuverCount, const uint8_t &_routeGuidanceVisibleInApp)
    	{
    		std::get<0>(values_) = _displayName;
    		std::get<1>(values_) = _guidanceState;
    		std::get<2>(values_) = _naviManeuverState;
    		std::get<3>(values_) = _currentRoadName;
    		std::get<4>(values_) = _destinationName;
    		std::get<5>(values_) = _estimatedTimeOfArrival;
    		std::get<6>(values_) = _timeRemainingToDestination;
    		std::get<7>(values_) = _distanceRemaining;
    		std::get<8>(values_) = _distanceRemainingDisplayString;
    		std::get<9>(values_) = _distanceRemainingDisplayUnits;
    		std::get<10>(values_) = _distanceRemainingToNextManeuver;
    		std::get<11>(values_) = _distanceRemainingToNextManeuverDisplayString;
    		std::get<12>(values_) = _distanceRemainingToNextManeuverDisplayUnits;
    		std::get<13>(values_) = _routeGuidanceManeuverCurrentList;
    		std::get<14>(values_) = _routeGuidanceManeuverCount;
    		std::get<15>(values_) = _routeGuidanceVisibleInApp;
    	}
    	inline const std::vector<std::string> &getDisplayName() const { return std::get<0>(values_); }
    	inline void setDisplayName(const std::vector<std::string> &_value) { std::get<0>(values_) = _value; }
    	inline const enRouteGuidanceState &getGuidanceState() const { return std::get<1>(values_); }
    	inline void setGuidanceState(const enRouteGuidanceState &_value) { std::get<1>(values_) = _value; }
    	inline const enManeuverState &getNaviManeuverState() const { return std::get<2>(values_); }
    	inline void setNaviManeuverState(const enManeuverState &_value) { std::get<2>(values_) = _value; }
    	inline const std::string &getCurrentRoadName() const { return std::get<3>(values_); }
    	inline void setCurrentRoadName(const std::string &_value) { std::get<3>(values_) = _value; }
    	inline const std::string &getDestinationName() const { return std::get<4>(values_); }
    	inline void setDestinationName(const std::string &_value) { std::get<4>(values_) = _value; }
    	inline const uint64_t &getEstimatedTimeOfArrival() const { return std::get<5>(values_); }
    	inline void setEstimatedTimeOfArrival(const uint64_t &_value) { std::get<5>(values_) = _value; }
    	inline const uint64_t &getTimeRemainingToDestination() const { return std::get<6>(values_); }
    	inline void setTimeRemainingToDestination(const uint64_t &_value) { std::get<6>(values_) = _value; }
    	inline const uint32_t &getDistanceRemaining() const { return std::get<7>(values_); }
    	inline void setDistanceRemaining(const uint32_t &_value) { std::get<7>(values_) = _value; }
    	inline const std::string &getDistanceRemainingDisplayString() const { return std::get<8>(values_); }
    	inline void setDistanceRemainingDisplayString(const std::string &_value) { std::get<8>(values_) = _value; }
    	inline const enDistanceRemainingUnits &getDistanceRemainingDisplayUnits() const { return std::get<9>(values_); }
    	inline void setDistanceRemainingDisplayUnits(const enDistanceRemainingUnits &_value) { std::get<9>(values_) = _value; }
    	inline const uint32_t &getDistanceRemainingToNextManeuver() const { return std::get<10>(values_); }
    	inline void setDistanceRemainingToNextManeuver(const uint32_t &_value) { std::get<10>(values_) = _value; }
    	inline const std::string &getDistanceRemainingToNextManeuverDisplayString() const { return std::get<11>(values_); }
    	inline void setDistanceRemainingToNextManeuverDisplayString(const std::string &_value) { std::get<11>(values_) = _value; }
    	inline const enDistanceRemainingUnits &getDistanceRemainingToNextManeuverDisplayUnits() const { return std::get<12>(values_); }
    	inline void setDistanceRemainingToNextManeuverDisplayUnits(const enDistanceRemainingUnits &_value) { std::get<12>(values_) = _value; }
    	inline const std::vector<uint16_t> &getRouteGuidanceManeuverCurrentList() const { return std::get<13>(values_); }
    	inline void setRouteGuidanceManeuverCurrentList(const std::vector<uint16_t> &_value) { std::get<13>(values_) = _value; }
    	inline const uint16_t &getRouteGuidanceManeuverCount() const { return std::get<14>(values_); }
    	inline void setRouteGuidanceManeuverCount(const uint16_t &_value) { std::get<14>(values_) = _value; }
    	inline const uint8_t &getRouteGuidanceVisibleInApp() const { return std::get<15>(values_); }
    	inline void setRouteGuidanceVisibleInApp(const uint8_t &_value) { std::get<15>(values_) = _value; }
    	inline bool operator==(const sNaviRouteGuidanceUpdate& _other) const {
                return (getDisplayName() == _other.getDisplayName() && getGuidanceState() == _other.getGuidanceState() && getNaviManeuverState() == _other.getNaviManeuverState() && getCurrentRoadName() == _other.getCurrentRoadName() && getDestinationName() == _other.getDestinationName() && getEstimatedTimeOfArrival() == _other.getEstimatedTimeOfArrival() && getTimeRemainingToDestination() == _other.getTimeRemainingToDestination() && getDistanceRemaining() == _other.getDistanceRemaining() && getDistanceRemainingDisplayString() == _other.getDistanceRemainingDisplayString() && getDistanceRemainingDisplayUnits() == _other.getDistanceRemainingDisplayUnits() && getDistanceRemainingToNextManeuver() == _other.getDistanceRemainingToNextManeuver() && getDistanceRemainingToNextManeuverDisplayString() == _other.getDistanceRemainingToNextManeuverDisplayString() && getDistanceRemainingToNextManeuverDisplayUnits() == _other.getDistanceRemainingToNextManeuverDisplayUnits() && getRouteGuidanceManeuverCurrentList() == _other.getRouteGuidanceManeuverCurrentList() && getRouteGuidanceManeuverCount() == _other.getRouteGuidanceManeuverCount() && getRouteGuidanceVisibleInApp() == _other.getRouteGuidanceVisibleInApp());
        }
    	inline bool operator!=(const sNaviRouteGuidanceUpdate &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct sNaviRouteGuidanceManeuverInfoUpdate : CommonAPI::Struct<std::vector<std::string>, uint16_t, std::string, enManeuverType, std::string, uint32_t, std::string, enDistanceRemainingUnits, enDrivingSide, enJunctionType, std::vector<int16_t>, int16_t> {
    	
    	sNaviRouteGuidanceManeuverInfoUpdate() {
    	}
    	sNaviRouteGuidanceManeuverInfoUpdate(const std::vector<std::string> &_displayName, const uint16_t &_index, const std::string &_maneuverDesc, const enManeuverType &_type, const std::string &_afterManeuverRoadName, const uint32_t &_distanceBetweenManeuver, const std::string &_distanceBetweenManeuverDisplayString, const enDistanceRemainingUnits &_distanceBetweenManeuverDisplayUnits, const enDrivingSide &_drivingSideValue, const enJunctionType &_junctionTypeValue, const std::vector<int16_t> &_junctionElementAngle, const int16_t &_junctionElementExitAngle)
    	{
    		std::get<0>(values_) = _displayName;
    		std::get<1>(values_) = _index;
    		std::get<2>(values_) = _maneuverDesc;
    		std::get<3>(values_) = _type;
    		std::get<4>(values_) = _afterManeuverRoadName;
    		std::get<5>(values_) = _distanceBetweenManeuver;
    		std::get<6>(values_) = _distanceBetweenManeuverDisplayString;
    		std::get<7>(values_) = _distanceBetweenManeuverDisplayUnits;
    		std::get<8>(values_) = _drivingSideValue;
    		std::get<9>(values_) = _junctionTypeValue;
    		std::get<10>(values_) = _junctionElementAngle;
    		std::get<11>(values_) = _junctionElementExitAngle;
    	}
    	inline const std::vector<std::string> &getDisplayName() const { return std::get<0>(values_); }
    	inline void setDisplayName(const std::vector<std::string> &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getIndex() const { return std::get<1>(values_); }
    	inline void setIndex(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline const std::string &getManeuverDesc() const { return std::get<2>(values_); }
    	inline void setManeuverDesc(const std::string &_value) { std::get<2>(values_) = _value; }
    	inline const enManeuverType &getType() const { return std::get<3>(values_); }
    	inline void setType(const enManeuverType &_value) { std::get<3>(values_) = _value; }
    	inline const std::string &getAfterManeuverRoadName() const { return std::get<4>(values_); }
    	inline void setAfterManeuverRoadName(const std::string &_value) { std::get<4>(values_) = _value; }
    	inline const uint32_t &getDistanceBetweenManeuver() const { return std::get<5>(values_); }
    	inline void setDistanceBetweenManeuver(const uint32_t &_value) { std::get<5>(values_) = _value; }
    	inline const std::string &getDistanceBetweenManeuverDisplayString() const { return std::get<6>(values_); }
    	inline void setDistanceBetweenManeuverDisplayString(const std::string &_value) { std::get<6>(values_) = _value; }
    	inline const enDistanceRemainingUnits &getDistanceBetweenManeuverDisplayUnits() const { return std::get<7>(values_); }
    	inline void setDistanceBetweenManeuverDisplayUnits(const enDistanceRemainingUnits &_value) { std::get<7>(values_) = _value; }
    	inline const enDrivingSide &getDrivingSideValue() const { return std::get<8>(values_); }
    	inline void setDrivingSideValue(const enDrivingSide &_value) { std::get<8>(values_) = _value; }
    	inline const enJunctionType &getJunctionTypeValue() const { return std::get<9>(values_); }
    	inline void setJunctionTypeValue(const enJunctionType &_value) { std::get<9>(values_) = _value; }
    	inline const std::vector<int16_t> &getJunctionElementAngle() const { return std::get<10>(values_); }
    	inline void setJunctionElementAngle(const std::vector<int16_t> &_value) { std::get<10>(values_) = _value; }
    	inline const int16_t &getJunctionElementExitAngle() const { return std::get<11>(values_); }
    	inline void setJunctionElementExitAngle(const int16_t &_value) { std::get<11>(values_) = _value; }
    	inline bool operator==(const sNaviRouteGuidanceManeuverInfoUpdate& _other) const {
                return (getDisplayName() == _other.getDisplayName() && getIndex() == _other.getIndex() && getManeuverDesc() == _other.getManeuverDesc() && getType() == _other.getType() && getAfterManeuverRoadName() == _other.getAfterManeuverRoadName() && getDistanceBetweenManeuver() == _other.getDistanceBetweenManeuver() && getDistanceBetweenManeuverDisplayString() == _other.getDistanceBetweenManeuverDisplayString() && getDistanceBetweenManeuverDisplayUnits() == _other.getDistanceBetweenManeuverDisplayUnits() && getDrivingSideValue() == _other.getDrivingSideValue() && getJunctionTypeValue() == _other.getJunctionTypeValue() && getJunctionElementAngle() == _other.getJunctionElementAngle() && getJunctionElementExitAngle() == _other.getJunctionElementExitAngle());
        }
    	inline bool operator!=(const sNaviRouteGuidanceManeuverInfoUpdate &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct WifiInfo : CommonAPI::Struct<std::string, std::string> {
    	
    	WifiInfo() {
    	}
    	WifiInfo(const std::string &_password, const std::string &_deviceAddr)
    	{
    		std::get<0>(values_) = _password;
    		std::get<1>(values_) = _deviceAddr;
    	}
    	inline const std::string &getPassword() const { return std::get<0>(values_); }
    	inline void setPassword(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getDeviceAddr() const { return std::get<1>(values_); }
    	inline void setDeviceAddr(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const WifiInfo& _other) const {
                return (getPassword() == _other.getPassword() && getDeviceAddr() == _other.getDeviceAddr());
        }
    	inline bool operator!=(const WifiInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };



static inline const char* getTypeCollectionName() {
    static const char* typeCollectionName = "com.harman.pres.cpprestypes";
    return typeCollectionName;
}

inline CommonAPI::Version getTypeCollectionVersion() {
    return CommonAPI::Version(2, 0);
}

}; // struct cpprestypes

} // namespace pres
} // namespace harman
} // namespace com
} // namespace v2

namespace CommonAPI {
}


namespace std {
    //Hash for eScreenSwitchReason
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::eScreenSwitchReason> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::eScreenSwitchReason& eScreenSwitchReason) const {
            return static_cast<int32_t>(eScreenSwitchReason);
        }
    };
    //Hash for enRouteGuidanceState
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::enRouteGuidanceState> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::enRouteGuidanceState& enRouteGuidanceState) const {
            return static_cast<int32_t>(enRouteGuidanceState);
        }
    };
    //Hash for enManeuverState
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::enManeuverState> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::enManeuverState& enManeuverState) const {
            return static_cast<int32_t>(enManeuverState);
        }
    };
    //Hash for enDistanceRemainingUnits
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::enDistanceRemainingUnits> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::enDistanceRemainingUnits& enDistanceRemainingUnits) const {
            return static_cast<int32_t>(enDistanceRemainingUnits);
        }
    };
    //Hash for enManeuverType
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::enManeuverType> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::enManeuverType& enManeuverType) const {
            return static_cast<int32_t>(enManeuverType);
        }
    };
    //Hash for enDrivingSide
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::enDrivingSide> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::enDrivingSide& enDrivingSide) const {
            return static_cast<int32_t>(enDrivingSide);
        }
    };
    //Hash for enJunctionType
    template<>
    struct hash<::v2::com::harman::pres::cpprestypes::enJunctionType> {
        inline size_t operator()(const ::v2::com::harman::pres::cpprestypes::enJunctionType& enJunctionType) const {
            return static_cast<int32_t>(enJunctionType);
        }
    };
}


// Compatibility
namespace v2_0 = v2;

#endif // V2_COM_HARMAN_PRES_cpprestypes_HPP_
