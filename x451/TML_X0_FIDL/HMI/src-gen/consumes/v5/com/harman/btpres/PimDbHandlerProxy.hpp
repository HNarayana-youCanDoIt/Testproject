/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.
* Used org.franca.core 0.9.1.201412191134.
*
* generated by DCIF CodeGen Version: R2_v2.1.0
* generated on: Wed Oct 30 12:44:55 IST 2019
*/
#ifndef V5_COM_HARMAN_BTPRES_Pim_Db_Handler_PROXY_HPP_
#define V5_COM_HARMAN_BTPRES_Pim_Db_Handler_PROXY_HPP_

#include <v5/com/harman/btpres/PimDbHandlerProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/AttributeExtension.hpp>
#include <CommonAPI/Factory.hpp>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v5 {
namespace com {
namespace harman {
namespace btpres {

template <typename ... _AttributeExtensions>
class PimDbHandlerProxy
    : virtual public PimDbHandler, 
      virtual public PimDbHandlerProxyBase,
      virtual public _AttributeExtensions... {
public:
    PimDbHandlerProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~PimDbHandlerProxy();

    typedef PimDbHandler InterfaceType;


    /**
     * description: formattedNameOrder is sorted name order, which can be set from HMI
     */
    /**
     * Returns the wrapper class that provides access to the attribute contactNameOrder.
     */
    virtual ContactNameOrderAttribute& getContactNameOrderAttribute() {
        return delegate_->getContactNameOrderAttribute();
    }
    /**
     * description: DeviceList will contain list of paired device and their syncstatus
     */
    /**
     * Returns the wrapper class that provides access to the attribute DeviceList.
     */
    virtual DeviceListAttribute& getDeviceListAttribute() {
        return delegate_->getDeviceListAttribute();
    }
    /**
     * description: Emergency Contact List this will contain the list of Emergency contacts for the
     *   connected phone.
     */
    /**
     * Returns the wrapper class that provides access to the attribute EmergencyContactList.
     */
    virtual EmergencyContactListAttribute& getEmergencyContactListAttribute() {
        return delegate_->getEmergencyContactListAttribute();
    }
    /**
     * description: Sms supported feature list, of connected phones
     */
    /**
     * Returns the wrapper class that provides access to the attribute smsSupportedFeature.
     */
    virtual SmsSupportedFeatureAttribute& getSmsSupportedFeatureAttribute() {
        return delegate_->getSmsSupportedFeatureAttribute();
    }

    /**
     * description: Will only be posted to the respective listeners if the session query parameters
     *   have changed.                       For example, for  Calllist and SMS can be
     *   changed dynamically based on new SMS or new Call Stack.  Will be published    
     *                     only if auto update was enabled when setting the query.
     *   There can be case when there is no change in total count
     * param: sessionID: The Session ID alloted.
     * param: sessionQueryID: Allocated session queruy ID
     * param: numResults: Total number of result
     * param: unreadCount: This will be sent updated for unread SMS count and unread missed
     *   call count
     * param: alphaList: This will be updated for alphaJumpTable list
     * param: charactersMask This will provide the possible next character list
     * param: phonebookList: This will be updated with possible phonebook entires for
     *   searched string
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQueryUpdate.
     */
    virtual SessionQueryUpdateSelectiveEvent& getSessionQueryUpdateSelectiveEvent() {
        return delegate_->getSessionQueryUpdateSelectiveEvent();
    }
    /**
     * description: Will only be posted to the respective listeners if the session query parameters
     *   have changed.                      For example, for  Calllist and SMS can be
     *   changed dynamically based on new SMS or new Call Stack.  Will be published    
     *                    only if auto update was enabled when setting the query. There
     *   can be case when there is no change in total count
     * param: sessionID: The Session ID alloted.
     * param: sessionQueryID: Allocated session queruy ID
     * param: numResults: Total number of result
     * param: unreadCount: This will be sent updated for unread SMS count and unread missed
     *   call count
     * param: alphaList: This will be updated for alphaJumpTable list
     * param: charactersMask This will provide the possible next character list
     * param: phonebookList: This will be updated with possible phonebook entires for
     *   searched string
     * param: count: This will provide folder and count. This applicable only for message    
     *              This is an extension of the sessionQueryUpdate to support message
     *   folder list and count.Once this is implemented, sessionQueryUpdate will be
     *   deprecated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQueryUpdateV2.
     */
    virtual SessionQueryUpdateV2SelectiveEvent& getSessionQueryUpdateV2SelectiveEvent() {
        return delegate_->getSessionQueryUpdateV2SelectiveEvent();
    }
    /**
     * description: Publishes the query status to all clients. The client can get the data once the
     *   query is "finished"
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQueryWindowUpdate.
     */
    virtual SessionQueryWindowUpdateSelectiveEvent& getSessionQueryWindowUpdateSelectiveEvent() {
        return delegate_->getSessionQueryWindowUpdateSelectiveEvent();
    }
    /**
     * description: Publishes the query status to all clients. The client can get the data once the
     *   query is "finished"        Adding folder name in windowupdate so client can
     *   map it with request.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQueryWindowUpdateV2.
     */
    virtual SessionQueryWindowUpdateV2SelectiveEvent& getSessionQueryWindowUpdateV2SelectiveEvent() {
        return delegate_->getSessionQueryWindowUpdateV2SelectiveEvent();
    }
    /**
     * description: Publishes the query status to all clients. The client can get the data once the
     *   query is "finished"
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionQuerySearchWindowUpdate.
     */
    virtual SessionQuerySearchWindowUpdateSelectiveEvent& getSessionQuerySearchWindowUpdateSelectiveEvent() {
        return delegate_->getSessionQuerySearchWindowUpdateSelectiveEvent();
    }
    /**
     * description: Publishes only when session is closed due to device disconnect or client request
     */
    /**
     * Returns the wrapper class that provides access to the broadcast sessionClosed.
     */
    virtual SessionClosedSelectiveEvent& getSessionClosedSelectiveEvent() {
        return delegate_->getSessionClosedSelectiveEvent();
    }
    /**
     * description: This signal will be sent when a new missed call notification is received (after
     *   the phone is connected to Head Unit).
     * param: inAddress: BD Address of Device
     * param: number: Missed call number of latest missed call
     * param: name: formatted Name of the contact
     * param: unreadCount: This is the current count of unread-missed call.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast unreadMissedCall.
     */
    virtual UnreadMissedCallEvent& getUnreadMissedCallEvent() {
        return delegate_->getUnreadMissedCallEvent();
    }
    /**
     * description: This signal will be sent when a newCallList is available, after a call.
     * param: inAddress: BD Address of Device
     * param: newCallStackEntry : New call stack entry
     */
    /**
     * Returns the wrapper class that provides access to the broadcast newCallList.
     */
    virtual NewCallListEvent& getNewCallListEvent() {
        return delegate_->getNewCallListEvent();
    }
    /**
     * description: This signal will be emitted , when send sms is invoked : sent & delivered
     *   (success or failure)
     * param: inAddress: BD Address of Device
     * param: smsId: smsID of the sent SMS
     * param: notification: Status of the sent SMS
     */
    /**
     * Returns the wrapper class that provides access to the broadcast SMSNotification.
     */
    virtual SMSNotificationEvent& getSMSNotificationEvent() {
        return delegate_->getSMSNotificationEvent();
    }
    /**
     * description: This signal will be emitted , when send sms is invoked : sent & delivered
     *   (success or failure)
     * param: btAddress: BD Address of Device
     * param: messageId: message Id
     * param: messageDetail: Details of the message.
     * param: notification: Status of the sent SMS                This is an extension of the
     *   smsnotification to support the preview of the message.Once this is
     *   implemented, SMSNotification will be deprecated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast MessageNotification.
     */
    virtual MessageNotificationEvent& getMessageNotificationEvent() {
        return delegate_->getMessageNotificationEvent();
    }
    /**
     * description: This signal will be sent when HU will have only limited contact compare to
     *   phone.                      For example if phone has 12000 contacts but HU
     *   supports only 6000 contact storage for each phone. In that case after
     *   synccomplete this signal will be emitted                      Based on that
     *   HMI can inform that sync is completed but only limited contacts are available
     *   on the HU
     * param: btAddress: BT Address of Device
     */
    /**
     * Returns the wrapper class that provides access to the broadcast PhoneBookTooLarge.
     */
    virtual PhoneBookTooLargeEvent& getPhoneBookTooLargeEvent() {
        return delegate_->getPhoneBookTooLargeEvent();
    }
    /**
     * description: This signal will be emitted , when send sms/email is invoked : sent & delivered
     *   (success or failure)
     * param: btAddress: BD Address of Device
     * param: databaseType: Different database of Pim.Currently only available for "sms" or
     *   "email"
     * param: messageId: message Id
     * param: messageDetail: Details of the message.
     * param: notification: Status of the sent SMS/Email         This is an extension of the
     *   smsnotification/MessageNotification to support the preview of the message.    
     *      Once this is implemented, SMSNotification/MessageNotification will be
     *   deprecated.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast MsgNotification.
     */
    virtual MsgNotificationEvent& getMsgNotificationEvent() {
        return delegate_->getMsgNotificationEvent();
    }

    /**
     * description: Opens a session for the client communication. This session will be used
     *   internally to uniquely identify a client, and to maintain client specific
     *   caches.                      The client need not create a new session for
     *   every request, this is rather used to identify different instances of clients.
     *                                   returns: sessionID: Session identifier
     *   allocated to the client.
     * Calls openSession with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void openSession(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, uint8_t &_sessionID, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_ErrorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls openSession with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> openSessionAsync(const std::string &_inAddress, OpenSessionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Close a client session and release all associated resources.
     * param: sessionID: The Session ID to close.
     * Calls closeSession with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void closeSession(const uint8_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_ErrorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls closeSession with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> closeSessionAsync(const uint8_t &_sessionID, CloseSessionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets a session query. This api handles all requests to fetch Phonebook results,
     *   database searches, etc.                       As an example. If the HMI wanted
     *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
     *   and the result type would be set to Required field list.
     * param: filterIDs: The previously communicated numeric identifiers of the different
     *   filter categories.
     * param: filters: The string filters which should be applied to the result.
     * param: resultType: The data which is expected from the query.
     * param: sessionID: Session ID obtained from OpenSession.
     * param: databaseType: Related database for this sessionquery.
     * param: RequiredField: List of required field , if default is set browsing item will be
     *   sent with default avlues based on config
     * param: resetPrevious: Whether to use old history or not.If true treat this as a new
     *   session query, do not use any old selection history.
     * param: AutoUpdateEnabled: This is applicable for result sets which might update
     *   dynamically,Call stack or Fav list
     * param: AlphaJumpTable: This is applicable only for phonebook, to get the alphajump
     *   table phonebook entries						         returns: numResults: The number of
     *   records matching the search criteria.        returns: SessionQueryID:The
     *   sessionQueryID allotted.This uniquely identifies a particular session
     *   query/filter for retrieving data in a session and it has to be passed         
     *                           for furthur setting the sessionQuery window and
     *   retrieving the contents of that window.
     * Calls setSessionQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSessionQuery(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint32_t &_numResults, uint8_t &_sessionQueryID, uint8_t &_unreadCount, ::v7::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSessionQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSessionQueryAsync(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, SetSessionQueryAsyncCallback_9708 _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Sets a session query. This api handles all requests to fetch Phonebook results,
     *   database searches, etc.                       As an example. If the HMI wanted
     *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
     *   and the result type would be set to Required field list.
     * param: filterIDs: The previously communicated numeric identifiers of the different
     *   filter categories.
     * param: filters: The string filters which should be applied to the result.
     * param: resultType: The data which is expected from the query.
     * param: sessionID: Session ID obtained from OpenSession.
     * param: databaseType: Related database for this sessionquery.
     * param: RequiredField: List of required field , if default is set browsing item will be
     *   sent with default avlues based on config
     * param: resetPrevious: Whether to use old history or not.If true treat this as a new
     *   session query, do not use any old selection history.
     * param: AutoUpdateEnabled: This is applicable for result sets which might update
     *   dynamically,Call stack or Fav list
     * param: AlphaJumpTable: This is applicable only for phonebook, to get the alphajump
     *   table for phonebook
     * param: NextValidChar: This is applicable while searching phonebook entries from smart
     *   search keyboard
     * param: numberOfItems: it provides number of entries from possible phonebook entries
     *   for searchString, it is considered only if NextValidChar is set to true
     *   							                returns: numResults: The number of records matching the
     *   search criteria.        returns: SessionQueryID:The sessionQueryID
     *   allotted.This uniquely identifies a particular session query/filter for
     *   retrieving data in a session and it has to be passed                          
     *          for furthur setting the sessionQuery window and retrieving the contents
     *   of that window.
     * Calls setSessionQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSessionQuery(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, const bool &_NextValidChar, const uint8_t &_numberOfItems, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint32_t &_numResults, uint8_t &_sessionQueryID, uint8_t &_unreadCount, ::v7::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, std::string &_possibleCharList, ::v7::com::harman::btpres::BTPresTypes::phonebook &_phonebookList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSessionQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSessionQueryAsync(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, const bool &_NextValidChar, const uint8_t &_numberOfItems, SetSessionQueryAsyncCallback_8354 _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Essentially re-initializes a session query and stops all background tasks.
     * param: sessionID: The Session ID alloted.
     * param: sessionID: The Session Query ID alloted for that particular session.This
     *   uniquely identifies a particular session query/filter for retrieving data in a
     *   session.
     * Calls cancelSessionQuery with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelSessionQuery(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls cancelSessionQuery with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> cancelSessionQueryAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, CancelSessionQueryAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Ask presentation control to fetch the desired set of entries for a particular
     *   session query. This call does not block for the result to complete, and will
     *   override                      the last request given to Pres Ctrl.
     * param: sessionID: The Session ID alloted.
     * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
     *   particular session query/filter for retrieving data in a session and it has to
     *   be passed                                 for furthur setting the sessionQuery
     *   window and retrieving the contents of that window.
     * param: startIndex: The index to start fetching.
     * param: numItems: The number of items to fetch.                       returns:
     *   windowID: A unique identifier for the client to track data responses to the
     *   queries. sessionQueryWindowUpdate version 1.0 will be emitted
     * Calls setSessionQueryWindow with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSessionQueryWindow(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSessionQueryWindow with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSessionQueryWindowAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, SetSessionQueryWindowAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: Ask presentation control to fetch the desired set of entries for a particular
     *   session query. This call does not block for the result to complete, and will
     *   override                      the last request given to Pres Ctrl.
     * param: sessionID: The Session ID alloted.
     * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
     *   particular session query/filter for retrieving data in a session and it has to
     *   be passed                                for furthur setting the sessionQuery
     *   window and retrieving the contents of that window.
     * param: startIndex: The index to start fetching.
     * param: numItems: The number of items to fetch.
     * param: folder: This parameter is applicable only for message browsing. 	          
     *   returns: windowID: A unique identifier for the client to track data responses
     *   to the queries. sessionQueryWindowUpdate version 1.0 will be emitted        
     *   This is an extension of the setSessionQueryWindow to support messages from
     *   folder. Once this is implemented, sessionQueryUpdate will be deprecated.
     * Calls setSessionQueryWindow with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSessionQueryWindow(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const std::string &_folder, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSessionQueryWindow with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSessionQueryWindowAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const std::string &_folder, SetSessionQueryWindowAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used for inserting/deleting/update entries to Favourite list ,
     *   Emergency List , SMS Template                       This method also can be
     *   used for Manual Update.Manual update currently only supported for Contact, CC
     *   , SMS                       This method is also can be used to reset SMS
     *   Template list . In that case all customized message will be removed system
     *   will contain only default sms template list
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim, Only Fav is allowed
     * param: requestID: Different type of user initiated DB operation. If requestID is
     *   MANUAL_SYNC/RESET_TO_DEFAULT/DELETE_ALL_FROM_DB, itemDetails field is not
     *   required.
     * param: itemDetails: This list contains contactID list, NewPhonebook entry,
     *   SMSTemplateID list, SMStemplate. This structure is mandatory for inserting,
     *   deleting         Use Case: To insert some of the contacts from Phonebook to
     *   FAV/EMERGENCY contact list itemDetails structures only ContactIdList field is
     *   required. request Id should be INSERT_INTO_DB_BY_CONTACT_ID        Use Case:
     *   To insert customize Phonebook to FAV/EMERGENCY contact list itemDetails
     *   structures only contactInfo field is required. requestID should be INSERT_NEW 
     *         Use Case: To insert customize sms template to sms template list ,
     *   itemDetails structures only SMSTemplate is required. requestID should be
     *   INSERT_NEW        Use Case: To update customize sms template to sms template
     *   list , itemDetails structures SMSTemplate and  SMSTemplateIdList is required.
     *   SMSTemplateIdList should contain only one index value                  
     *   requestId should be UPDATE_ENTRY        Use Case: To update emergency contact
     *   list entry , itemDetails structures phonebookEntry and  ContactIdList is
     *   required. ContactIdList should contain only one index value                  
     *   requestId should be UPDATE_ENTRY                              	 		            
     *   returns: This method returns errorcode
     * Calls dbOperation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void dbOperation(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::eDbOperationId &_requestID, const ::v7::com::harman::btpres::BTPresTypes::InsertItems &_itemDetails, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls dbOperation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> dbOperationAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::eDbOperationId &_requestID, const ::v7::com::harman::btpres::BTPresTypes::InsertItems &_itemDetails, DbOperationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API can be used to get Contact Name by contactID
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim.Currently only available for "pb" or
     *   "ab"
     * param: contactID: contactID for which contact details should be extracted
     * param: fieldList: Required filedlist using bit masking () 	 		             returns:	  
     *    phonebookEntry which will contain all the field
     * Calls getContactsByID with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getContactsByID(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const uint32_t &_contactID, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_FieldList, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::phonebookEntry &_detailedContact, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getContactsByID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getContactsByIDAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const uint32_t &_contactID, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_FieldList, GetContactsByIDAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API can be used to get complete contact details,  by Name or EMAIL or
     *   Number
     * param: SearchCriteria :  Criteria of Search        Use case : This should be used only
     *   if there is a need for search exact match by Name or Email                    
     *                  returns:       phonebookEntry which will contain all the field
     * Calls getDetailedContact with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getDetailedContact(const ::v7::com::harman::btpres::BTPresTypes::sSearchCriteria &_SearchCriteria, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::phonebook &_detailedContact, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getDetailedContact with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getDetailedContactAsync(const ::v7::com::harman::btpres::BTPresTypes::sSearchCriteria &_SearchCriteria, GetDetailedContactAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to get the full details of the SMS; this takes a unique id as
     *   input, which is received from the signal
     * param: inAddress: BD Address of Device
     * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
     *   can be sent, separated) 	 		             returns: This method returns SMS entry
     * Calls getSMSById with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSMSById(const std::string &_inAddress, const int64_t &_smsId, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::smsEntry &_sms, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSMSById with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSMSByIdAsync(const std::string &_inAddress, const int64_t &_smsId, GetSMSByIdAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to get the full details of the SMS/Email; this takes a unique
     *   id as input, which is received from the signal
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim.Currently only available for "sms" or
     *   "email"
     * param: msgId: Unique id for SMS/Email that is returned as part of the signal (multiple
     *   uid’s can be sent, separated)         returns: This method returns SMS/Email
     *   entry         This is an extension of the getSMSById to support the preview of
     *   the message.Once this is implemented, getSMSById will be deprecated.
     * Calls getMsgById with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getMsgById(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::msgEntry &_msg, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getMsgById with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getMsgByIdAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, GetMsgByIdAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API can be used to get the following details on either phonebook          
     *               1.	The next valid characters mask that match the input string.    
     *                    2.	The count of the names that matched the input string.     
     *                   3.	The index of the first match of the input string sorted by
     *   givenName column. (This index can be used in getItems API to query for the
     *   details but the same sort criteria need to be applied).
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim. Currently only available for Pb or ab
     * param: inputName: String to be searched
     * param: sortOrder: ascending or descending
     * param: condition: either or all based on notnullcolumnList         	 		            
     *   returns:      contactsCount:The count of the names that matched the input
     *   string.        returns:      index:The index of the first match of the input
     *   string sorted by formattedName column.        returns:      charactersMask:The
     *   next valid characters mask that match the input string.        returns:     
     *   firstMatch:The “formattedName” of the first matched contact
     * Calls getNextValidCharacters with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getNextValidCharacters(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const std::string &_inputName, const std::string &_sortOrder, const std::string &_condition, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint16_t &_contactsCount, uint16_t &_index, std::string &_charactersMask, std::string &_firstMatch, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getNextValidCharacters with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getNextValidCharactersAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const std::string &_inputName, const std::string &_sortOrder, const std::string &_condition, GetNextValidCharactersAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to send the SMS to the destined number.
     * param: inAddress: BD Address of Device
     * param: destinationNumber: This indicates destination number of the SMS
     * param: smsBody: Describes the body of SMS to be sent 	 		             returns:	This
     *   methods return success or failure        returns: contactName: Contact Name to
     *   which SMS is sent
     * Calls sendSMSByTemplateID with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void sendSMSByTemplateID(const std::string &_inAddress, const std::string &_destinationNumber, const uint8_t &_TemplateID, const std::string &_smsBody, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, std::string &_contactName, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls sendSMSByTemplateID with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> sendSMSByTemplateIDAsync(const std::string &_inAddress, const std::string &_destinationNumber, const uint8_t &_TemplateID, const std::string &_smsBody, SendSMSByTemplateIDAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to set the status of a sms (as READ/UNREAD).
     * param: inAddress: BD Address of Device
     * param: smsId: Unique sms identifier
     * param: read_status: The status value that needs to be set. The valid values are “READ”
     *   or “UNREAD” 	 		             returns: This method returns errorcode
     * Calls setSMSReadStatus with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSMSReadStatus(const std::string &_inAddress, const int64_t &_smsId, const bool &_sms_read_status, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSMSReadStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSMSReadStatusAsync(const std::string &_inAddress, const int64_t &_smsId, const bool &_sms_read_status, SetSMSReadStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This API is used to set the status of a SMS/Email (as READ/UNREAD).
     * param: inAddress: BD Address of Device
     * param: databaseType: Different database of Pim.Currently only available for "sms" or
     *   "email"
     * param: msgId: Unique SMS/Email identifier
     * param: msg_read_status: The status value that needs to be set. The valid values are
     *   “READ” or “UNREAD”         returns: This method returns errorcode         This
     *   is an extension of the setSMSReadStatus to support the preview of the
     *   message.Once this is implemented, setSMSReadStatus will be deprecated.
     * Calls setMsgReadStatus with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setMsgReadStatus(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, const bool &_msg_read_status, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setMsgReadStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setMsgReadStatusAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, const bool &_msg_read_status, SetMsgReadStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to set the sorted name order.
     * param: inAddress: BD Address of Device (Considered only if project support device
     *   specific sorting order)
     * param: contact Name order
     * Calls setFormattedNameOrder with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setFormattedNameOrder(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eContactNameOredr &_contactNameOrder, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setFormattedNameOrder with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setFormattedNameOrderAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eContactNameOredr &_contactNameOrder, SetFormattedNameOrderAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method is used to get the emergencyContactList for a particular device.   
     *                      For the connected phone emergency contact list will be
     *   available in the  EmergencyContactList attribute.                      For
     *   other phone client can use this interface.
     * param: btAddress: BD Address of Device (Considered only if project support device
     *   specific sorting order)
     * param: emergencyContactList : List of the Emergency contacts
     * Calls getEmergencyContacts with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getEmergencyContacts(const std::string &_btAddress, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::phonebook &_emergencyContactList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getEmergencyContacts with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getEmergencyContactsAsync(const std::string &_btAddress, GetEmergencyContactsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<PimDbHandlerProxyBase> delegate_;
};

typedef PimDbHandlerProxy<> PimDbHandlerProxyDefault;

namespace PimDbHandlerExtensions {
    /**
     * description: formattedNameOrder is sorted name order, which can be set from HMI
     */
    template <template <typename > class _ExtensionType>
    class ContactNameOrderAttributeExtension {
     public:
        typedef _ExtensionType<PimDbHandlerProxyBase::ContactNameOrderAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<PimDbHandlerProxyBase::ContactNameOrderAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        ContactNameOrderAttributeExtension() {}
    #endif
    
        ContactNameOrderAttributeExtension(PimDbHandlerProxyBase& proxy): attributeExtension_(proxy.getContactNameOrderAttribute()) {
        }
    
        inline extension_type& getContactNameOrderAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: DeviceList will contain list of paired device and their syncstatus
     */
    template <template <typename > class _ExtensionType>
    class DeviceListAttributeExtension {
     public:
        typedef _ExtensionType<PimDbHandlerProxyBase::DeviceListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<PimDbHandlerProxyBase::DeviceListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        DeviceListAttributeExtension() {}
    #endif
    
        DeviceListAttributeExtension(PimDbHandlerProxyBase& proxy): attributeExtension_(proxy.getDeviceListAttribute()) {
        }
    
        inline extension_type& getDeviceListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Emergency Contact List this will contain the list of Emergency contacts for the
     *   connected phone.
     */
    template <template <typename > class _ExtensionType>
    class EmergencyContactListAttributeExtension {
     public:
        typedef _ExtensionType<PimDbHandlerProxyBase::EmergencyContactListAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<PimDbHandlerProxyBase::EmergencyContactListAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        EmergencyContactListAttributeExtension() {}
    #endif
    
        EmergencyContactListAttributeExtension(PimDbHandlerProxyBase& proxy): attributeExtension_(proxy.getEmergencyContactListAttribute()) {
        }
    
        inline extension_type& getEmergencyContactListAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

    /**
     * description: Sms supported feature list, of connected phones
     */
    template <template <typename > class _ExtensionType>
    class SmsSupportedFeatureAttributeExtension {
     public:
        typedef _ExtensionType<PimDbHandlerProxyBase::SmsSupportedFeatureAttribute> extension_type;
    
        static_assert(std::is_base_of<typename CommonAPI::AttributeExtension<PimDbHandlerProxyBase::SmsSupportedFeatureAttribute>, extension_type>::value,
                      "Not CommonAPI Attribute Extension!");
    #ifdef WIN32
        SmsSupportedFeatureAttributeExtension() {}
    #endif
    
        SmsSupportedFeatureAttributeExtension(PimDbHandlerProxyBase& proxy): attributeExtension_(proxy.getSmsSupportedFeatureAttribute()) {
        }
    
        inline extension_type& getSmsSupportedFeatureAttributeExtension() {
            return attributeExtension_;
        }
    
     private:
        extension_type attributeExtension_;
    };

} // namespace PimDbHandlerExtensions

//
// PimDbHandlerProxy Implementation
//
template <typename ... _AttributeExtensions>
PimDbHandlerProxy<_AttributeExtensions...>::PimDbHandlerProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<PimDbHandlerProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<PimDbHandlerProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
PimDbHandlerProxy<_AttributeExtensions...>::~PimDbHandlerProxy() {
}

/**
 * description: Opens a session for the client communication. This session will be used
 *   internally to uniquely identify a client, and to maintain client specific
 *   caches.                      The client need not create a new session for
 *   every request, this is rather used to identify different instances of clients.
 *                                   returns: sessionID: Session identifier
 *   allocated to the client.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::openSession(const std::string &_inAddress, CommonAPI::CallStatus &_internalCallStatus, uint8_t &_sessionID, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_ErrorCode, const CommonAPI::CallInfo *_info) {
    delegate_->openSession(_inAddress, _internalCallStatus, _sessionID, _ErrorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::openSessionAsync(const std::string &_inAddress, OpenSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->openSessionAsync(_inAddress, _callback, _info);
}
/**
 * description: Close a client session and release all associated resources.
 * param: sessionID: The Session ID to close.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::closeSession(const uint8_t &_sessionID, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_ErrorCode, const CommonAPI::CallInfo *_info) {
    delegate_->closeSession(_sessionID, _internalCallStatus, _ErrorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::closeSessionAsync(const uint8_t &_sessionID, CloseSessionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->closeSessionAsync(_sessionID, _callback, _info);
}
/**
 * description: Sets a session query. This api handles all requests to fetch Phonebook results,
 *   database searches, etc.                       As an example. If the HMI wanted
 *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
 *   and the result type would be set to Required field list.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters: The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: Session ID obtained from OpenSession.
 * param: databaseType: Related database for this sessionquery.
 * param: RequiredField: List of required field , if default is set browsing item will be
 *   sent with default avlues based on config
 * param: resetPrevious: Whether to use old history or not.If true treat this as a new
 *   session query, do not use any old selection history.
 * param: AutoUpdateEnabled: This is applicable for result sets which might update
 *   dynamically,Call stack or Fav list
 * param: AlphaJumpTable: This is applicable only for phonebook, to get the alphajump
 *   table phonebook entries						         returns: numResults: The number of
 *   records matching the search criteria.        returns: SessionQueryID:The
 *   sessionQueryID allotted.This uniquely identifies a particular session
 *   query/filter for retrieving data in a session and it has to be passed         
 *                           for furthur setting the sessionQuery window and
 *   retrieving the contents of that window.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setSessionQuery(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint32_t &_numResults, uint8_t &_sessionQueryID, uint8_t &_unreadCount, ::v7::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setSessionQuery(_sessionID, _databaseType, _filterIDs, _filters, _RequiredField, _resetPrevious, _AutoUpdateEnabled, _AlphaJumpTable, _internalCallStatus, _errorCode, _numResults, _sessionQueryID, _unreadCount, _alphaList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setSessionQueryAsync(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, SetSessionQueryAsyncCallback_9708 _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        uint32_t numResults = 0ul;
        uint8_t sessionQueryID = 0u;
        uint8_t unreadCount = 0u;
        ::v7::com::harman::btpres::BTPresTypes::alphaJumpList alphaList = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, numResults, sessionQueryID, unreadCount, alphaList);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setSessionQueryAsync(_sessionID, _databaseType, _filterIDs, _filters, _RequiredField, _resetPrevious, _AutoUpdateEnabled, _AlphaJumpTable, _callback, _info);
}
/**
 * description: Sets a session query. This api handles all requests to fetch Phonebook results,
 *   database searches, etc.                       As an example. If the HMI wanted
 *   to fetch a list of all contacts. The filterID's' and filter's' will be empty,
 *   and the result type would be set to Required field list.
 * param: filterIDs: The previously communicated numeric identifiers of the different
 *   filter categories.
 * param: filters: The string filters which should be applied to the result.
 * param: resultType: The data which is expected from the query.
 * param: sessionID: Session ID obtained from OpenSession.
 * param: databaseType: Related database for this sessionquery.
 * param: RequiredField: List of required field , if default is set browsing item will be
 *   sent with default avlues based on config
 * param: resetPrevious: Whether to use old history or not.If true treat this as a new
 *   session query, do not use any old selection history.
 * param: AutoUpdateEnabled: This is applicable for result sets which might update
 *   dynamically,Call stack or Fav list
 * param: AlphaJumpTable: This is applicable only for phonebook, to get the alphajump
 *   table for phonebook
 * param: NextValidChar: This is applicable while searching phonebook entries from smart
 *   search keyboard
 * param: numberOfItems: it provides number of entries from possible phonebook entries
 *   for searchString, it is considered only if NextValidChar is set to true
 *   							                returns: numResults: The number of records matching the
 *   search criteria.        returns: SessionQueryID:The sessionQueryID
 *   allotted.This uniquely identifies a particular session query/filter for
 *   retrieving data in a session and it has to be passed                          
 *          for furthur setting the sessionQuery window and retrieving the contents
 *   of that window.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setSessionQuery(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, const bool &_NextValidChar, const uint8_t &_numberOfItems, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint32_t &_numResults, uint8_t &_sessionQueryID, uint8_t &_unreadCount, ::v7::com::harman::btpres::BTPresTypes::alphaJumpList &_alphaList, std::string &_possibleCharList, ::v7::com::harman::btpres::BTPresTypes::phonebook &_phonebookList, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setSessionQuery(_sessionID, _databaseType, _filterIDs, _filters, _RequiredField, _resetPrevious, _AutoUpdateEnabled, _AlphaJumpTable, _NextValidChar, _numberOfItems, _internalCallStatus, _errorCode, _numResults, _sessionQueryID, _unreadCount, _alphaList, _possibleCharList, _phonebookList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setSessionQueryAsync(const uint8_t &_sessionID, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_filterIDs, const ::v7::com::harman::btpres::BTPresTypes::filterMap &_filters, const ::v7::com::harman::btpres::BTPresTypes::requiredFieldMap &_RequiredField, const bool &_resetPrevious, const bool &_AutoUpdateEnabled, const bool &_AlphaJumpTable, const bool &_NextValidChar, const uint8_t &_numberOfItems, SetSessionQueryAsyncCallback_8354 _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        uint32_t numResults = 0ul;
        uint8_t sessionQueryID = 0u;
        uint8_t unreadCount = 0u;
        ::v7::com::harman::btpres::BTPresTypes::alphaJumpList alphaList = {};
        std::string possibleCharList = "";
        ::v7::com::harman::btpres::BTPresTypes::phonebook phonebookList = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, numResults, sessionQueryID, unreadCount, alphaList, possibleCharList, phonebookList);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setSessionQueryAsync(_sessionID, _databaseType, _filterIDs, _filters, _RequiredField, _resetPrevious, _AutoUpdateEnabled, _AlphaJumpTable, _NextValidChar, _numberOfItems, _callback, _info);
}
/**
 * description: Essentially re-initializes a session query and stops all background tasks.
 * param: sessionID: The Session ID alloted.
 * param: sessionID: The Session Query ID alloted for that particular session.This
 *   uniquely identifies a particular session query/filter for retrieving data in a
 *   session.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::cancelSessionQuery(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->cancelSessionQuery(_sessionID, _sessionQueryID, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::cancelSessionQueryAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, CancelSessionQueryAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->cancelSessionQueryAsync(_sessionID, _sessionQueryID, _callback, _info);
}
/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override                      the last request given to Pres Ctrl.
 * param: sessionID: The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed                                 for furthur setting the sessionQuery
 *   window and retrieving the contents of that window.
 * param: startIndex: The index to start fetching.
 * param: numItems: The number of items to fetch.                       returns:
 *   windowID: A unique identifier for the client to track data responses to the
 *   queries. sessionQueryWindowUpdate version 1.0 will be emitted
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setSessionQueryWindow(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setSessionQueryWindow(_sessionID, _sessionQueryID, _startIndex, _numItems, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setSessionQueryWindowAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, SetSessionQueryWindowAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSessionQueryWindowAsync(_sessionID, _sessionQueryID, _startIndex, _numItems, _callback, _info);
}
/**
 * description: Ask presentation control to fetch the desired set of entries for a particular
 *   session query. This call does not block for the result to complete, and will
 *   override                      the last request given to Pres Ctrl.
 * param: sessionID: The Session ID alloted.
 * param: sessionQueryID: The sessionQueryID allotted.This uniquely identifies a
 *   particular session query/filter for retrieving data in a session and it has to
 *   be passed                                for furthur setting the sessionQuery
 *   window and retrieving the contents of that window.
 * param: startIndex: The index to start fetching.
 * param: numItems: The number of items to fetch.
 * param: folder: This parameter is applicable only for message browsing. 	          
 *   returns: windowID: A unique identifier for the client to track data responses
 *   to the queries. sessionQueryWindowUpdate version 1.0 will be emitted        
 *   This is an extension of the setSessionQueryWindow to support messages from
 *   folder. Once this is implemented, sessionQueryUpdate will be deprecated.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setSessionQueryWindow(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const std::string &_folder, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setSessionQueryWindow(_sessionID, _sessionQueryID, _startIndex, _numItems, _folder, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setSessionQueryWindowAsync(const uint8_t &_sessionID, const uint8_t &_sessionQueryID, const uint16_t &_startIndex, const uint8_t &_numItems, const std::string &_folder, SetSessionQueryWindowAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSessionQueryWindowAsync(_sessionID, _sessionQueryID, _startIndex, _numItems, _folder, _callback, _info);
}
/**
 * description: This method is used for inserting/deleting/update entries to Favourite list ,
 *   Emergency List , SMS Template                       This method also can be
 *   used for Manual Update.Manual update currently only supported for Contact, CC
 *   , SMS                       This method is also can be used to reset SMS
 *   Template list . In that case all customized message will be removed system
 *   will contain only default sms template list
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim, Only Fav is allowed
 * param: requestID: Different type of user initiated DB operation. If requestID is
 *   MANUAL_SYNC/RESET_TO_DEFAULT/DELETE_ALL_FROM_DB, itemDetails field is not
 *   required.
 * param: itemDetails: This list contains contactID list, NewPhonebook entry,
 *   SMSTemplateID list, SMStemplate. This structure is mandatory for inserting,
 *   deleting         Use Case: To insert some of the contacts from Phonebook to
 *   FAV/EMERGENCY contact list itemDetails structures only ContactIdList field is
 *   required. request Id should be INSERT_INTO_DB_BY_CONTACT_ID        Use Case:
 *   To insert customize Phonebook to FAV/EMERGENCY contact list itemDetails
 *   structures only contactInfo field is required. requestID should be INSERT_NEW 
 *         Use Case: To insert customize sms template to sms template list ,
 *   itemDetails structures only SMSTemplate is required. requestID should be
 *   INSERT_NEW        Use Case: To update customize sms template to sms template
 *   list , itemDetails structures SMSTemplate and  SMSTemplateIdList is required.
 *   SMSTemplateIdList should contain only one index value                  
 *   requestId should be UPDATE_ENTRY        Use Case: To update emergency contact
 *   list entry , itemDetails structures phonebookEntry and  ContactIdList is
 *   required. ContactIdList should contain only one index value                  
 *   requestId should be UPDATE_ENTRY                              	 		            
 *   returns: This method returns errorcode
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::dbOperation(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::eDbOperationId &_requestID, const ::v7::com::harman::btpres::BTPresTypes::InsertItems &_itemDetails, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    if (!_requestID.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->dbOperation(_inAddress, _databaseType, _requestID, _itemDetails, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::dbOperationAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const ::v7::com::harman::btpres::BTPresTypes::eDbOperationId &_requestID, const ::v7::com::harman::btpres::BTPresTypes::InsertItems &_itemDetails, DbOperationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    if (!_requestID.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->dbOperationAsync(_inAddress, _databaseType, _requestID, _itemDetails, _callback, _info);
}
/**
 * description: This API can be used to get Contact Name by contactID
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim.Currently only available for "pb" or
 *   "ab"
 * param: contactID: contactID for which contact details should be extracted
 * param: fieldList: Required filedlist using bit masking () 	 		             returns:	  
 *    phonebookEntry which will contain all the field
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::getContactsByID(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const uint32_t &_contactID, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_FieldList, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::phonebookEntry &_detailedContact, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->getContactsByID(_inAddress, _databaseType, _contactID, _FieldList, _internalCallStatus, _errorCode, _detailedContact, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::getContactsByIDAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const uint32_t &_contactID, const ::v7::com::harman::btpres::BTPresTypes::phonebookResultMap &_FieldList, GetContactsByIDAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        ::v7::com::harman::btpres::BTPresTypes::phonebookEntry detailedContact = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, detailedContact);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->getContactsByIDAsync(_inAddress, _databaseType, _contactID, _FieldList, _callback, _info);
}
/**
 * description: This API can be used to get complete contact details,  by Name or EMAIL or
 *   Number
 * param: SearchCriteria :  Criteria of Search        Use case : This should be used only
 *   if there is a need for search exact match by Name or Email                    
 *                  returns:       phonebookEntry which will contain all the field
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::getDetailedContact(const ::v7::com::harman::btpres::BTPresTypes::sSearchCriteria &_SearchCriteria, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::phonebook &_detailedContact, const CommonAPI::CallInfo *_info) {
    delegate_->getDetailedContact(_SearchCriteria, _internalCallStatus, _errorCode, _detailedContact, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::getDetailedContactAsync(const ::v7::com::harman::btpres::BTPresTypes::sSearchCriteria &_SearchCriteria, GetDetailedContactAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getDetailedContactAsync(_SearchCriteria, _callback, _info);
}
/**
 * description: This API is used to get the full details of the SMS; this takes a unique id as
 *   input, which is received from the signal
 * param: inAddress: BD Address of Device
 * param: smsId: Unique id for SMS that is returned as part of the signal (multiple uid’s
 *   can be sent, separated) 	 		             returns: This method returns SMS entry
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::getSMSById(const std::string &_inAddress, const int64_t &_smsId, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::smsEntry &_sms, const CommonAPI::CallInfo *_info) {
    delegate_->getSMSById(_inAddress, _smsId, _internalCallStatus, _errorCode, _sms, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::getSMSByIdAsync(const std::string &_inAddress, const int64_t &_smsId, GetSMSByIdAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSMSByIdAsync(_inAddress, _smsId, _callback, _info);
}
/**
 * description: This API is used to get the full details of the SMS/Email; this takes a unique
 *   id as input, which is received from the signal
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim.Currently only available for "sms" or
 *   "email"
 * param: msgId: Unique id for SMS/Email that is returned as part of the signal (multiple
 *   uid’s can be sent, separated)         returns: This method returns SMS/Email
 *   entry         This is an extension of the getSMSById to support the preview of
 *   the message.Once this is implemented, getSMSById will be deprecated.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::getMsgById(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::msgEntry &_msg, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->getMsgById(_inAddress, _databaseType, _msgId, _internalCallStatus, _errorCode, _msg, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::getMsgByIdAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, GetMsgByIdAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        ::v7::com::harman::btpres::BTPresTypes::msgEntry msg = {};
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, msg);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->getMsgByIdAsync(_inAddress, _databaseType, _msgId, _callback, _info);
}
/**
 * description: This API can be used to get the following details on either phonebook          
 *               1.	The next valid characters mask that match the input string.    
 *                    2.	The count of the names that matched the input string.     
 *                   3.	The index of the first match of the input string sorted by
 *   givenName column. (This index can be used in getItems API to query for the
 *   details but the same sort criteria need to be applied).
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim. Currently only available for Pb or ab
 * param: inputName: String to be searched
 * param: sortOrder: ascending or descending
 * param: condition: either or all based on notnullcolumnList         	 		            
 *   returns:      contactsCount:The count of the names that matched the input
 *   string.        returns:      index:The index of the first match of the input
 *   string sorted by formattedName column.        returns:      charactersMask:The
 *   next valid characters mask that match the input string.        returns:     
 *   firstMatch:The “formattedName” of the first matched contact
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::getNextValidCharacters(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const std::string &_inputName, const std::string &_sortOrder, const std::string &_condition, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, uint16_t &_contactsCount, uint16_t &_index, std::string &_charactersMask, std::string &_firstMatch, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->getNextValidCharacters(_inAddress, _databaseType, _inputName, _sortOrder, _condition, _internalCallStatus, _errorCode, _contactsCount, _index, _charactersMask, _firstMatch, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::getNextValidCharactersAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const std::string &_inputName, const std::string &_sortOrder, const std::string &_condition, GetNextValidCharactersAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        uint16_t contactsCount = 0u;
        uint16_t index = 0u;
        std::string charactersMask = "";
        std::string firstMatch = "";
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode, contactsCount, index, charactersMask, firstMatch);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->getNextValidCharactersAsync(_inAddress, _databaseType, _inputName, _sortOrder, _condition, _callback, _info);
}
/**
 * description: This API is used to send the SMS to the destined number.
 * param: inAddress: BD Address of Device
 * param: destinationNumber: This indicates destination number of the SMS
 * param: smsBody: Describes the body of SMS to be sent 	 		             returns:	This
 *   methods return success or failure        returns: contactName: Contact Name to
 *   which SMS is sent
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::sendSMSByTemplateID(const std::string &_inAddress, const std::string &_destinationNumber, const uint8_t &_TemplateID, const std::string &_smsBody, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, std::string &_contactName, const CommonAPI::CallInfo *_info) {
    delegate_->sendSMSByTemplateID(_inAddress, _destinationNumber, _TemplateID, _smsBody, _internalCallStatus, _errorCode, _contactName, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::sendSMSByTemplateIDAsync(const std::string &_inAddress, const std::string &_destinationNumber, const uint8_t &_TemplateID, const std::string &_smsBody, SendSMSByTemplateIDAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->sendSMSByTemplateIDAsync(_inAddress, _destinationNumber, _TemplateID, _smsBody, _callback, _info);
}
/**
 * description: This API is used to set the status of a sms (as READ/UNREAD).
 * param: inAddress: BD Address of Device
 * param: smsId: Unique sms identifier
 * param: read_status: The status value that needs to be set. The valid values are “READ”
 *   or “UNREAD” 	 		             returns: This method returns errorcode
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setSMSReadStatus(const std::string &_inAddress, const int64_t &_smsId, const bool &_sms_read_status, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    delegate_->setSMSReadStatus(_inAddress, _smsId, _sms_read_status, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setSMSReadStatusAsync(const std::string &_inAddress, const int64_t &_smsId, const bool &_sms_read_status, SetSMSReadStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSMSReadStatusAsync(_inAddress, _smsId, _sms_read_status, _callback, _info);
}
/**
 * description: This API is used to set the status of a SMS/Email (as READ/UNREAD).
 * param: inAddress: BD Address of Device
 * param: databaseType: Different database of Pim.Currently only available for "sms" or
 *   "email"
 * param: msgId: Unique SMS/Email identifier
 * param: msg_read_status: The status value that needs to be set. The valid values are
 *   “READ” or “UNREAD”         returns: This method returns errorcode         This
 *   is an extension of the setSMSReadStatus to support the preview of the
 *   message.Once this is implemented, setSMSReadStatus will be deprecated.
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setMsgReadStatus(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, const bool &_msg_read_status, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setMsgReadStatus(_inAddress, _databaseType, _msgId, _msg_read_status, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setMsgReadStatusAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eDatabaseType &_databaseType, const int64_t &_msgId, const bool &_msg_read_status, SetMsgReadStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_databaseType.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setMsgReadStatusAsync(_inAddress, _databaseType, _msgId, _msg_read_status, _callback, _info);
}
/**
 * description: This method is used to set the sorted name order.
 * param: inAddress: BD Address of Device (Considered only if project support device
 *   specific sorting order)
 * param: contact Name order
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::setFormattedNameOrder(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eContactNameOredr &_contactNameOrder, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, const CommonAPI::CallInfo *_info) {
    if (!_contactNameOrder.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setFormattedNameOrder(_inAddress, _contactNameOrder, _internalCallStatus, _errorCode, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::setFormattedNameOrderAsync(const std::string &_inAddress, const ::v7::com::harman::btpres::BTPresTypes::eContactNameOredr &_contactNameOrder, SetFormattedNameOrderAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_contactNameOrder.validate()) {
        ::v7::com::harman::btpres::BTPresTypes::eErrorType errorCode = ::v7::com::harman::btpres::BTPresTypes::eErrorType::ERROR_TYPE_SUCCESS;
        _callback(CommonAPI::CallStatus::INVALID_VALUE, errorCode);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setFormattedNameOrderAsync(_inAddress, _contactNameOrder, _callback, _info);
}
/**
 * description: This method is used to get the emergencyContactList for a particular device.   
 *                      For the connected phone emergency contact list will be
 *   available in the  EmergencyContactList attribute.                      For
 *   other phone client can use this interface.
 * param: btAddress: BD Address of Device (Considered only if project support device
 *   specific sorting order)
 * param: emergencyContactList : List of the Emergency contacts
 */
template <typename ... _AttributeExtensions>
void PimDbHandlerProxy<_AttributeExtensions...>::getEmergencyContacts(const std::string &_btAddress, CommonAPI::CallStatus &_internalCallStatus, ::v7::com::harman::btpres::BTPresTypes::eErrorType &_errorCode, ::v7::com::harman::btpres::BTPresTypes::phonebook &_emergencyContactList, const CommonAPI::CallInfo *_info) {
    delegate_->getEmergencyContacts(_btAddress, _internalCallStatus, _errorCode, _emergencyContactList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> PimDbHandlerProxy<_AttributeExtensions...>::getEmergencyContactsAsync(const std::string &_btAddress, GetEmergencyContactsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getEmergencyContactsAsync(_btAddress, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &PimDbHandlerProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool PimDbHandlerProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool PimDbHandlerProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& PimDbHandlerProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& PimDbHandlerProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace btpres
} // namespace harman
} // namespace com
} // namespace v5

namespace CommonAPI {
template<template<typename > class _AttributeExtension>
struct DefaultAttributeProxyHelper<::v5::com::harman::btpres::PimDbHandlerProxy,
    _AttributeExtension> {
    typedef typename ::v5::com::harman::btpres::PimDbHandlerProxy<
            ::v5::com::harman::btpres::PimDbHandlerExtensions::ContactNameOrderAttributeExtension<_AttributeExtension>, 
            ::v5::com::harman::btpres::PimDbHandlerExtensions::DeviceListAttributeExtension<_AttributeExtension>, 
            ::v5::com::harman::btpres::PimDbHandlerExtensions::EmergencyContactListAttributeExtension<_AttributeExtension>, 
            ::v5::com::harman::btpres::PimDbHandlerExtensions::SmsSupportedFeatureAttributeExtension<_AttributeExtension>
    > class_t;
};
}


// Compatibility
namespace v5_1 = v5;

#endif // V5_COM_HARMAN_BTPRES_Pim_Db_Handler_PROXY_HPP_
